CCS PCM C Compiler, Version 3.060, 12652

               Filename: D:\DEVELOP\MIDICO~1\MIDICO~1\CODE\MIDICONT.LST

               ROM used: 7075 (86%)
                         Largest free fragment is 921
               RAM used: 114 (65%) at main() level
                         173 (99%) worst case
               Stack:    7 worst case (5 in main + 2 for interrupts)

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   3C3
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  BCF    03.5
0007:  BCF    03.6
0008:  MOVWF  21
0009:  MOVF   0A,W
000A:  MOVWF  20
000B:  CLRF   0A
000C:  MOVF   04,W
000D:  MOVWF  22
000E:  MOVF   77,W
000F:  MOVWF  23
0010:  MOVF   78,W
0011:  MOVWF  24
0012:  MOVF   79,W
0013:  MOVWF  25
0014:  MOVF   7A,W
0015:  MOVWF  26
0016:  MOVF   7B,W
0017:  MOVWF  27
0018:  BCF    03.7
0019:  BCF    03.5
001A:  MOVLW  8C
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  0C.5
001F:  GOTO   033
0020:  MOVF   22,W
0021:  MOVWF  04
0022:  MOVF   23,W
0023:  MOVWF  77
0024:  MOVF   24,W
0025:  MOVWF  78
0026:  MOVF   25,W
0027:  MOVWF  79
0028:  MOVF   26,W
0029:  MOVWF  7A
002A:  MOVF   27,W
002B:  MOVWF  7B
002C:  MOVF   20,W
002D:  MOVWF  0A
002E:  SWAPF  21,W
002F:  MOVWF  03
0030:  SWAPF  7F,F
0031:  SWAPF  7F,W
0032:  RETFIE
0033:  BCF    0A.3
0034:  BCF    0A.4
0035:  GOTO   04C
....................  /******************************************************************************* 
.................... *	Author: Angelo Fraietta 
.................... *	Description: General Purpose Midi controller 
.................... *	Processor PIC16F877 
.................... *	Specifications: 
.................... *		16 Digital input to Midi Output (SPI) 
.................... *		16 Analogue input to Midi Output (ADC) 
.................... *		Midi input to Midi output merge (UART) 
.................... *   Midi input to 16 Analogue ouput (I2C) 
.................... * 
.................... *******************************************************************************/ 
....................  
.................... #include "16f877.h" 
....................  //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
.................... 
.................... #device adc=10 
.................... #fuses HS, WDT, BROWNOUT, PUT, NOLVP, PROTECT 
....................  
.................... //#define _SIMULATE 
.................... #define QUEUE_SIZE  40 // we make this as big as we can until we run out of Ram 
....................  
.................... // define pins for SPI input reads and output writes 
.................... #define SPI_IN_LATCH      PIN_C2 
.................... #define SPI_CLOCK         PIN_C3 
.................... #define SPI_DATA_OUT      PIN_D1 
.................... #define DIGITAL_OUT_LATCH PIN_D2 
....................   
....................  
.................... #define DIGITAL_IN_DATA PIN_C4 
.................... #define MIDI_CONTROLLER_BUILD 
....................  
.................... #ifdef _SIMULATE 
.................... #define _NO_DELAY 
.................... #else 
.................... #define _USE_PRINTF 
.................... #endif 
....................  
.................... #define NUM_ANALOGUE_OUT 8 
.................... #define NUM_DIGITAL_OUT 16 
....................  
....................  
.................... #use delay(clock=20000000) 
*
00FD:  MOVLW  B8
00FE:  MOVWF  04
00FF:  MOVF   00,W
0100:  BTFSC  03.2
0101:  GOTO   10F
0102:  MOVLW  06
0103:  MOVWF  78
0104:  CLRF   77
0105:  DECFSZ 77,F
0106:  GOTO   105
0107:  DECFSZ 78,F
0108:  GOTO   104
0109:  MOVLW  7B
010A:  MOVWF  77
010B:  DECFSZ 77,F
010C:  GOTO   10B
010D:  DECFSZ 00,F
010E:  GOTO   102
010F:  RETLW  00
....................  
.................... #define MIDIOUT_1_PIN PIN_C6 
.................... #define MIDIOUT_2_PIN PIN_C5 
.................... #define MIDI_IN_PIN PIN_C7 
.................... //#define BLUETOOTH_OUT_PIN PIN_D3 
.................... #define BLUETOOTH_OUT_PIN MIDIOUT_2_PIN 
....................  
.................... #define WATCHDOG_OVERFLOW_COUNT   255 
.................... #define WATCHDOG_NORMAL_COUNT     5000L 
....................  
.................... #define NUM_ANALOGUE_IN_BANKS 2 
.................... #define NUM_ANALOGUE_IN_SUB_BANKS 8 
.................... #define NUM_ANALOGUE_IN_CHANS (NUM_ANALOGUE_IN_BANKS * NUM_ANALOGUE_IN_SUB_BANKS) 
.................... #define AD_READ_DELAY 20 // num us to delay from setting channel to making read 
.................... #define AD_SWITCH_DELAY 1 // num us to wait between switching analog switch to reading 
.................... #define NUM_ANALOG_VALID_READS 2 // must be this many identical reads to be a valid input 
....................  
.................... #define SEVEN_BIT_AD 
....................  
.................... #ifdef SEVEN_BIT_AD 
.................... #define DIG_ON_VAL 0x7f 
.................... #else 
.................... #define DIG_ON_VAL 0xff 
.................... #endif 
....................  
.................... #byte PORTA = 5 
.................... #byte PORTB = 6 
.................... #byte PORTC = 7 
....................  
....................  
.................... #use rs232(baud=31250, xmit=MIDIOUT_1_PIN, rcv=MIDI_IN_PIN, ERRORS)  
*
003E:  BTFSS  0C.5
003F:  GOTO   03E
0040:  MOVF   18,W
0041:  MOVWF  28
0042:  MOVF   1A,W
0043:  MOVWF  78
0044:  BTFSS  28.1
0045:  GOTO   048
0046:  BCF    18.4
0047:  BSF    18.4
0048:  NOP
0049:  BCF    0A.3
004A:  BCF    0A.4
004B:  GOTO   04D (RETURN)
....................  
.................... #USE I2C(master, sda=PIN_B7, scl=PIN_B6) 
*
02E4:  MOVLW  08
02E5:  MOVWF  78
02E6:  NOP
02E7:  MOVLW  04
02E8:  MOVWF  77
02E9:  DECFSZ 77,F
02EA:  GOTO   2E9
02EB:  BCF    06.6
02EC:  BSF    03.5
02ED:  BCF    06.6
02EE:  MOVLW  06
02EF:  MOVWF  77
02F0:  BCF    03.5
02F1:  DECFSZ 77,F
02F2:  GOTO   2F1
02F3:  BSF    03.5
02F4:  RLF    6B,F
02F5:  BCF    03.5
02F6:  BCF    06.7
02F7:  BTFSS  03.0
02F8:  GOTO   2FC
02F9:  BSF    03.5
02FA:  BSF    06.7
02FB:  BCF    03.5
02FC:  BTFSC  03.0
02FD:  GOTO   301
02FE:  BSF    03.5
02FF:  BCF    06.7
0300:  BCF    03.5
0301:  BSF    03.5
0302:  BSF    06.6
0303:  BCF    03.5
0304:  BTFSS  06.6
0305:  GOTO   304
0306:  DECFSZ 78,F
0307:  GOTO   2E6
0308:  MOVLW  04
0309:  MOVWF  77
030A:  DECFSZ 77,F
030B:  GOTO   30A
030C:  BCF    06.6
030D:  BSF    03.5
030E:  BCF    06.6
030F:  NOP
0310:  BSF    06.7
0311:  MOVLW  06
0312:  MOVWF  77
0313:  BCF    03.5
0314:  DECFSZ 77,F
0315:  GOTO   314
0316:  MOVLW  06
0317:  MOVWF  77
0318:  DECFSZ 77,F
0319:  GOTO   318
031A:  BSF    03.5
031B:  BSF    06.6
031C:  BCF    03.5
031D:  BTFSS  06.6
031E:  GOTO   31D
031F:  CLRF   78
0320:  MOVLW  06
0321:  MOVWF  77
0322:  DECFSZ 77,F
0323:  GOTO   322
0324:  BTFSC  06.7
0325:  BSF    78.0
0326:  BCF    06.6
0327:  BSF    03.5
0328:  BCF    06.6
0329:  BCF    03.5
032A:  BCF    06.7
032B:  BSF    03.5
032C:  BCF    06.7
032D:  BCF    03.5
032E:  RETLW  00
.................... #include "sysexcommands.h" 
....................  #ifndef _SYSEXCAMMANDS_H 
.................... #define _SYSEXCAMMANDS_H 
....................  
.................... #define BASIC_MIDI_CONTROLLER 0x00 
.................... #define SMART_CONTROLLER      0x01 
....................  
.................... // define SYSEX ID education/ research 
.................... #define SYSEX_ID 0x7D 
.................... #define EQUIPMENT_TYPE BASIC_MIDI_CONTROLLER 
.................... #define ANY_DEVICE_ID_NUM 0xff // any device will respond 
....................  
....................  
.................... // define the numbers of the bytes within a sysyex message 
.................... #define SYSEX_ID_NUM 1 
.................... #define SYSEX_EQUIPMENT_NUM 2 
.................... #define SYSEX_DEVICE_NUM 3 
.................... #define SYSEX_COMMAND_NUM 4 
.................... #define SYSEX_CONGIG_INDEX_NUM 5 
....................  
....................  
.................... // define COMMANDS 
.................... #define READ_CONFIG_BYTE 0 
.................... #define WRITE_CONGFIG_BYTE 1 
.................... #define FACTORY_DEFAULT 2 
.................... #define WRITE_ACKNOWLEDGE 3 
....................  
....................  
.................... #define SYSEX_BEGIN 0xF0 
.................... #define SYSEX_END 0xF7 
.................... #define SYSTEM_RESET 0xFF 
.................... #define SYSTEM_QUARTER_FRAME 0xF1 
.................... #define SYSTEM_SONG_POS 0xF2 
.................... #define SYSTEM_SONG_SELECT 0xF3 
....................  
....................  
.................... #define STATUS_BYTE_MASK 0x80  
.................... #define SYSTEM_MSG_VAL 0xF0 
.................... #define STATUS_NIBBLE_MASK 0xF0 
....................  
.................... #endif 
....................  
....................  
....................  
.................... 
.................... #include "midiDrv.h" 
....................  /******************************************************************* 
....................  * Module for encoding and decoding a data stream from transmission 
....................  * through a Midi sysex block 
....................  * The main issue is preventing any bytes with a MSB of 1 from being  
....................  * transmitted inside a Midi stream. 
....................  *******************************************************************/ 
.................... #ifndef MIDIDRV_H 
.................... #define MIDIDRV_H 
....................  
.................... // define control characters 
.................... #define MIDIDRV_MODMSB 0x01 // the following char must have MSB set 
.................... #define MIDIDRV_NOMOD 0x02 // the following char is not a control char 
....................  
.................... /***************************************************************************** 
....................  * Author: A. Fraietta 
....................  * Function: EncodeMidiByte 
....................  * Purpose:  Determine whether a control character is required for a character 
....................  *           And if so, modify the input character and return the control  
....................  *           char value 
....................  * Input:    char_to_tx - address of char that needs to be transmitted (also Op) 
....................  * Output:   char_to_tx - the new value of character that will be transmitted 
....................  * Returns:  a control char if required, otherwise zero 
....................  ******************************************************************************/ 
.................... #pragma inline 
.................... byte EncodeMidiByte (byte *char_to_tx) 
.................... { 
....................   byte ret; 
....................  
....................   if (*char_to_tx & 0x80) // Msb is 1 
*
01D9:  BSF    03.5
01DA:  MOVF   5D,W
01DB:  MOVWF  04
01DC:  MOVF   00,W
01DD:  ANDLW  80
01DE:  XORLW  00
01DF:  BTFSS  03.2
01E0:  GOTO   1E3
01E1:  BCF    03.5
01E2:  GOTO   1EE
01E3:  BCF    03.5
*
0233:  BSF    03.5
0234:  MOVF   5D,W
0235:  MOVWF  04
0236:  MOVF   00,W
0237:  ANDLW  80
0238:  XORLW  00
0239:  BTFSS  03.2
023A:  GOTO   23D
023B:  BCF    03.5
023C:  GOTO   248
023D:  BCF    03.5
*
0290:  BSF    03.5
0291:  MOVF   5D,W
0292:  MOVWF  04
0293:  MOVF   00,W
0294:  ANDLW  80
0295:  XORLW  00
0296:  BTFSS  03.2
0297:  GOTO   29A
0298:  BCF    03.5
0299:  GOTO   2A5
029A:  BCF    03.5
*
08F7:  BSF    03.5
08F8:  MOVF   5D,W
08F9:  MOVWF  04
08FA:  MOVF   00,W
08FB:  ANDLW  80
08FC:  XORLW  00
08FD:  BTFSS  03.2
08FE:  GOTO   101
08FF:  BCF    03.5
0900:  GOTO   10C
0901:  BCF    03.5
*
095F:  BSF    03.5
0960:  MOVF   5D,W
0961:  MOVWF  04
0962:  MOVF   00,W
0963:  ANDLW  80
0964:  XORLW  00
0965:  BTFSS  03.2
0966:  GOTO   169
0967:  BCF    03.5
0968:  GOTO   174
0969:  BCF    03.5
*
09BD:  BSF    03.5
09BE:  MOVF   5D,W
09BF:  MOVWF  04
09C0:  MOVF   00,W
09C1:  ANDLW  80
09C2:  XORLW  00
09C3:  BTFSS  03.2
09C4:  GOTO   1C7
09C5:  BCF    03.5
09C6:  GOTO   1D2
09C7:  BCF    03.5
*
0A29:  BSF    03.5
0A2A:  MOVF   5D,W
0A2B:  MOVWF  04
0A2C:  MOVF   00,W
0A2D:  ANDLW  80
0A2E:  XORLW  00
0A2F:  BTFSS  03.2
0A30:  GOTO   233
0A31:  BCF    03.5
0A32:  GOTO   23E
0A33:  BCF    03.5
*
0A97:  BSF    03.5
0A98:  MOVF   5D,W
0A99:  MOVWF  04
0A9A:  MOVF   00,W
0A9B:  ANDLW  80
0A9C:  XORLW  00
0A9D:  BTFSS  03.2
0A9E:  GOTO   2A1
0A9F:  BCF    03.5
0AA0:  GOTO   2AC
0AA1:  BCF    03.5
....................     { 
....................       *char_to_tx &= 0x7F; // clear MSB 
*
01E4:  BSF    03.5
01E5:  MOVF   5D,W
01E6:  MOVWF  04
01E7:  MOVF   00,W
01E8:  ANDLW  7F
01E9:  MOVWF  00
*
023E:  BSF    03.5
023F:  MOVF   5D,W
0240:  MOVWF  04
0241:  MOVF   00,W
0242:  ANDLW  7F
0243:  MOVWF  00
*
029B:  BSF    03.5
029C:  MOVF   5D,W
029D:  MOVWF  04
029E:  MOVF   00,W
029F:  ANDLW  7F
02A0:  MOVWF  00
*
0902:  BSF    03.5
0903:  MOVF   5D,W
0904:  MOVWF  04
0905:  MOVF   00,W
0906:  ANDLW  7F
0907:  MOVWF  00
*
096A:  BSF    03.5
096B:  MOVF   5D,W
096C:  MOVWF  04
096D:  MOVF   00,W
096E:  ANDLW  7F
096F:  MOVWF  00
*
09C8:  BSF    03.5
09C9:  MOVF   5D,W
09CA:  MOVWF  04
09CB:  MOVF   00,W
09CC:  ANDLW  7F
09CD:  MOVWF  00
*
0A34:  BSF    03.5
0A35:  MOVF   5D,W
0A36:  MOVWF  04
0A37:  MOVF   00,W
0A38:  ANDLW  7F
0A39:  MOVWF  00
*
0AA2:  BSF    03.5
0AA3:  MOVF   5D,W
0AA4:  MOVWF  04
0AA5:  MOVF   00,W
0AA6:  ANDLW  7F
0AA7:  MOVWF  00
....................       ret = MIDIDRV_MODMSB; 
*
01EA:  MOVLW  01
01EB:  MOVWF  5E
*
0244:  MOVLW  01
0245:  MOVWF  5E
*
02A1:  MOVLW  01
02A2:  MOVWF  5E
*
0908:  MOVLW  01
0909:  MOVWF  5E
*
0970:  MOVLW  01
0971:  MOVWF  5E
*
09CE:  MOVLW  01
09CF:  MOVWF  5E
*
0A3A:  MOVLW  01
0A3B:  MOVWF  5E
*
0AA8:  MOVLW  01
0AA9:  MOVWF  5E
....................     } 
....................   else // test if it is a control char 
*
01EC:  BCF    03.5
01ED:  GOTO   20A
*
0246:  BCF    03.5
0247:  GOTO   264
*
02A3:  BCF    03.5
02A4:  GOTO   2C1
*
090A:  BCF    03.5
090B:  GOTO   128
*
0972:  BCF    03.5
0973:  GOTO   190
*
09D0:  BCF    03.5
09D1:  GOTO   1EE
*
0A3C:  BCF    03.5
0A3D:  GOTO   25A
*
0AAA:  BCF    03.5
0AAB:  GOTO   2C8
....................     { 
....................       if (*char_to_tx == MIDIDRV_MODMSB || *char_to_tx == MIDIDRV_NOMOD) 
*
01EE:  BSF    03.5
01EF:  MOVF   5D,W
01F0:  MOVWF  04
01F1:  DECFSZ 00,W
01F2:  GOTO   1F4
01F3:  GOTO   1F6
01F4:  BCF    03.5
01F5:  GOTO   1F8
01F6:  BCF    03.5
01F7:  GOTO   202
01F8:  BSF    03.5
01F9:  MOVF   5D,W
01FA:  MOVWF  04
01FB:  MOVF   00,W
01FC:  SUBLW  02
01FD:  BTFSC  03.2
01FE:  GOTO   201
01FF:  BCF    03.5
0200:  GOTO   207
0201:  BCF    03.5
*
0248:  BSF    03.5
0249:  MOVF   5D,W
024A:  MOVWF  04
024B:  DECFSZ 00,W
024C:  GOTO   24E
024D:  GOTO   250
024E:  BCF    03.5
024F:  GOTO   252
0250:  BCF    03.5
0251:  GOTO   25C
0252:  BSF    03.5
0253:  MOVF   5D,W
0254:  MOVWF  04
0255:  MOVF   00,W
0256:  SUBLW  02
0257:  BTFSC  03.2
0258:  GOTO   25B
0259:  BCF    03.5
025A:  GOTO   261
025B:  BCF    03.5
*
02A5:  BSF    03.5
02A6:  MOVF   5D,W
02A7:  MOVWF  04
02A8:  DECFSZ 00,W
02A9:  GOTO   2AB
02AA:  GOTO   2AD
02AB:  BCF    03.5
02AC:  GOTO   2AF
02AD:  BCF    03.5
02AE:  GOTO   2B9
02AF:  BSF    03.5
02B0:  MOVF   5D,W
02B1:  MOVWF  04
02B2:  MOVF   00,W
02B3:  SUBLW  02
02B4:  BTFSC  03.2
02B5:  GOTO   2B8
02B6:  BCF    03.5
02B7:  GOTO   2BE
02B8:  BCF    03.5
*
090C:  BSF    03.5
090D:  MOVF   5D,W
090E:  MOVWF  04
090F:  DECFSZ 00,W
0910:  GOTO   112
0911:  GOTO   114
0912:  BCF    03.5
0913:  GOTO   116
0914:  BCF    03.5
0915:  GOTO   120
0916:  BSF    03.5
0917:  MOVF   5D,W
0918:  MOVWF  04
0919:  MOVF   00,W
091A:  SUBLW  02
091B:  BTFSC  03.2
091C:  GOTO   11F
091D:  BCF    03.5
091E:  GOTO   125
091F:  BCF    03.5
*
0974:  BSF    03.5
0975:  MOVF   5D,W
0976:  MOVWF  04
0977:  DECFSZ 00,W
0978:  GOTO   17A
0979:  GOTO   17C
097A:  BCF    03.5
097B:  GOTO   17E
097C:  BCF    03.5
097D:  GOTO   188
097E:  BSF    03.5
097F:  MOVF   5D,W
0980:  MOVWF  04
0981:  MOVF   00,W
0982:  SUBLW  02
0983:  BTFSC  03.2
0984:  GOTO   187
0985:  BCF    03.5
0986:  GOTO   18D
0987:  BCF    03.5
*
09D2:  BSF    03.5
09D3:  MOVF   5D,W
09D4:  MOVWF  04
09D5:  DECFSZ 00,W
09D6:  GOTO   1D8
09D7:  GOTO   1DA
09D8:  BCF    03.5
09D9:  GOTO   1DC
09DA:  BCF    03.5
09DB:  GOTO   1E6
09DC:  BSF    03.5
09DD:  MOVF   5D,W
09DE:  MOVWF  04
09DF:  MOVF   00,W
09E0:  SUBLW  02
09E1:  BTFSC  03.2
09E2:  GOTO   1E5
09E3:  BCF    03.5
09E4:  GOTO   1EB
09E5:  BCF    03.5
*
0A3E:  BSF    03.5
0A3F:  MOVF   5D,W
0A40:  MOVWF  04
0A41:  DECFSZ 00,W
0A42:  GOTO   244
0A43:  GOTO   246
0A44:  BCF    03.5
0A45:  GOTO   248
0A46:  BCF    03.5
0A47:  GOTO   252
0A48:  BSF    03.5
0A49:  MOVF   5D,W
0A4A:  MOVWF  04
0A4B:  MOVF   00,W
0A4C:  SUBLW  02
0A4D:  BTFSC  03.2
0A4E:  GOTO   251
0A4F:  BCF    03.5
0A50:  GOTO   257
0A51:  BCF    03.5
*
0AAC:  BSF    03.5
0AAD:  MOVF   5D,W
0AAE:  MOVWF  04
0AAF:  DECFSZ 00,W
0AB0:  GOTO   2B2
0AB1:  GOTO   2B4
0AB2:  BCF    03.5
0AB3:  GOTO   2B6
0AB4:  BCF    03.5
0AB5:  GOTO   2C0
0AB6:  BSF    03.5
0AB7:  MOVF   5D,W
0AB8:  MOVWF  04
0AB9:  MOVF   00,W
0ABA:  SUBLW  02
0ABB:  BTFSC  03.2
0ABC:  GOTO   2BF
0ABD:  BCF    03.5
0ABE:  GOTO   2C5
0ABF:  BCF    03.5
....................         { 
....................           // set control char to notify that *char_to_tx is not to  
....................           // behave as a control char 
....................           ret = MIDIDRV_NOMOD;  
*
0202:  MOVLW  02
0203:  BSF    03.5
0204:  MOVWF  5E
*
025C:  MOVLW  02
025D:  BSF    03.5
025E:  MOVWF  5E
*
02B9:  MOVLW  02
02BA:  BSF    03.5
02BB:  MOVWF  5E
*
0920:  MOVLW  02
0921:  BSF    03.5
0922:  MOVWF  5E
*
0988:  MOVLW  02
0989:  BSF    03.5
098A:  MOVWF  5E
*
09E6:  MOVLW  02
09E7:  BSF    03.5
09E8:  MOVWF  5E
*
0A52:  MOVLW  02
0A53:  BSF    03.5
0A54:  MOVWF  5E
*
0AC0:  MOVLW  02
0AC1:  BSF    03.5
0AC2:  MOVWF  5E
....................         } 
....................       else 
*
0205:  BCF    03.5
0206:  GOTO   20A
*
025F:  BCF    03.5
0260:  GOTO   264
*
02BC:  BCF    03.5
02BD:  GOTO   2C1
*
0923:  BCF    03.5
0924:  GOTO   128
*
098B:  BCF    03.5
098C:  GOTO   190
*
09E9:  BCF    03.5
09EA:  GOTO   1EE
*
0A55:  BCF    03.5
0A56:  GOTO   25A
*
0AC3:  BCF    03.5
0AC4:  GOTO   2C8
....................         { 
....................           ret = 0x00; 
*
0207:  BSF    03.5
0208:  CLRF   5E
0209:  BCF    03.5
*
0261:  BSF    03.5
0262:  CLRF   5E
0263:  BCF    03.5
*
02BE:  BSF    03.5
02BF:  CLRF   5E
02C0:  BCF    03.5
*
0925:  BSF    03.5
0926:  CLRF   5E
0927:  BCF    03.5
*
098D:  BSF    03.5
098E:  CLRF   5E
098F:  BCF    03.5
*
09EB:  BSF    03.5
09EC:  CLRF   5E
09ED:  BCF    03.5
*
0A57:  BSF    03.5
0A58:  CLRF   5E
0A59:  BCF    03.5
*
0AC5:  BSF    03.5
0AC6:  CLRF   5E
0AC7:  BCF    03.5
....................  
....................         } 
....................     } 
....................   return ret; 
*
020A:  BSF    03.5
020B:  MOVF   5E,W
020C:  MOVWF  78
020D:  BCF    03.5
*
0264:  BSF    03.5
0265:  MOVF   5E,W
0266:  MOVWF  78
0267:  BCF    03.5
*
02C1:  BSF    03.5
02C2:  MOVF   5E,W
02C3:  MOVWF  78
02C4:  BCF    03.5
*
0928:  BSF    03.5
0929:  MOVF   5E,W
092A:  MOVWF  78
092B:  BCF    03.5
*
0990:  BSF    03.5
0991:  MOVF   5E,W
0992:  MOVWF  78
0993:  BCF    03.5
*
09EE:  BSF    03.5
09EF:  MOVF   5E,W
09F0:  MOVWF  78
09F1:  BCF    03.5
*
0A5A:  BSF    03.5
0A5B:  MOVF   5E,W
0A5C:  MOVWF  78
0A5D:  BCF    03.5
*
0AC8:  BSF    03.5
0AC9:  MOVF   5E,W
0ACA:  MOVWF  78
0ACB:  BCF    03.5
.................... } // end EncodeMidiByte 
....................  
.................... /***************************************************************************** 
....................  * Author: A. Fraietta 
....................  * Function: DecodeMidiByte 
....................  * Purpose:  Decodes and modify two input characters 
....................  
....................  * Input:    control_char - control char used to determine mod reqd for current_char 
....................  *           current_char - char that is being tested 
....................  
....................  * Output:   control_char - new value for control char used for next current_char 
....................  *           current_char - decoded value of current_char 
....................  
....................  * Returns:  true if current_char is a valid (not control) character 
....................  * 
....................  * Notes: using 0x00 in case as it is most common and makes function more efficient 
....................  ******************************************************************************/ 
.................... #pragma inline 
.................... short DecodeMidiByte (byte *control_char, byte *current_char) 
.................... { 
....................   short ret; 
....................  
....................   switch (*control_char) 
*
0B73:  BSF    03.5
0B74:  MOVF   58,W
0B75:  MOVWF  04
0B76:  MOVF   00,W
0B77:  MOVWF  77
0B78:  BTFSS  03.2
0B79:  GOTO   37C
0B7A:  BCF    03.5
0B7B:  GOTO   384
0B7C:  MOVLW  01
0B7D:  SUBWF  77,W
0B7E:  BTFSS  03.2
0B7F:  GOTO   382
0B80:  BCF    03.5
0B81:  GOTO   3AA
0B82:  BCF    03.5
0B83:  GOTO   3B6
....................     { 
....................     case 0x00: // place first for efficiency 
....................       if (*current_char == MIDIDRV_MODMSB || *current_char == MIDIDRV_NOMOD) 
0B84:  BSF    03.5
0B85:  MOVF   59,W
0B86:  MOVWF  04
0B87:  DECFSZ 00,W
0B88:  GOTO   38A
0B89:  GOTO   38C
0B8A:  BCF    03.5
0B8B:  GOTO   38E
0B8C:  BCF    03.5
0B8D:  GOTO   398
0B8E:  BSF    03.5
0B8F:  MOVF   59,W
0B90:  MOVWF  04
0B91:  MOVF   00,W
0B92:  SUBLW  02
0B93:  BTFSC  03.2
0B94:  GOTO   397
0B95:  BCF    03.5
0B96:  GOTO   3A6
0B97:  BCF    03.5
....................         { 
....................           ret = false; 
0B98:  BSF    03.5
0B99:  BCF    5A.0
....................           *control_char = *current_char; 
0B9A:  MOVF   58,W
0B9B:  MOVWF  5B
0B9C:  MOVF   59,W
0B9D:  MOVWF  04
0B9E:  MOVF   00,W
0B9F:  MOVWF  5C
0BA0:  MOVF   5B,W
0BA1:  MOVWF  04
0BA2:  MOVF   5C,W
0BA3:  MOVWF  00
....................         } 
....................       else 
0BA4:  BCF    03.5
0BA5:  GOTO   3A9
....................         { 
....................           ret = true; 
0BA6:  BSF    03.5
0BA7:  BSF    5A.0
0BA8:  BCF    03.5
....................         } 
....................       break; 
0BA9:  GOTO   3BC
....................  
....................     case MIDIDRV_MODMSB: 
....................       ret = true; 
0BAA:  BSF    03.5
0BAB:  BSF    5A.0
....................       *control_char = 0x00; // clear next control char 
0BAC:  MOVF   58,W
0BAD:  MOVWF  04
0BAE:  CLRF   00
....................       *current_char |= 0x80; // set MSB 
0BAF:  MOVF   59,W
0BB0:  MOVWF  04
0BB1:  MOVF   00,W
0BB2:  IORLW  80
0BB3:  MOVWF  00
....................       break; 
0BB4:  BCF    03.5
0BB5:  GOTO   3BC
....................  
....................     default:  
....................       ret = true; 
0BB6:  BSF    03.5
0BB7:  BSF    5A.0
....................       *control_char = 0x00; // clear next control char 
0BB8:  MOVF   58,W
0BB9:  MOVWF  04
0BBA:  CLRF   00
0BBB:  BCF    03.5
....................     } // end select 
....................  
....................   return ret; 
0BBC:  MOVLW  00
0BBD:  BSF    03.5
0BBE:  BTFSC  5A.0
0BBF:  MOVLW  01
0BC0:  MOVWF  78
0BC1:  BCF    03.5
.................... } // end DecodeMidiByte 
....................  
....................  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................  * Author: A. Fraietta 
....................  * Function: CalculateMidiTxBufferSize 
....................  * Purpose:  Calculates the size of a buffer to encode 
....................  
....................  * Input:    Tx_Buffer- buffer of chars to be transmitted 
....................  *           Buff_size - size of buffer 
....................  
....................  * Output:   Nill 
....................  
....................  * Returns:  Size of buffer required does not include start and end sysex chars 
....................  * 
....................  * Notes:  
....................  ******************************************************************************/ 
.................... int16 CalculateMidiTxBufferSize (byte *buf, int16 buf_size) 
.................... { 
....................   int16 ret;  
....................   int16 i; 
....................   byte current_char; // local so we do not modify buff 
....................  
....................   ret = 0; 
....................  
....................   for (i = 0; i < buf_size; i++) 
....................     { 
....................       current_char = buf[i]; 
....................        
....................       if (EncodeMidiByte (&current_char)) 
....................         { 
....................           ret += 2; 
....................         } 
....................       else 
....................         { 
....................           ret++; 
....................         } 
....................     } 
....................   return ret; 
....................    
.................... } // end CalculateMidiTxBufferSize 
....................  
....................  
....................  
.................... 
.................... #include "cfgram.h" 
....................  /********************************************************* 
.................... Module for storing configuration in Pic EEProm 
.................... ********************************************************/ 
....................  
....................  
.................... //#inline 
.................... void WriteConfigByte (int index, byte config_byte) 
.................... { 
....................  
.................... #ifndef _SIMULATE 
....................   restart_wdt(); 
*
00A7:  CLRWDT
.................... 	write_eeprom (index, config_byte); 
00A8:  BSF    03.5
00A9:  MOVF   5C,W
00AA:  BCF    03.5
00AB:  BSF    03.6
00AC:  MOVWF  0D
00AD:  CLRF   0F
00AE:  BSF    03.5
00AF:  BCF    03.6
00B0:  MOVF   5D,W
00B1:  BCF    03.5
00B2:  BSF    03.6
00B3:  MOVWF  0C
00B4:  BSF    03.5
00B5:  BCF    0C.7
00B6:  BSF    0C.2
00B7:  BCF    03.5
00B8:  BCF    03.6
00B9:  MOVF   0B,W
00BA:  MOVWF  77
00BB:  BCF    0B.7
00BC:  MOVLW  55
00BD:  BSF    03.5
00BE:  BSF    03.6
00BF:  MOVWF  0D
00C0:  MOVLW  AA
00C1:  MOVWF  0D
00C2:  BSF    0C.1
00C3:  BCF    03.5
00C4:  BCF    03.6
00C5:  BSF    03.5
00C6:  BSF    03.6
00C7:  BTFSS  0C.1
00C8:  GOTO   0CC
00C9:  BCF    03.5
00CA:  BCF    03.6
00CB:  GOTO   0C5
00CC:  BCF    0C.2
00CD:  MOVF   77,W
00CE:  BCF    03.5
00CF:  BCF    03.6
00D0:  IORWF  0B,F
....................   restart_wdt(); 
00D1:  CLRWDT
00D2:  RETLW  00
.................... #else // let us decode from here 
....................   int x; 
....................   x = index; 
.................... #endif 
.................... } // end WriteConfigByte 
....................  
....................  
.................... #inline 
.................... byte ReadConfigByte (int index) 
.................... { 
.................... 	return read_eeprom (index); 
*
0158:  BSF    03.5
0159:  MOVF   69,W
015A:  BCF    03.5
015B:  BSF    03.6
015C:  MOVWF  0D
015D:  CLRF   0F
015E:  BSF    03.5
015F:  BCF    0C.7
0160:  BSF    0C.0
0161:  BCF    03.5
0162:  MOVF   0C,W
0163:  MOVWF  78
0164:  BCF    03.6
*
01B2:  BSF    03.5
01B3:  MOVF   69,W
01B4:  BCF    03.5
01B5:  BSF    03.6
01B6:  MOVWF  0D
01B7:  CLRF   0F
01B8:  BSF    03.5
01B9:  BCF    0C.7
01BA:  BSF    0C.0
01BB:  BCF    03.5
01BC:  MOVF   0C,W
01BD:  MOVWF  78
01BE:  BCF    03.6
*
05E3:  BSF    03.5
05E4:  MOVF   69,W
05E5:  BCF    03.5
05E6:  BSF    03.6
05E7:  MOVWF  0D
05E8:  CLRF   0F
05E9:  BSF    03.5
05EA:  BCF    0C.7
05EB:  BSF    0C.0
05EC:  BCF    03.5
05ED:  MOVF   0C,W
05EE:  MOVWF  78
05EF:  BCF    03.6
*
083A:  BSF    03.5
083B:  MOVF   69,W
083C:  BCF    03.5
083D:  BSF    03.6
083E:  MOVWF  0D
083F:  CLRF   0F
0840:  BSF    03.5
0841:  BCF    0C.7
0842:  BSF    0C.0
0843:  BCF    03.5
0844:  MOVF   0C,W
0845:  MOVWF  78
0846:  BCF    03.6
*
0A13:  BSF    03.5
0A14:  MOVF   69,W
0A15:  BCF    03.5
0A16:  BSF    03.6
0A17:  MOVWF  0D
0A18:  CLRF   0F
0A19:  BSF    03.5
0A1A:  BCF    0C.7
0A1B:  BSF    0C.0
0A1C:  BCF    03.5
0A1D:  MOVF   0C,W
0A1E:  MOVWF  78
0A1F:  BCF    03.6
*
0A81:  BSF    03.5
0A82:  MOVF   69,W
0A83:  BCF    03.5
0A84:  BSF    03.6
0A85:  MOVWF  0D
0A86:  CLRF   0F
0A87:  BSF    03.5
0A88:  BCF    0C.7
0A89:  BSF    0C.0
0A8A:  BCF    03.5
0A8B:  MOVF   0C,W
0A8C:  MOVWF  78
0A8D:  BCF    03.6
*
0B50:  BSF    03.5
0B51:  MOVF   69,W
0B52:  BCF    03.5
0B53:  BSF    03.6
0B54:  MOVWF  0D
0B55:  CLRF   0F
0B56:  BSF    03.5
0B57:  BCF    0C.7
0B58:  BSF    0C.0
0B59:  BCF    03.5
0B5A:  MOVF   0C,W
0B5B:  MOVWF  78
0B5C:  BCF    03.6
*
0C8B:  BSF    03.5
0C8C:  MOVF   69,W
0C8D:  BCF    03.5
0C8E:  BSF    03.6
0C8F:  MOVWF  0D
0C90:  CLRF   0F
0C91:  BSF    03.5
0C92:  BCF    0C.7
0C93:  BSF    0C.0
0C94:  BCF    03.5
0C95:  MOVF   0C,W
0C96:  MOVWF  78
0C97:  BCF    03.6
*
0CB6:  BSF    03.5
0CB7:  MOVF   69,W
0CB8:  BCF    03.5
0CB9:  BSF    03.6
0CBA:  MOVWF  0D
0CBB:  CLRF   0F
0CBC:  BSF    03.5
0CBD:  BCF    0C.7
0CBE:  BSF    0C.0
0CBF:  BCF    03.5
0CC0:  MOVF   0C,W
0CC1:  MOVWF  78
0CC2:  BCF    03.6
*
1007:  BSF    03.5
1008:  MOVF   69,W
1009:  BCF    03.5
100A:  BSF    03.6
100B:  MOVWF  0D
100C:  CLRF   0F
100D:  BSF    03.5
100E:  BCF    0C.7
100F:  BSF    0C.0
1010:  BCF    03.5
1011:  MOVF   0C,W
1012:  MOVWF  78
1013:  BCF    03.6
*
11C3:  BSF    03.5
11C4:  MOVF   69,W
11C5:  BCF    03.5
11C6:  BSF    03.6
11C7:  MOVWF  0D
11C8:  CLRF   0F
11C9:  BSF    03.5
11CA:  BCF    0C.7
11CB:  BSF    0C.0
11CC:  BCF    03.5
11CD:  MOVF   0C,W
11CE:  MOVWF  78
11CF:  BCF    03.6
*
1298:  BSF    03.5
1299:  MOVF   69,W
129A:  BCF    03.5
129B:  BSF    03.6
129C:  MOVWF  0D
129D:  CLRF   0F
129E:  BSF    03.5
129F:  BCF    0C.7
12A0:  BSF    0C.0
12A1:  BCF    03.5
12A2:  MOVF   0C,W
12A3:  MOVWF  78
12A4:  BCF    03.6
*
1A6A:  BSF    03.5
1A6B:  MOVF   69,W
1A6C:  BCF    03.5
1A6D:  BSF    03.6
1A6E:  MOVWF  0D
1A6F:  CLRF   0F
1A70:  BSF    03.5
1A71:  BCF    0C.7
1A72:  BSF    0C.0
1A73:  BCF    03.5
1A74:  MOVF   0C,W
1A75:  MOVWF  78
1A76:  BCF    03.6
*
1B9A:  BSF    03.5
1B9B:  MOVF   69,W
1B9C:  BCF    03.5
1B9D:  BSF    03.6
1B9E:  MOVWF  0D
1B9F:  CLRF   0F
1BA0:  BSF    03.5
1BA1:  BCF    0C.7
1BA2:  BSF    0C.0
1BA3:  BCF    03.5
1BA4:  MOVF   0C,W
1BA5:  MOVWF  78
1BA6:  BCF    03.6
*
1C4A:  BSF    03.5
1C4B:  MOVF   69,W
1C4C:  BCF    03.5
1C4D:  BSF    03.6
1C4E:  MOVWF  0D
1C4F:  CLRF   0F
1C50:  BSF    03.5
1C51:  BCF    0C.7
1C52:  BSF    0C.0
1C53:  BCF    03.5
1C54:  MOVF   0C,W
1C55:  MOVWF  78
1C56:  BCF    03.6
*
1D06:  BSF    03.5
1D07:  MOVF   69,W
1D08:  BCF    03.5
1D09:  BSF    03.6
1D0A:  MOVWF  0D
1D0B:  CLRF   0F
1D0C:  BSF    03.5
1D0D:  BCF    0C.7
1D0E:  BSF    0C.0
1D0F:  BCF    03.5
1D10:  MOVF   0C,W
1D11:  MOVWF  78
1D12:  BCF    03.6
*
1DC4:  BSF    03.5
1DC5:  MOVF   69,W
1DC6:  BCF    03.5
1DC7:  BSF    03.6
1DC8:  MOVWF  0D
1DC9:  CLRF   0F
1DCA:  BSF    03.5
1DCB:  BCF    0C.7
1DCC:  BSF    0C.0
1DCD:  BCF    03.5
1DCE:  MOVF   0C,W
1DCF:  MOVWF  78
1DD0:  BCF    03.6
.................... } // end ReadConfigByte 
.................... 
.................... #include "midicfg.h" 
....................  /**************************************************************************** 
.................... * MidiCfg.h 
.................... * Contains the configuration data for the Midi configuration for each input  
.................... * and output channel 
.................... * 
.................... * Configuration is stored as 64 element arrays 
.................... *  
.................... * 256 bytes available due to PIC limitations.  
.................... * Therefore, a max of 64 configuration types 
.................... * 
.................... * module shared between patch editor and PIC code 
.................... ****************************************************************************/ 
.................... #ifndef _MIDICFG_H 
.................... #define _MIDICFG_H 
....................  
....................        
....................  
.................... const byte ANA_OUT_CONTROLLER [] = {1, 2, 4, 7}; 
*
0036:  BCF    0A.0
0037:  BCF    0A.1
0038:  BCF    0A.2
0039:  ADDWF  02,F
003A:  RETLW  01
003B:  RETLW  02
003C:  RETLW  04
003D:  RETLW  07
....................  
.................... #define ANALOG_IN_CONFIG_INDEX  0 
.................... #define DIGITAL_IN_CONFIG_INDEX 16 
.................... #define ANALOGUE_OUT_CONFIG_INDEX 32 
.................... #define DIGITAL_OUT_CONFIG_INDEX  40 
....................  
.................... #define NOTEOFF_MASK 0x80 
.................... #define NOTEON_MASK 0x90 
.................... #define POLYPRESS_MASK 0xA0 
.................... #define CONTROLLER_MASK 0xB0 
.................... #define PROGCHANGE_MASK 0xC0 
.................... #define CHANPRESS_MASK 0xD0 
.................... #define PITCHBEND_MASK 0xE0 
....................  
.................... // define index for configuraion within eeprom 
.................... #define MAX_INPUT_CHAN 16 
.................... #define MAX_ANAOUTPUT_CHAN 8 
.................... #define MAX_DIGOUTPUT_CHAN 16 
.................... #define MIDI_CONFIG_START_ADDRESS 32 
....................  
.................... #define VALID_CONFIG_ADDRESS 0x0 
.................... #define DEVICE_ID_ADDRESS 0x01 
.................... #define MIDI_MERGE_ADDRESS 0x02 
....................  
....................  
.................... #define DEFAULT_ANA_IN_CONT 12 
.................... #define DEFAULT_DIG_IN_CONT 64 
.................... #define DEFAULT_DIG_OUT_CONT 80 
....................  
.................... // define bitmasks for config flags 
.................... #define DATA_1_VARY_MASK    0x01 // this means data 1 is the byte containg the variable value 
.................... #define INVERT_VALUE_MASK   0x02 // this means the variable value is inverted 
.................... #define MUTE_CONFIG_MASK    0x04 // no output generated for this configuration 
.................... #define MIDI_OUTPUT2_MASK   0x08 // Output generated on Midi output 2 insetad of 1 
.................... #define PRESET_VALUE_FLAG   0x10 // Value will be sent upon reset 
.................... #define HIGH_RES_DUAL_CHAN  0x20 // 10 bit over two different controller numbers 
.................... #define VALUE_SCALING_FLAG	0x80 // must be uppermost bit - if set, the status of Midi Message will contain upper scale 
....................  
.................... /* define a structure for a midi config. max 4 bytes */ 
....................  
.................... #ifdef _PATCH_EDITOR 
.................... 	typedef unsigned char BYTE; 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................   BYTE status_chan; 
....................   BYTE data_1; 
....................   BYTE data_2; 
....................   BYTE config_flag; 
.................... } str_midiconfig; 
....................  
....................  
.................... #ifdef _PATCH_EDITOR 
....................   byte ReadConfigByte (int index); 
....................   void WriteConfigByte (int index, byte value); 
....................   void ReadMidiConfig (str_midiconfig* ret_config, byte index); 
....................   void WriteMidiConfig (str_midiconfig* config, byte index); 
....................   void ReadAnalogueInConfig(str_midiconfig* ret_config, int index); 
....................   void ReadDigitalInConfig(str_midiconfig* ret_config, int index); 
....................   void ReadAnalogueOutConfig(str_midiconfig* ret_config, int index); 
....................   void ReadDigitalOutConfig(str_midiconfig* ret_config, int index); 
.................... #endif 
....................  
.................... #ifndef _NO_CODE 
.................... #pragma inline 
.................... short DoMidiMerge() 
.................... { 
....................   return (ReadConfigByte(MIDI_MERGE_ADDRESS)); 
*
05DF:  MOVLW  02
05E0:  BSF    03.5
05E1:  MOVWF  69
05E2:  BCF    03.5
*
05F0:  MOVF   78,W
*
0836:  MOVLW  02
0837:  BSF    03.5
0838:  MOVWF  69
0839:  BCF    03.5
*
0847:  MOVF   78,W
*
0B4C:  MOVLW  02
0B4D:  BSF    03.5
0B4E:  MOVWF  69
0B4F:  BCF    03.5
*
0B5D:  MOVF   78,W
*
0C87:  MOVLW  02
0C88:  BSF    03.5
0C89:  MOVWF  69
0C8A:  BCF    03.5
*
0C98:  MOVF   78,W
*
0CB2:  MOVLW  02
0CB3:  BSF    03.5
0CB4:  MOVWF  69
0CB5:  BCF    03.5
*
0CC3:  MOVF   78,W
*
11BF:  MOVLW  02
11C0:  BSF    03.5
11C1:  MOVWF  69
11C2:  BCF    03.5
*
11D0:  MOVF   78,W
*
1294:  MOVLW  02
1295:  BSF    03.5
1296:  MOVWF  69
1297:  BCF    03.5
*
12A5:  MOVF   78,W
*
1A66:  MOVLW  02
1A67:  BSF    03.5
1A68:  MOVWF  69
1A69:  BCF    03.5
*
1A77:  MOVF   78,W
*
1B96:  MOVLW  02
1B97:  BSF    03.5
1B98:  MOVWF  69
1B99:  BCF    03.5
*
1BA7:  MOVF   78,W
*
1C46:  MOVLW  02
1C47:  BSF    03.5
1C48:  MOVWF  69
1C49:  BCF    03.5
*
1C57:  MOVF   78,W
*
1D02:  MOVLW  02
1D03:  BSF    03.5
1D04:  MOVWF  69
1D05:  BCF    03.5
*
1D13:  MOVF   78,W
*
1DC0:  MOVLW  02
1DC1:  BSF    03.5
1DC2:  MOVWF  69
1DC3:  BCF    03.5
*
1DD1:  MOVF   78,W
.................... } 
....................  
.................... // note that index must be less than 64 
.................... void ReadMidiConfig (str_midiconfig* ret_config, byte index) 
.................... { 
....................   byte i; 
....................   byte* ret_ptr; 
.................... 	byte start_memory_index; // the index within the RAM configuration array 
....................  
....................   ret_ptr = (byte*)ret_config; 
*
0139:  BSF    03.5
013A:  MOVF   62,W
013B:  MOVWF  65
.................... 	start_memory_index = (byte)((index * sizeof (str_midiconfig)) 
.................... 		+ MIDI_CONFIG_START_ADDRESS); 
013C:  BCF    03.0
013D:  RLF    63,W
013E:  MOVWF  77
013F:  RLF    77,F
0140:  MOVLW  FC
0141:  ANDWF  77,F
0142:  MOVF   77,W
0143:  ADDLW  20
0144:  MOVWF  66
....................  
....................   for (i = 0; i < sizeof (str_midiconfig); i++) 
0145:  CLRF   64
0146:  BCF    03.5
0147:  BSF    03.5
0148:  MOVF   64,W
0149:  SUBLW  03
014A:  BTFSC  03.0
014B:  GOTO   14E
014C:  BCF    03.5
014D:  GOTO   16F
014E:  BCF    03.5
....................   { 
....................     ret_ptr [i] = (byte)ReadConfigByte ((byte) (start_memory_index + i)); 
014F:  BSF    03.5
0150:  MOVF   65,W
0151:  ADDWF  64,W
0152:  MOVWF  67
0153:  MOVF   64,W
0154:  ADDWF  66,W
0155:  MOVWF  68
0156:  MOVWF  69
0157:  BCF    03.5
*
0165:  BSF    03.5
0166:  MOVF   67,W
0167:  MOVWF  04
0168:  MOVF   78,W
0169:  MOVWF  00
016A:  BCF    03.5
....................   } 
016B:  BSF    03.5
016C:  INCF   64,F
016D:  BCF    03.5
016E:  GOTO   147
016F:  RETLW  00
.................... } // end void ReadMidiConfig (str_midiconfig* ret_config, int index)  
....................  
....................  
.................... // note that index must be less than 64 
.................... void WriteMidiConfig (str_midiconfig* config, byte index) 
.................... { 
....................   byte i; 
....................   byte* ptr; 
.................... 	byte start_memory_index; // the index within the RAM configuration array 
....................  
....................   ptr = (byte*)config; 
*
00D3:  BSF    03.5
00D4:  MOVF   3B,W
00D5:  MOVWF  3E
....................    
.................... 	start_memory_index = (byte) ((index * sizeof (str_midiconfig)) 
.................... 		+ MIDI_CONFIG_START_ADDRESS); 
00D6:  BCF    03.0
00D7:  RLF    3C,W
00D8:  MOVWF  77
00D9:  RLF    77,F
00DA:  MOVLW  FC
00DB:  ANDWF  77,F
00DC:  MOVF   77,W
00DD:  ADDLW  20
00DE:  MOVWF  3F
....................    
.................... 	for (i = 0; i < sizeof (str_midiconfig); i++) 
00DF:  CLRF   3D
00E0:  BCF    03.5
00E1:  BSF    03.5
00E2:  MOVF   3D,W
00E3:  SUBLW  03
00E4:  BTFSC  03.0
00E5:  GOTO   0E8
00E6:  BCF    03.5
00E7:  GOTO   0FC
00E8:  BCF    03.5
....................   { 
....................     WriteConfigByte ((byte) (start_memory_index + i), ptr [i]); 
00E9:  BSF    03.5
00EA:  MOVF   3D,W
00EB:  ADDWF  3F,W
00EC:  MOVWF  40
00ED:  MOVF   3E,W
00EE:  ADDWF  3D,W
00EF:  MOVWF  04
00F0:  MOVF   00,W
00F1:  MOVWF  41
00F2:  MOVF   40,W
00F3:  MOVWF  5C
00F4:  MOVF   41,W
00F5:  MOVWF  5D
00F6:  BCF    03.5
00F7:  CALL   0A7
....................   } 
00F8:  BSF    03.5
00F9:  INCF   3D,F
00FA:  BCF    03.5
00FB:  GOTO   0E1
00FC:  RETLW  00
.................... } // end void WriteMidiConfig (str_midiconfig* config, int index)  
....................  
....................  
.................... #pragma inline 
.................... void ReadAnalogueInConfig(str_midiconfig* ret_config, int index) 
.................... { 
.................... 	ReadMidiConfig (ret_config, (byte) (ANALOG_IN_CONFIG_INDEX + index)); 
*
079E:  BSF    03.5
079F:  MOVF   4C,W
07A0:  MOVWF  62
07A1:  MOVF   4D,W
07A2:  MOVWF  63
07A3:  BCF    03.5
07A4:  CALL   139
*
117D:  BSF    03.5
117E:  MOVF   4C,W
117F:  MOVWF  62
1180:  MOVF   4D,W
1181:  MOVWF  63
1182:  BCF    03.5
1183:  BCF    0A.4
1184:  CALL   139
1185:  BSF    0A.4
*
184E:  BSF    03.5
184F:  MOVF   4C,W
1850:  MOVWF  62
1851:  MOVF   4D,W
1852:  MOVWF  63
1853:  BCF    03.5
1854:  BCF    0A.4
1855:  BCF    0A.3
1856:  CALL   139
1857:  BSF    0A.4
1858:  BSF    0A.3
*
19F5:  BSF    03.5
19F6:  MOVF   4C,W
19F7:  MOVWF  62
19F8:  MOVF   4D,W
19F9:  MOVWF  63
19FA:  BCF    03.5
19FB:  BCF    0A.4
19FC:  BCF    0A.3
19FD:  CALL   139
19FE:  BSF    0A.4
19FF:  BSF    0A.3
.................... } 
....................  
....................  
.................... # pragma inline 
.................... void ReadDigitalInConfig(str_midiconfig* ret_config, int index)  
.................... { 
.................... 	ReadMidiConfig (ret_config, (byte) (DIGITAL_IN_CONFIG_INDEX + index)); 
*
0561:  MOVLW  10
0562:  BSF    03.5
0563:  ADDWF  4A,W
0564:  MOVWF  4B
0565:  MOVF   49,W
0566:  MOVWF  62
0567:  MOVF   4B,W
0568:  MOVWF  63
0569:  BCF    03.5
056A:  CALL   139
*
124F:  MOVLW  10
1250:  BSF    03.5
1251:  ADDWF  4A,W
1252:  MOVWF  4B
1253:  MOVF   49,W
1254:  MOVWF  62
1255:  MOVF   4B,W
1256:  MOVWF  63
1257:  BCF    03.5
1258:  BCF    0A.4
1259:  CALL   139
125A:  BSF    0A.4
.................... } // end void ReadDigitalInConfig(str_midiconfig* ret_config, int index)  
....................  
....................  
.................... #pragma inline 
.................... void ReadAnalogueOutConfig(str_midiconfig* ret_config, int index)  
.................... { 
.................... 	ReadMidiConfig (ret_config, (byte) (ANALOGUE_OUT_CONFIG_INDEX + index)); 
*
0D09:  MOVLW  20
0D0A:  BSF    03.5
0D0B:  ADDWF  60,W
0D0C:  MOVWF  61
0D0D:  MOVF   5F,W
0D0E:  MOVWF  62
0D0F:  MOVF   61,W
0D10:  MOVWF  63
0D11:  BCF    03.5
0D12:  BCF    0A.3
0D13:  CALL   139
0D14:  BSF    0A.3
*
1324:  MOVLW  20
1325:  BSF    03.5
1326:  ADDWF  60,W
1327:  MOVWF  61
1328:  MOVF   5F,W
1329:  MOVWF  62
132A:  MOVF   61,W
132B:  MOVWF  63
132C:  BCF    03.5
132D:  BCF    0A.4
132E:  CALL   139
132F:  BSF    0A.4
.................... } // end void ReadAnalogueOutConfig(str_midiconfig* ret_config, int index)  
....................  
....................  
.................... #pragma inline  
.................... void ReadDigitalOutConfig(str_midiconfig* ret_config, int index)  
.................... { 
.................... 	ReadMidiConfig (ret_config, (byte) (DIGITAL_OUT_CONFIG_INDEX + index)); 
*
0E8C:  MOVLW  28
0E8D:  BSF    03.5
0E8E:  ADDWF  60,W
0E8F:  MOVWF  61
0E90:  MOVF   5F,W
0E91:  MOVWF  62
0E92:  MOVF   61,W
0E93:  MOVWF  63
0E94:  BCF    03.5
0E95:  BCF    0A.3
0E96:  CALL   139
0E97:  BSF    0A.3
*
137A:  MOVLW  28
137B:  BSF    03.5
137C:  ADDWF  60,W
137D:  MOVWF  61
137E:  MOVF   5F,W
137F:  MOVWF  62
1380:  MOVF   61,W
1381:  MOVWF  63
1382:  BCF    03.5
1383:  BCF    0A.4
1384:  CALL   139
1385:  BSF    0A.4
.................... } // end void ReadDigitalOutConfig(str_midiconfig* ret_config, int index)  
....................  
.................... void GetDefaultAnalogueIn(str_midiconfig* ret_config, int index)  
.................... { 
....................   ret_config->status_chan = CONTROLLER_MASK | 0x00; // controller on channel 1  
*
102F:  BSF    03.5
1030:  MOVF   3A,W
1031:  MOVWF  04
1032:  MOVLW  B0
1033:  MOVWF  00
....................   ret_config->data_1 = (byte) (DEFAULT_ANA_IN_CONT + index); 
1034:  MOVLW  01
1035:  ADDWF  3A,W
1036:  MOVWF  04
1037:  MOVLW  0C
1038:  ADDWF  3B,W
1039:  MOVWF  00
.................... 	ret_config->data_2 = 0;  
103A:  MOVLW  02
103B:  ADDWF  3A,W
103C:  MOVWF  04
103D:  CLRF   00
....................   ret_config->config_flag = 0; 
103E:  MOVLW  03
103F:  ADDWF  3A,W
1040:  MOVWF  04
1041:  CLRF   00
1042:  BCF    03.5
.................... } // end void GetDefaultAnalogueIn(str_midiconfig* ret_config, int index)  
....................  
.................... void GetDefaultDigitalIn(str_midiconfig* ret_config, int index)  
.................... { 
....................   ret_config->status_chan = CONTROLLER_MASK | 0x00; // controller on channel 1  
*
1061:  BSF    03.5
1062:  MOVF   3A,W
1063:  MOVWF  04
1064:  MOVLW  B0
1065:  MOVWF  00
....................   ret_config->data_1 = (byte) (DEFAULT_DIG_IN_CONT + index); 
1066:  MOVLW  01
1067:  ADDWF  3A,W
1068:  MOVWF  04
1069:  MOVLW  40
106A:  ADDWF  3B,W
106B:  MOVWF  00
.................... 	ret_config->data_2 = 0; 
106C:  MOVLW  02
106D:  ADDWF  3A,W
106E:  MOVWF  04
106F:  CLRF   00
....................   ret_config->config_flag = 0; 
1070:  MOVLW  03
1071:  ADDWF  3A,W
1072:  MOVWF  04
1073:  CLRF   00
1074:  BCF    03.5
.................... } // end void GetDefaultDigitalIn(str_midiconfig* ret_config, int index)  
....................  
.................... void GetDefaultDigitalOut(str_midiconfig* ret_config, int index)  
.................... { 
....................   ret_config->status_chan = CONTROLLER_MASK | 0x00; // controller on channel 1  
*
10D8:  BSF    03.5
10D9:  MOVF   3A,W
10DA:  MOVWF  04
10DB:  MOVLW  B0
10DC:  MOVWF  00
....................   ret_config->data_1 = (byte) (DEFAULT_DIG_OUT_CONT + index); 
10DD:  MOVLW  01
10DE:  ADDWF  3A,W
10DF:  MOVWF  04
10E0:  MOVLW  50
10E1:  ADDWF  3B,W
10E2:  MOVWF  00
.................... 	ret_config->data_2 = 0; 
10E3:  MOVLW  02
10E4:  ADDWF  3A,W
10E5:  MOVWF  04
10E6:  CLRF   00
....................   ret_config->config_flag = 0; 
10E7:  MOVLW  03
10E8:  ADDWF  3A,W
10E9:  MOVWF  04
10EA:  CLRF   00
10EB:  BCF    03.5
.................... } // end void GetDefaultDigitalOut(str_midiconfig* ret_config, int index)  
....................  
.................... void GetDefaultAnalogueOut(str_midiconfig* ret_config, int index)  
.................... { 
.................... 	ret_config->status_chan = (byte) (CONTROLLER_MASK | (index / sizeof(ANA_OUT_CONTROLLER)));  
*
1096:  BSF    03.5
1097:  MOVF   3A,W
1098:  MOVWF  04
1099:  BCF    03.0
109A:  RRF    3B,W
109B:  MOVWF  77
109C:  RRF    77,F
109D:  MOVLW  3F
109E:  ANDWF  77,F
109F:  MOVF   77,W
10A0:  IORLW  B0
10A1:  MOVWF  00
.................... 	ret_config->data_1 = ANA_OUT_CONTROLLER [index % sizeof(ANA_OUT_CONTROLLER)]; 
10A2:  MOVLW  01
10A3:  ADDWF  3A,W
10A4:  MOVWF  04
10A5:  MOVF   3B,W
10A6:  ANDLW  03
10A7:  BCF    03.5
10A8:  BCF    0A.4
10A9:  CALL   036
10AA:  BSF    0A.4
10AB:  MOVWF  78
10AC:  MOVWF  00
.................... 	ret_config->data_2 = 0; 
10AD:  MOVLW  02
10AE:  BSF    03.5
10AF:  ADDWF  3A,W
10B0:  MOVWF  04
10B1:  CLRF   00
....................   ret_config->config_flag = 0; 
10B2:  MOVLW  03
10B3:  ADDWF  3A,W
10B4:  MOVWF  04
10B5:  CLRF   00
10B6:  BCF    03.5
.................... } // end void GetDefaultAnalogueOut(str_midiconfig* ret_config, int index)  
....................  
.................... // gets the default for all types and writes it to eeprom 
.................... void ResetConfiguration() 
.................... { 
.................... 	// configure analog in first 
.................... 	str_midiconfig config; 
.................... 	int i; 
....................  
.................... 	for (i = 0; i < MAX_INPUT_CHAN; i++) 
*
101E:  BSF    03.5
101F:  CLRF   39
1020:  BCF    03.5
1021:  BSF    03.5
1022:  MOVF   39,W
1023:  SUBLW  0F
1024:  BTFSC  03.0
1025:  GOTO   028
1026:  BCF    03.5
1027:  GOTO   050
1028:  BCF    03.5
.................... 		{ 
.................... 			GetDefaultAnalogueIn (&config, i); 
1029:  MOVLW  B5
102A:  BSF    03.5
102B:  MOVWF  3A
102C:  MOVF   39,W
102D:  MOVWF  3B
102E:  BCF    03.5
....................  
.................... 			WriteMidiConfig (&config, (byte) (i + ANALOG_IN_CONFIG_INDEX)); 
*
1043:  MOVLW  B5
1044:  BSF    03.5
1045:  MOVWF  3B
1046:  MOVF   39,W
1047:  MOVWF  3C
1048:  BCF    03.5
1049:  BCF    0A.4
104A:  CALL   0D3
104B:  BSF    0A.4
.................... 		} 
104C:  BSF    03.5
104D:  INCF   39,F
104E:  BCF    03.5
104F:  GOTO   021
....................  
....................  
.................... 	for (i = 0; i < MAX_INPUT_CHAN; i++) 
1050:  BSF    03.5
1051:  CLRF   39
1052:  BCF    03.5
1053:  BSF    03.5
1054:  MOVF   39,W
1055:  SUBLW  0F
1056:  BTFSC  03.0
1057:  GOTO   05A
1058:  BCF    03.5
1059:  GOTO   085
105A:  BCF    03.5
.................... 		{ 
.................... 			GetDefaultDigitalIn (&config, i); 
105B:  MOVLW  B5
105C:  BSF    03.5
105D:  MOVWF  3A
105E:  MOVF   39,W
105F:  MOVWF  3B
1060:  BCF    03.5
....................  
.................... 			WriteMidiConfig (&config, (byte) (i + DIGITAL_IN_CONFIG_INDEX)); 
*
1075:  MOVLW  10
1076:  BSF    03.5
1077:  ADDWF  39,W
1078:  MOVWF  3A
1079:  MOVLW  B5
107A:  MOVWF  3B
107B:  MOVF   3A,W
107C:  MOVWF  3C
107D:  BCF    03.5
107E:  BCF    0A.4
107F:  CALL   0D3
1080:  BSF    0A.4
.................... 		} 
1081:  BSF    03.5
1082:  INCF   39,F
1083:  BCF    03.5
1084:  GOTO   053
....................  
.................... 	for (i = 0; i < MAX_ANAOUTPUT_CHAN; i++) 
1085:  BSF    03.5
1086:  CLRF   39
1087:  BCF    03.5
1088:  BSF    03.5
1089:  MOVF   39,W
108A:  SUBLW  07
108B:  BTFSC  03.0
108C:  GOTO   08F
108D:  BCF    03.5
108E:  GOTO   0C7
108F:  BCF    03.5
.................... 		{ 
.................... 			GetDefaultAnalogueOut (&config, i); 
1090:  MOVLW  B5
1091:  BSF    03.5
1092:  MOVWF  3A
1093:  MOVF   39,W
1094:  MOVWF  3B
1095:  BCF    03.5
....................  
.................... 			WriteMidiConfig (&config, (byte) (i + ANALOGUE_OUT_CONFIG_INDEX)); 
*
10B7:  MOVLW  20
10B8:  BSF    03.5
10B9:  ADDWF  39,W
10BA:  MOVWF  3A
10BB:  MOVLW  B5
10BC:  MOVWF  3B
10BD:  MOVF   3A,W
10BE:  MOVWF  3C
10BF:  BCF    03.5
10C0:  BCF    0A.4
10C1:  CALL   0D3
10C2:  BSF    0A.4
.................... 		} 
10C3:  BSF    03.5
10C4:  INCF   39,F
10C5:  BCF    03.5
10C6:  GOTO   088
....................  
.................... 	for (i = 0; i < MAX_DIGOUTPUT_CHAN; i++) 
10C7:  BSF    03.5
10C8:  CLRF   39
10C9:  BCF    03.5
10CA:  BSF    03.5
10CB:  MOVF   39,W
10CC:  SUBLW  0F
10CD:  BTFSC  03.0
10CE:  GOTO   0D1
10CF:  BCF    03.5
10D0:  GOTO   0FC
10D1:  BCF    03.5
.................... 		{ 
.................... 			GetDefaultDigitalOut (&config, i); 
10D2:  MOVLW  B5
10D3:  BSF    03.5
10D4:  MOVWF  3A
10D5:  MOVF   39,W
10D6:  MOVWF  3B
10D7:  BCF    03.5
....................  
.................... 			WriteMidiConfig (&config, (byte) (i + DIGITAL_OUT_CONFIG_INDEX)); 
*
10EC:  MOVLW  28
10ED:  BSF    03.5
10EE:  ADDWF  39,W
10EF:  MOVWF  3A
10F0:  MOVLW  B5
10F1:  MOVWF  3B
10F2:  MOVF   3A,W
10F3:  MOVWF  3C
10F4:  BCF    03.5
10F5:  BCF    0A.4
10F6:  CALL   0D3
10F7:  BSF    0A.4
.................... 		} 
10F8:  BSF    03.5
10F9:  INCF   39,F
10FA:  BCF    03.5
10FB:  GOTO   0CA
....................  
.................... 	WriteConfigByte (VALID_CONFIG_ADDRESS, 0x00); 
10FC:  BSF    03.5
10FD:  CLRF   5C
10FE:  CLRF   5D
10FF:  BCF    03.5
1100:  BCF    0A.4
1101:  CALL   0A7
1102:  BSF    0A.4
.................... } // end void ResetConfiguration() 
....................  
.................... // tests whether the config bit is valid (i.e between 0x80 and 0xEf) 
.................... short ValidConfig () 
.................... { 
.................... 	return (!ReadConfigByte (VALID_CONFIG_ADDRESS)); 
*
1004:  BSF    03.5
1005:  CLRF   69
1006:  BCF    03.5
*
1014:  MOVF   78,F
1015:  BTFSC  03.2
1016:  GOTO   019
1017:  MOVLW  00
1018:  GOTO   01A
1019:  MOVLW  01
101A:  MOVWF  78
.................... }// end short ValidConfig () 
....................  
.................... int ReadDeviceId() 
.................... { 
....................   int ret; 
.................... 	ret = ReadConfigByte(DEVICE_ID_ADDRESS); 
*
01AE:  MOVLW  01
01AF:  BSF    03.5
01B0:  MOVWF  69
01B1:  BCF    03.5
*
01BF:  MOVF   78,W
01C0:  BSF    03.5
01C1:  MOVWF  5A
....................   return ret; 
01C2:  MOVF   5A,W
01C3:  MOVWF  78
01C4:  BCF    03.5
01C5:  RETLW  00
.................... } // end ReadDeviceId  
....................  
.................... // tests first config msg. If invalid, rewrites lot 
.................... void ValidateStoredConfig () 
.................... { 
.................... 	if (!ValidConfig ()) 
*
101B:  MOVF   78,F
101C:  BTFSS  03.2
101D:  GOTO   103
.................... 		{ 
.................... 			ResetConfiguration(); 
.................... 		} 
....................  
.................... } // end ValidateStoredConfig 
....................  
....................  
....................  
.................... // returns the number of bytes that need to be transmitted for this midi config 
.................... int NumTxBytes (str_midiconfig* config) 
.................... { 
.................... 	int status_nibble; 
....................  
.................... 	status_nibble = config->status_chan & 0xF0; // first nibble 
*
0170:  BSF    03.5
0171:  MOVF   58,W
0172:  MOVWF  04
0173:  MOVF   00,W
0174:  ANDLW  F0
0175:  MOVWF  59
....................  
.................... 	switch (status_nibble) 
0176:  MOVF   59,W
0177:  MOVWF  77
0178:  MOVLW  80
0179:  SUBWF  77,W
017A:  BTFSS  03.2
017B:  GOTO   17E
017C:  BCF    03.5
017D:  GOTO   1A4
017E:  MOVLW  90
017F:  SUBWF  77,W
0180:  BTFSS  03.2
0181:  GOTO   184
0182:  BCF    03.5
0183:  GOTO   1A4
0184:  MOVLW  A0
0185:  SUBWF  77,W
0186:  BTFSS  03.2
0187:  GOTO   18A
0188:  BCF    03.5
0189:  GOTO   1A4
018A:  MOVLW  B0
018B:  SUBWF  77,W
018C:  BTFSS  03.2
018D:  GOTO   190
018E:  BCF    03.5
018F:  GOTO   1A4
0190:  MOVLW  E0
0191:  SUBWF  77,W
0192:  BTFSS  03.2
0193:  GOTO   196
0194:  BCF    03.5
0195:  GOTO   1A4
0196:  MOVLW  C0
0197:  SUBWF  77,W
0198:  BTFSS  03.2
0199:  GOTO   19C
019A:  BCF    03.5
019B:  GOTO   1A7
019C:  MOVLW  D0
019D:  SUBWF  77,W
019E:  BTFSS  03.2
019F:  GOTO   1A2
01A0:  BCF    03.5
01A1:  GOTO   1A7
01A2:  BCF    03.5
01A3:  GOTO   1AA
.................... 		{ 
.................... 		case NOTEOFF_MASK: 
.................... 		case NOTEON_MASK:  
.................... 		case POLYPRESS_MASK: 
.................... 		case CONTROLLER_MASK: 
.................... 		case PITCHBEND_MASK: 
.................... 			return 3; 
01A4:  MOVLW  03
01A5:  MOVWF  78
01A6:  GOTO   1AD
....................  
.................... 		case PROGCHANGE_MASK: 
.................... 		case CHANPRESS_MASK: 
.................... 			return 2; 
01A7:  MOVLW  02
01A8:  MOVWF  78
01A9:  GOTO   1AD
.................... 		default: 
.................... 			return 0; 
01AA:  MOVLW  00
01AB:  MOVWF  78
01AC:  GOTO   1AD
.................... 		} 
01AD:  RETLW  00
....................  
.................... } // end int NumTxBytes (str_midiconfig* config) 
....................  
.................... #endif /*_NO_CODE*/ 
....................  
.................... #endif 
.................... 
.................... #include "max520.h" 
....................  /********************************************************** 
....................  * I2C driver for Max520 ADC 
....................  *********************************************************/ 
....................  
.................... #define MAX520_SLAVE_MASK 0x50 // must be ORed with slave device number 
.................... #define NUM_520_OP 4     // the maximum outputs of a Max 520 
....................  
....................  
.................... #inline 
.................... short WriteAnalogueOutput (int port_num, byte outval) 
.................... { 
.................... 	short ret; 
.................... 	byte slave_num, op_num, device_address; 
....................  
.................... 	i2c_start(); 
*
0335:  BSF    03.5
0336:  BSF    06.7
0337:  MOVLW  04
0338:  MOVWF  77
0339:  BCF    03.5
033A:  DECFSZ 77,F
033B:  GOTO   33A
033C:  BSF    03.5
033D:  BSF    06.6
033E:  MOVLW  06
033F:  MOVWF  77
0340:  BCF    03.5
0341:  DECFSZ 77,F
0342:  GOTO   341
0343:  BCF    06.7
0344:  BSF    03.5
0345:  BCF    06.7
0346:  MOVLW  04
0347:  MOVWF  77
0348:  BCF    03.5
0349:  DECFSZ 77,F
034A:  GOTO   349
034B:  BCF    06.6
034C:  BSF    03.5
034D:  BCF    06.6
....................  
.................... 	slave_num = port_num / NUM_520_OP; 
034E:  BCF    03.0
034F:  RRF    65,W
0350:  MOVWF  68
0351:  RRF    68,F
0352:  MOVLW  3F
0353:  ANDWF  68,F
....................   slave_num <<= 1; 
0354:  BCF    03.0
0355:  RLF    68,F
.................... 	device_address = MAX520_SLAVE_MASK | slave_num; 
0356:  MOVF   68,W
0357:  IORLW  50
0358:  MOVWF  6A
.................... #ifndef _SIMULATE 
.................... 	i2c_write (device_address); 
0359:  MOVWF  6B
035A:  BCF    03.5
035B:  CALL   2E4
.................... #endif 
....................  
.................... 	op_num = port_num % NUM_520_OP; 
035C:  BSF    03.5
035D:  MOVF   65,W
035E:  ANDLW  03
035F:  MOVWF  69
....................  
.................... #ifndef _SIMULATE 
.................... 	i2c_write (op_num); 
0360:  MOVWF  6B
0361:  BCF    03.5
0362:  CALL   2E4
.................... 	i2c_write (outval); 
0363:  BSF    03.5
0364:  MOVF   66,W
0365:  MOVWF  6B
0366:  BCF    03.5
0367:  CALL   2E4
.................... 	i2c_stop(); 
0368:  BSF    03.5
0369:  BCF    06.7
036A:  NOP
036B:  BSF    06.6
036C:  BCF    03.5
036D:  BTFSS  06.6
036E:  GOTO   36D
036F:  MOVLW  04
0370:  MOVWF  77
0371:  DECFSZ 77,F
0372:  GOTO   371
0373:  NOP
0374:  NOP
0375:  NOP
0376:  BSF    03.5
0377:  BSF    06.7
0378:  MOVLW  04
0379:  MOVWF  77
037A:  BCF    03.5
037B:  DECFSZ 77,F
037C:  GOTO   37B
.................... #else 
....................   op_num = port_num % NUM_520_OP; 
.................... #endif 
.................... } 
.................... 
.................... #include "anaout.h" 
....................  /********************************************************************** 
.................... Performs the ana;logue output using an SPI write 
.................... ***********************************************************************/ 
....................   
....................  
.................... void GenerateAnalogueOutput (int out_num, byte val) 
.................... { 
.................... 	WriteAnalogueOutput (out_num, val); 
*
032F:  BSF    03.5
0330:  MOVF   63,W
0331:  MOVWF  65
0332:  MOVF   64,W
0333:  MOVWF  66
0334:  BCF    03.5
*
037D:  RETLW  00
.................... } 
....................  
....................  
.................... 
.................... #include "midiin.h" 
....................  /************************************************************* 
.................... * Author: Angelo Fraietta 
.................... * Description Process the reception of Input and output using a  
.................... * sixteen byte queue 
.................... * Dependancy : calls ProcessMidiIn 
.................... *************************************************************/ 
.................... #byte PIR1 = 0x0C 
.................... #byte TXREG = 0x19 
....................  
.................... // define a  volatile flag that becomes true when a char is received 
.................... // and is reset by external program 
.................... short input_unlocked;  
.................... short midi_in_sysex = false; 
....................  
....................  
.................... #define MAX_QUEUE (QUEUE_SIZE -1) 
....................  
.................... byte midi_queue_data [QUEUE_SIZE]; 
....................  
.................... int  midi_head; // the size is important as we just make the value  
.................... int  midi_tail; // cycle from 0x0 to QUEUE_SIZE by incrementing 
....................  
....................  
.................... short midi_overflow; 
....................  
.................... // return true if flag was set when we cleared it 
.................... #inline  
.................... short ClearRxFlag() 
.................... { 
.................... 	short ret; 
....................  
.................... 	ret = input_unlocked; 
*
0FCD:  BSF    03.5
0FCE:  BCF    35.0
0FCF:  BCF    03.5
0FD0:  BTFSS  29.0
0FD1:  GOTO   7D5
0FD2:  BSF    03.5
0FD3:  BSF    35.0
0FD4:  BCF    03.5
.................... 	input_unlocked = 0; 
0FD5:  BCF    29.0
.................... 	return ret; 
0FD6:  MOVLW  00
0FD7:  BSF    03.5
0FD8:  BTFSC  35.0
0FD9:  MOVLW  01
0FDA:  MOVWF  78
0FDB:  BCF    03.5
.................... } 
....................  
.................... #inline  
.................... short InQueueEmpty() 
.................... { 
....................   return midi_head == midi_tail; 
*
05F4:  MOVF   53,W
05F5:  SUBWF  52,W
05F6:  BTFSC  03.2
05F7:  GOTO   5FA
05F8:  MOVLW  00
05F9:  GOTO   5FB
05FA:  MOVLW  01
05FB:  MOVWF  78
*
0800:  MOVF   53,W
0801:  SUBWF  52,W
0802:  BTFSC  03.2
0803:  GOTO   006
0804:  MOVLW  00
0805:  GOTO   007
0806:  MOVLW  01
0807:  MOVWF  78
*
11D4:  MOVF   53,W
11D5:  SUBWF  52,W
11D6:  BTFSC  03.2
11D7:  GOTO   1DA
11D8:  MOVLW  00
11D9:  GOTO   1DB
11DA:  MOVLW  01
11DB:  MOVWF  78
*
12A9:  MOVF   53,W
12AA:  SUBWF  52,W
12AB:  BTFSC  03.2
12AC:  GOTO   2AF
12AD:  MOVLW  00
12AE:  GOTO   2B0
12AF:  MOVLW  01
12B0:  MOVWF  78
*
19C3:  MOVF   53,W
19C4:  SUBWF  52,W
19C5:  BTFSC  03.2
19C6:  GOTO   1C9
19C7:  MOVLW  00
19C8:  GOTO   1CA
19C9:  MOVLW  01
19CA:  MOVWF  78
*
1A7B:  MOVF   53,W
1A7C:  SUBWF  52,W
1A7D:  BTFSC  03.2
1A7E:  GOTO   281
1A7F:  MOVLW  00
1A80:  GOTO   282
1A81:  MOVLW  01
1A82:  MOVWF  78
*
1BAB:  MOVF   53,W
1BAC:  SUBWF  52,W
1BAD:  BTFSC  03.2
1BAE:  GOTO   3B1
1BAF:  MOVLW  00
1BB0:  GOTO   3B2
1BB1:  MOVLW  01
1BB2:  MOVWF  78
*
1C5B:  MOVF   53,W
1C5C:  SUBWF  52,W
1C5D:  BTFSC  03.2
1C5E:  GOTO   461
1C5F:  MOVLW  00
1C60:  GOTO   462
1C61:  MOVLW  01
1C62:  MOVWF  78
*
1D17:  MOVF   53,W
1D18:  SUBWF  52,W
1D19:  BTFSC  03.2
1D1A:  GOTO   51D
1D1B:  MOVLW  00
1D1C:  GOTO   51E
1D1D:  MOVLW  01
1D1E:  MOVWF  78
*
1DD5:  MOVF   53,W
1DD6:  SUBWF  52,W
1DD7:  BTFSC  03.2
1DD8:  GOTO   5DB
1DD9:  MOVLW  00
1DDA:  GOTO   5DC
1DDB:  MOVLW  01
1DDC:  MOVWF  78
.................... } 
....................  
....................  
.................... #inline  
.................... short InOverflow() 
.................... { 
....................   return midi_overflow; 
*
0F80:  MOVLW  00
0F81:  BTFSC  29.2
0F82:  MOVLW  01
0F83:  MOVWF  78
*
0F8C:  MOVLW  00
0F8D:  BTFSC  29.2
0F8E:  MOVLW  01
0F8F:  MOVWF  78
*
0FBA:  MOVLW  00
0FBB:  BTFSC  29.2
0FBC:  MOVLW  01
0FBD:  MOVWF  78
.................... } 
....................  
.................... #inline  
.................... short InQueueFull() 
.................... { 
*
0064:  BSF    03.5
0065:  BCF    6E.0
.................... 	short ret = false; 
.................... 	if (midi_tail != midi_head) 
0066:  BCF    03.5
0067:  MOVF   52,W
0068:  SUBWF  53,W
0069:  BTFSC  03.2
006A:  GOTO   086
.................... 		{ 
.................... 			if (!midi_head) // head is zero 
006B:  MOVF   52,F
006C:  BTFSS  03.2
006D:  GOTO   07A
.................... 				{ 
.................... 					ret = (midi_tail == MAX_QUEUE); 
006E:  MOVF   53,W
006F:  SUBLW  27
0070:  BTFSC  03.2
0071:  GOTO   076
0072:  BSF    03.5
0073:  BCF    6E.0
0074:  BCF    03.5
0075:  GOTO   079
0076:  BSF    03.5
0077:  BSF    6E.0
0078:  BCF    03.5
.................... 				} 
.................... 			else 
0079:  GOTO   086
.................... 				{ 
.................... 					ret = (midi_head == midi_tail + 1); 
007A:  MOVLW  01
007B:  ADDWF  53,W
007C:  SUBWF  52,W
007D:  BTFSC  03.2
007E:  GOTO   083
007F:  BSF    03.5
0080:  BCF    6E.0
0081:  BCF    03.5
0082:  GOTO   086
0083:  BSF    03.5
0084:  BSF    6E.0
0085:  BCF    03.5
.................... 				} 
.................... 		} 
.................... 	return ret; 
0086:  MOVLW  00
0087:  BSF    03.5
0088:  BTFSC  6E.0
0089:  MOVLW  01
008A:  MOVWF  78
008B:  BCF    03.5
.................... } 
....................  
....................  
.................... #ifdef _USE_OUT_BUFFER 
.................... #inline  
.................... short OutQueueFull() 
.................... { 
.................... 	return (!out_queue.empty && out_queue.tail == out_queue.head); 
.................... } 
.................... #endif 
....................  
.................... #inline 
.................... void InitialiseQueue() 
.................... { 
....................   midi_tail = 0;  
*
06B5:  CLRF   53
....................   midi_head = 0; 
06B6:  CLRF   52
.................... 	midi_in_sysex = false; 
06B7:  BCF    29.1
.................... } 
....................  
....................  
.................... void InitialiseInQueue() 
.................... { 
....................   disable_interrupts (INT_RDA); // disable any Midi in  
*
06B2:  BSF    03.5
06B3:  BCF    0C.5
06B4:  BCF    03.5
.................... 	InitialiseQueue (); 
.................... 	input_unlocked = true; 
*
06B8:  BSF    29.0
.................... 	midi_overflow = false; 
06B9:  BCF    29.2
....................   enable_interrupts (INT_RDA); // disable any Midi in   
06BA:  BSF    03.5
06BB:  BSF    0C.5
06BC:  BCF    03.5
06BD:  RETLW  00
.................... } 
....................  
....................  
....................  
.................... // function called when adding function. Called by interrupt by input 
.................... #inline 
.................... void AddQueue (byte new_byte) 
.................... { 
.................... 	midi_queue_data [midi_tail] = new_byte; 
*
0095:  MOVLW  2A
0096:  ADDWF  53,W
0097:  MOVWF  04
0098:  BSF    03.5
0099:  MOVF   6E,W
009A:  MOVWF  00
.................... 	if(midi_tail == MAX_QUEUE) 
009B:  BCF    03.5
009C:  MOVF   53,W
009D:  SUBLW  27
009E:  BTFSS  03.2
009F:  GOTO   0A2
.................... 	{ 
.................... 	  midi_tail = 0; 
00A0:  CLRF   53
.................... 	} 
.................... 	else 
00A1:  GOTO   0A3
.................... 	{ 
.................... 	  midi_tail++; 
00A2:  INCF   53,F
.................... 	} 
.................... }   
....................  
.................... #inline  
.................... byte GetQueue () 
.................... { 
....................   byte ret; 
....................   ret = midi_queue_data [midi_head];  
*
080F:  MOVLW  2A
0810:  ADDWF  52,W
0811:  MOVWF  04
0812:  MOVF   00,W
0813:  BSF    03.5
0814:  MOVWF  59
.................... 	if (midi_head == MAX_QUEUE) 
0815:  BCF    03.5
0816:  MOVF   52,W
0817:  SUBLW  27
0818:  BTFSS  03.2
0819:  GOTO   01C
.................... 		{ 
.................... 			midi_head = 0; 
081A:  CLRF   52
.................... 		} 
.................... 	else 
081B:  GOTO   01D
.................... 		{ 
.................... 			midi_head++; 
081C:  INCF   52,F
.................... 		} 
....................  
.................... 	return ret; 
081D:  BSF    03.5
081E:  MOVF   59,W
081F:  MOVWF  78
0820:  BCF    03.5
.................... } 
....................  
.................... #inline 
.................... void ClearInQueueOverflow() 
.................... { 
....................   midi_overflow = false; 
.................... } 
....................  
.................... #inline 
.................... void AddInQueue (byte new_byte) 
.................... { 
....................   if (InQueueFull()) 
*
008C:  MOVF   78,F
008D:  BTFSC  03.2
008E:  GOTO   091
....................   { 
....................     midi_overflow = true; 
008F:  BSF    29.2
....................   } 
....................   else 
0090:  GOTO   0A3
....................   {	 
....................     AddQueue (new_byte); 
0091:  BSF    03.5
0092:  MOVF   6D,W
0093:  MOVWF  6E
0094:  BCF    03.5
....................   } 
.................... } 
....................  
.................... #int_rda 
.................... DataReceived() 
.................... { 
....................   int midi_char; 
....................   midi_char = getc(); 
*
004C:  GOTO   03E
004D:  MOVF   78,W
004E:  BSF    03.5
004F:  MOVWF  6C
....................  
.................... 	if (bit_test (midi_char, 7)) 
0050:  BTFSC  6C.7
0051:  GOTO   054
0052:  BCF    03.5
0053:  GOTO   060
0054:  BCF    03.5
.................... 		{ 
.................... 		midi_in_sysex = (midi_char == 0xf0); 
0055:  BSF    03.5
0056:  MOVF   6C,W
0057:  SUBLW  F0
0058:  BTFSS  03.2
0059:  GOTO   05C
005A:  BCF    03.5
005B:  GOTO   05F
005C:  BCF    03.5
005D:  BCF    29.1
005E:  GOTO   060
005F:  BSF    29.1
.................... 		} 
....................  
....................   AddInQueue (midi_char); 
0060:  BSF    03.5
0061:  MOVF   6C,W
0062:  MOVWF  6D
0063:  BCF    03.5
.................... } 
....................  
....................  
....................  
....................  
*
00A3:  BCF    0C.5
00A4:  BCF    0A.3
00A5:  BCF    0A.4
00A6:  GOTO   020
.................... #inline  
.................... void WriteBlueTooth (byte out_byte) 
.................... { 
....................  
....................   disable_interrupts(GLOBAL); 
*
1420:  BCF    0B.6
1421:  BCF    0B.7
1422:  BTFSC  0B.7
1423:  GOTO   421
*
143C:  BCF    0B.6
143D:  BCF    0B.7
143E:  BTFSC  0B.7
143F:  GOTO   43D
*
144D:  BCF    0B.6
144E:  BCF    0B.7
144F:  BTFSC  0B.7
1450:  GOTO   44E
.................... 	#use rs232(baud=115200, xmit=BLUETOOTH_OUT_PIN, rcv=0, ERRORS)  
*
07BF:  BCF    54.5
07C0:  MOVF   54,W
07C1:  BSF    03.5
07C2:  MOVWF  07
07C3:  BCF    03.5
07C4:  BCF    07.5
07C5:  MOVLW  08
07C6:  MOVWF  78
07C7:  NOP
07C8:  NOP
07C9:  NOP
07CA:  BSF    78.7
07CB:  GOTO   7E4
07CC:  BCF    78.7
07CD:  BSF    03.5
07CE:  MOVF   36,W
07CF:  MOVWF  79
07D0:  BCF    03.5
07D1:  RRF    79,F
07D2:  BTFSC  03.0
07D3:  BSF    07.5
07D4:  BTFSS  03.0
07D5:  BCF    07.5
07D6:  BSF    78.6
07D7:  GOTO   7E4
07D8:  BCF    78.6
07D9:  DECFSZ 78,F
07DA:  GOTO   7D1
07DB:  MOVF   79,W
07DC:  BSF    03.5
07DD:  MOVWF  36
07DE:  NOP
07DF:  NOP
07E0:  NOP
07E1:  BCF    03.5
07E2:  BSF    07.5
07E3:  GOTO   7E4
07E4:  MOVLW  08
07E5:  MOVWF  04
07E6:  DECFSZ 04,F
07E7:  GOTO   7E6
07E8:  NOP
07E9:  BTFSC  78.7
07EA:  GOTO   7CC
07EB:  BTFSC  78.6
07EC:  GOTO   7D8
07ED:  RETLW  00
....................  
.................... #ifndef _SIMULATE 
.................... 	putc (out_byte); 
*
1424:  BSF    03.5
1425:  MOVF   35,W
1426:  MOVWF  36
1427:  BCF    03.5
1428:  BCF    0A.4
1429:  CALL   7BF
142A:  BSF    0A.4
*
1440:  BSF    03.5
1441:  MOVF   35,W
1442:  MOVWF  36
1443:  BCF    03.5
1444:  BCF    0A.4
1445:  CALL   7BF
1446:  BSF    0A.4
*
1451:  BSF    03.5
1452:  MOVF   35,W
1453:  MOVWF  36
1454:  BCF    03.5
1455:  BCF    0A.4
1456:  CALL   7BF
1457:  BSF    0A.4
.................... #endif 
.................... #use rs232(baud=31250, xmit=MIDIOUT_1_PIN, rcv=MIDI_IN_PIN, ERRORS)  
....................   enable_interrupts(GLOBAL); 
*
142B:  MOVLW  C0
142C:  IORWF  0B,F
*
1447:  MOVLW  C0
1448:  IORWF  0B,F
*
1458:  MOVLW  C0
1459:  IORWF  0B,F
....................  
....................  
.................... } 
....................  
.................... #inline  
.................... void WriteOutData (byte out_byte) 
.................... { 
.................... #use rs232(baud=31250, xmit=MIDIOUT_1_PIN, rcv=MIDI_IN_PIN, ERRORS)  
.................... #ifndef _SIMULATE 
.................... 	putc (out_byte); 
*
01CA:  BSF    03.5
01CB:  MOVF   5D,W
01CC:  BCF    03.5
01CD:  BTFSS  0C.4
01CE:  GOTO   1CD
01CF:  MOVWF  19
*
021B:  BSF    03.5
021C:  MOVF   5D,W
021D:  BCF    03.5
021E:  BTFSS  0C.4
021F:  GOTO   21E
0220:  MOVWF  19
*
0225:  BSF    03.5
0226:  MOVF   5D,W
0227:  BCF    03.5
0228:  BTFSS  0C.4
0229:  GOTO   228
022A:  MOVWF  19
*
0275:  BSF    03.5
0276:  MOVF   5D,W
0277:  BCF    03.5
0278:  BTFSS  0C.4
0279:  GOTO   278
027A:  MOVWF  19
*
027F:  BSF    03.5
0280:  MOVF   5D,W
0281:  BCF    03.5
0282:  BTFSS  0C.4
0283:  GOTO   282
0284:  MOVWF  19
*
02D2:  BSF    03.5
02D3:  MOVF   5D,W
02D4:  BCF    03.5
02D5:  BTFSS  0C.4
02D6:  GOTO   2D5
02D7:  MOVWF  19
*
02DC:  BSF    03.5
02DD:  MOVF   5D,W
02DE:  BCF    03.5
02DF:  BTFSS  0C.4
02E0:  GOTO   2DF
02E1:  MOVWF  19
*
064B:  BSF    03.5
064C:  MOVF   5D,W
064D:  BCF    03.5
064E:  BTFSS  0C.4
064F:  GOTO   64E
0650:  MOVWF  19
*
084F:  BSF    03.5
0850:  MOVF   5D,W
0851:  BCF    03.5
0852:  BTFSS  0C.4
0853:  GOTO   052
0854:  MOVWF  19
*
0939:  BSF    03.5
093A:  MOVF   5D,W
093B:  BCF    03.5
093C:  BTFSS  0C.4
093D:  GOTO   13C
093E:  MOVWF  19
*
0943:  BSF    03.5
0944:  MOVF   5D,W
0945:  BCF    03.5
0946:  BTFSS  0C.4
0947:  GOTO   146
0948:  MOVWF  19
*
094D:  BSF    03.5
094E:  MOVF   5D,W
094F:  BCF    03.5
0950:  BTFSS  0C.4
0951:  GOTO   150
0952:  MOVWF  19
*
09A1:  BSF    03.5
09A2:  MOVF   5D,W
09A3:  BCF    03.5
09A4:  BTFSS  0C.4
09A5:  GOTO   1A4
09A6:  MOVWF  19
*
09AB:  BSF    03.5
09AC:  MOVF   5D,W
09AD:  BCF    03.5
09AE:  BTFSS  0C.4
09AF:  GOTO   1AE
09B0:  MOVWF  19
*
09FF:  BSF    03.5
0A00:  MOVF   5D,W
0A01:  BCF    03.5
0A02:  BTFSS  0C.4
0A03:  GOTO   202
0A04:  MOVWF  19
*
0A09:  BSF    03.5
0A0A:  MOVF   5D,W
0A0B:  BCF    03.5
0A0C:  BTFSS  0C.4
0A0D:  GOTO   20C
0A0E:  MOVWF  19
*
0A6B:  BSF    03.5
0A6C:  MOVF   5D,W
0A6D:  BCF    03.5
0A6E:  BTFSS  0C.4
0A6F:  GOTO   26E
0A70:  MOVWF  19
*
0A75:  BSF    03.5
0A76:  MOVF   5D,W
0A77:  BCF    03.5
0A78:  BTFSS  0C.4
0A79:  GOTO   278
0A7A:  MOVWF  19
*
0AD9:  BSF    03.5
0ADA:  MOVF   5D,W
0ADB:  BCF    03.5
0ADC:  BTFSS  0C.4
0ADD:  GOTO   2DC
0ADE:  MOVWF  19
*
0AE3:  BSF    03.5
0AE4:  MOVF   5D,W
0AE5:  BCF    03.5
0AE6:  BTFSS  0C.4
0AE7:  GOTO   2E6
0AE8:  MOVWF  19
*
0AF5:  BSF    03.5
0AF6:  MOVF   5D,W
0AF7:  BCF    03.5
0AF8:  BTFSS  0C.4
0AF9:  GOTO   2F8
0AFA:  MOVWF  19
*
0B65:  BSF    03.5
0B66:  MOVF   5D,W
0B67:  BCF    03.5
0B68:  BTFSS  0C.4
0B69:  GOTO   368
0B6A:  MOVWF  19
*
0CA0:  BSF    03.5
0CA1:  MOVF   5D,W
0CA2:  BCF    03.5
0CA3:  BTFSS  0C.4
0CA4:  GOTO   4A3
0CA5:  MOVWF  19
*
0CCB:  BSF    03.5
0CCC:  MOVF   5D,W
0CCD:  BCF    03.5
0CCE:  BTFSS  0C.4
0CCF:  GOTO   4CE
0CD0:  MOVWF  19
*
122F:  BSF    03.5
1230:  MOVF   5D,W
1231:  BCF    03.5
1232:  BTFSS  0C.4
1233:  GOTO   232
1234:  MOVWF  19
*
1304:  BSF    03.5
1305:  MOVF   5D,W
1306:  BCF    03.5
1307:  BTFSS  0C.4
1308:  GOTO   307
1309:  MOVWF  19
*
1AD6:  BSF    03.5
1AD7:  MOVF   5D,W
1AD8:  BCF    03.5
1AD9:  BTFSS  0C.4
1ADA:  GOTO   2D9
1ADB:  MOVWF  19
*
1C06:  BSF    03.5
1C07:  MOVF   5D,W
1C08:  BCF    03.5
1C09:  BTFSS  0C.4
1C0A:  GOTO   409
1C0B:  MOVWF  19
*
1CB6:  BSF    03.5
1CB7:  MOVF   5D,W
1CB8:  BCF    03.5
1CB9:  BTFSS  0C.4
1CBA:  GOTO   4B9
1CBB:  MOVWF  19
*
1D72:  BSF    03.5
1D73:  MOVF   5D,W
1D74:  BCF    03.5
1D75:  BTFSS  0C.4
1D76:  GOTO   575
1D77:  MOVWF  19
*
1E30:  BSF    03.5
1E31:  MOVF   5D,W
1E32:  BCF    03.5
1E33:  BTFSS  0C.4
1E34:  GOTO   633
1E35:  MOVWF  19
.................... #endif 
....................  
.................... } 
....................  
.................... #inline 
.................... byte GetInChar() 
.................... { 
....................   byte ret; 
....................    
....................   disable_interrupts (INT_RDA); // disable any Midi in  
*
080C:  BSF    03.5
080D:  BCF    0C.5
080E:  BCF    03.5
....................  
....................   ret = GetQueue (); 
*
0821:  MOVF   78,W
0822:  BSF    03.5
0823:  MOVWF  58
....................    
....................   enable_interrupts (INT_RDA); // re-enable Midi in  
0824:  BSF    0C.5
....................  
....................   input_unlocked = true; // set flag 
0825:  BCF    03.5
0826:  BSF    29.0
....................  
....................   return ret; 
0827:  BSF    03.5
0828:  MOVF   58,W
0829:  MOVWF  78
082A:  BCF    03.5
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #inline  
.................... void WriteOutData2 (byte out_byte) 
.................... { 
.................... #use rs232(baud=31250, xmit=MIDIOUT_2_PIN, rcv=MIDI_IN_PIN, ERRORS)  
*
041F:  BCF    54.5
0420:  MOVF   54,W
0421:  BSF    03.5
0422:  MOVWF  07
0423:  BCF    03.5
0424:  BCF    07.5
0425:  MOVLW  08
0426:  MOVWF  78
0427:  NOP
0428:  NOP
0429:  NOP
042A:  BSF    78.7
042B:  GOTO   43E
042C:  BCF    78.7
042D:  BSF    03.5
042E:  RRF    56,F
042F:  BCF    03.5
0430:  BTFSC  03.0
0431:  BSF    07.5
0432:  BTFSS  03.0
0433:  BCF    07.5
0434:  BSF    78.6
0435:  GOTO   43E
0436:  BCF    78.6
0437:  DECFSZ 78,F
0438:  GOTO   42D
0439:  NOP
043A:  NOP
043B:  NOP
043C:  BSF    07.5
043D:  GOTO   43E
043E:  MOVLW  2F
043F:  MOVWF  04
0440:  DECFSZ 04,F
0441:  GOTO   440
0442:  BTFSC  78.7
0443:  GOTO   42C
0444:  BTFSC  78.6
0445:  GOTO   436
0446:  RETLW  00
....................   // we have to disable the interrupts here otherwise the data will become corrupted because it has no uart 
....................   disable_interrupts(GLOBAL); 
*
0637:  BCF    0B.6
0638:  BCF    0B.7
0639:  BTFSC  0B.7
063A:  GOTO   638
*
1219:  BCF    0B.6
121A:  BCF    0B.7
121B:  BTFSC  0B.7
121C:  GOTO   21A
*
12EE:  BCF    0B.6
12EF:  BCF    0B.7
12F0:  BTFSC  0B.7
12F1:  GOTO   2EF
*
1ABE:  BCF    0B.6
1ABF:  BCF    0B.7
1AC0:  BTFSC  0B.7
1AC1:  GOTO   2BF
*
1BEE:  BCF    0B.6
1BEF:  BCF    0B.7
1BF0:  BTFSC  0B.7
1BF1:  GOTO   3EF
*
1C9E:  BCF    0B.6
1C9F:  BCF    0B.7
1CA0:  BTFSC  0B.7
1CA1:  GOTO   49F
*
1D5A:  BCF    0B.6
1D5B:  BCF    0B.7
1D5C:  BTFSC  0B.7
1D5D:  GOTO   55B
*
1E18:  BCF    0B.6
1E19:  BCF    0B.7
1E1A:  BTFSC  0B.7
1E1B:  GOTO   619
.................... #ifndef _SIMULATE 
.................... 	putc (out_byte); 
*
063B:  BSF    03.5
063C:  MOVF   55,W
063D:  MOVWF  56
063E:  BCF    03.5
063F:  CALL   41F
*
121D:  BSF    03.5
121E:  MOVF   55,W
121F:  MOVWF  56
1220:  BCF    03.5
1221:  BCF    0A.4
1222:  CALL   41F
1223:  BSF    0A.4
*
12F2:  BSF    03.5
12F3:  MOVF   55,W
12F4:  MOVWF  56
12F5:  BCF    03.5
12F6:  BCF    0A.4
12F7:  CALL   41F
12F8:  BSF    0A.4
*
1AC2:  BSF    03.5
1AC3:  MOVF   55,W
1AC4:  MOVWF  56
1AC5:  BCF    03.5
1AC6:  BCF    0A.4
1AC7:  BCF    0A.3
1AC8:  CALL   41F
1AC9:  BSF    0A.4
1ACA:  BSF    0A.3
*
1BF2:  BSF    03.5
1BF3:  MOVF   55,W
1BF4:  MOVWF  56
1BF5:  BCF    03.5
1BF6:  BCF    0A.4
1BF7:  BCF    0A.3
1BF8:  CALL   41F
1BF9:  BSF    0A.4
1BFA:  BSF    0A.3
*
1CA2:  BSF    03.5
1CA3:  MOVF   55,W
1CA4:  MOVWF  56
1CA5:  BCF    03.5
1CA6:  BCF    0A.4
1CA7:  BCF    0A.3
1CA8:  CALL   41F
1CA9:  BSF    0A.4
1CAA:  BSF    0A.3
*
1D5E:  BSF    03.5
1D5F:  MOVF   55,W
1D60:  MOVWF  56
1D61:  BCF    03.5
1D62:  BCF    0A.4
1D63:  BCF    0A.3
1D64:  CALL   41F
1D65:  BSF    0A.4
1D66:  BSF    0A.3
*
1E1C:  BSF    03.5
1E1D:  MOVF   55,W
1E1E:  MOVWF  56
1E1F:  BCF    03.5
1E20:  BCF    0A.4
1E21:  BCF    0A.3
1E22:  CALL   41F
1E23:  BSF    0A.4
1E24:  BSF    0A.3
.................... #endif 
....................   enable_interrupts(GLOBAL); 
*
0640:  MOVLW  C0
0641:  IORWF  0B,F
*
1224:  MOVLW  C0
1225:  IORWF  0B,F
*
12F9:  MOVLW  C0
12FA:  IORWF  0B,F
*
1ACB:  MOVLW  C0
1ACC:  IORWF  0B,F
*
1BFB:  MOVLW  C0
1BFC:  IORWF  0B,F
*
1CAB:  MOVLW  C0
1CAC:  IORWF  0B,F
*
1D67:  MOVLW  C0
1D68:  IORWF  0B,F
*
1E25:  MOVLW  C0
1E26:  IORWF  0B,F
.................... } 
....................  
....................  
....................  
....................  
.................... 
.................... #include "sysexout.h" 
....................  #ifndef SYSEX_OUT_H 
.................... #define SYSEX_OUT_H 
....................  
.................... /* Sysex Out module used for Encoding Sysex Messages*/ 
.................... #pragma inline 
.................... void WriteSysexOutData (byte out_byte) 
.................... { 
.................... 	byte control_byte; 
....................  
.................... 	control_byte = EncodeMidiByte (&out_byte); 
*
01D5:  MOVLW  DB
01D6:  BSF    03.5
01D7:  MOVWF  5D
01D8:  BCF    03.5
*
020E:  MOVF   78,W
020F:  BSF    03.5
0210:  MOVWF  5C
*
022F:  MOVLW  DB
0230:  BSF    03.5
0231:  MOVWF  5D
0232:  BCF    03.5
*
0268:  MOVF   78,W
0269:  BSF    03.5
026A:  MOVWF  5C
*
028C:  MOVLW  DB
028D:  BSF    03.5
028E:  MOVWF  5D
028F:  BCF    03.5
*
02C5:  MOVF   78,W
02C6:  BSF    03.5
02C7:  MOVWF  5C
*
08F3:  MOVLW  DB
08F4:  BSF    03.5
08F5:  MOVWF  5D
08F6:  BCF    03.5
*
092C:  MOVF   78,W
092D:  BSF    03.5
092E:  MOVWF  5C
*
095B:  MOVLW  DB
095C:  BSF    03.5
095D:  MOVWF  5D
095E:  BCF    03.5
*
0994:  MOVF   78,W
0995:  BSF    03.5
0996:  MOVWF  5C
*
09B9:  MOVLW  DB
09BA:  BSF    03.5
09BB:  MOVWF  5D
09BC:  BCF    03.5
*
09F2:  MOVF   78,W
09F3:  BSF    03.5
09F4:  MOVWF  5C
*
0A25:  MOVLW  DB
0A26:  BSF    03.5
0A27:  MOVWF  5D
0A28:  BCF    03.5
*
0A5E:  MOVF   78,W
0A5F:  BSF    03.5
0A60:  MOVWF  5C
*
0A93:  MOVLW  DB
0A94:  BSF    03.5
0A95:  MOVWF  5D
0A96:  BCF    03.5
*
0ACC:  MOVF   78,W
0ACD:  BSF    03.5
0ACE:  MOVWF  5C
....................  
.................... 	if (control_byte) 
*
0211:  MOVF   5C,F
0212:  BTFSS  03.2
0213:  GOTO   216
0214:  BCF    03.5
0215:  GOTO   221
0216:  BCF    03.5
*
026B:  MOVF   5C,F
026C:  BTFSS  03.2
026D:  GOTO   270
026E:  BCF    03.5
026F:  GOTO   27B
0270:  BCF    03.5
*
02C8:  MOVF   5C,F
02C9:  BTFSS  03.2
02CA:  GOTO   2CD
02CB:  BCF    03.5
02CC:  GOTO   2D8
02CD:  BCF    03.5
*
092F:  MOVF   5C,F
0930:  BTFSS  03.2
0931:  GOTO   134
0932:  BCF    03.5
0933:  GOTO   13F
0934:  BCF    03.5
*
0997:  MOVF   5C,F
0998:  BTFSS  03.2
0999:  GOTO   19C
099A:  BCF    03.5
099B:  GOTO   1A7
099C:  BCF    03.5
*
09F5:  MOVF   5C,F
09F6:  BTFSS  03.2
09F7:  GOTO   1FA
09F8:  BCF    03.5
09F9:  GOTO   205
09FA:  BCF    03.5
*
0A61:  MOVF   5C,F
0A62:  BTFSS  03.2
0A63:  GOTO   266
0A64:  BCF    03.5
0A65:  GOTO   271
0A66:  BCF    03.5
*
0ACF:  MOVF   5C,F
0AD0:  BTFSS  03.2
0AD1:  GOTO   2D4
0AD2:  BCF    03.5
0AD3:  GOTO   2DF
0AD4:  BCF    03.5
.................... 		{ 
.................... 			WriteOutData (control_byte); 
*
0217:  BSF    03.5
0218:  MOVF   5C,W
0219:  MOVWF  5D
021A:  BCF    03.5
*
0271:  BSF    03.5
0272:  MOVF   5C,W
0273:  MOVWF  5D
0274:  BCF    03.5
*
02CE:  BSF    03.5
02CF:  MOVF   5C,W
02D0:  MOVWF  5D
02D1:  BCF    03.5
*
0935:  BSF    03.5
0936:  MOVF   5C,W
0937:  MOVWF  5D
0938:  BCF    03.5
*
099D:  BSF    03.5
099E:  MOVF   5C,W
099F:  MOVWF  5D
09A0:  BCF    03.5
*
09FB:  BSF    03.5
09FC:  MOVF   5C,W
09FD:  MOVWF  5D
09FE:  BCF    03.5
*
0A67:  BSF    03.5
0A68:  MOVF   5C,W
0A69:  MOVWF  5D
0A6A:  BCF    03.5
*
0AD5:  BSF    03.5
0AD6:  MOVF   5C,W
0AD7:  MOVWF  5D
0AD8:  BCF    03.5
.................... 		} 
.................... 	WriteOutData (out_byte); 
*
0221:  BSF    03.5
0222:  MOVF   5B,W
0223:  MOVWF  5D
0224:  BCF    03.5
*
027B:  BSF    03.5
027C:  MOVF   5B,W
027D:  MOVWF  5D
027E:  BCF    03.5
*
02D8:  BSF    03.5
02D9:  MOVF   5B,W
02DA:  MOVWF  5D
02DB:  BCF    03.5
*
093F:  BSF    03.5
0940:  MOVF   5B,W
0941:  MOVWF  5D
0942:  BCF    03.5
*
09A7:  BSF    03.5
09A8:  MOVF   5B,W
09A9:  MOVWF  5D
09AA:  BCF    03.5
*
0A05:  BSF    03.5
0A06:  MOVF   5B,W
0A07:  MOVWF  5D
0A08:  BCF    03.5
*
0A71:  BSF    03.5
0A72:  MOVF   5B,W
0A73:  MOVWF  5D
0A74:  BCF    03.5
*
0ADF:  BSF    03.5
0AE0:  MOVF   5B,W
0AE1:  MOVWF  5D
0AE2:  BCF    03.5
.................... } // end WriteSysexOutData 
....................  
....................  
.................... void WriteSysexHeader() 
.................... { 
....................   WriteOutData (SYSEX_BEGIN); 
*
01C6:  MOVLW  F0
01C7:  BSF    03.5
01C8:  MOVWF  5D
01C9:  BCF    03.5
....................   restart_wdt();					 
*
01D0:  CLRWDT
.................... 	WriteSysexOutData (SYSEX_ID); 
01D1:  MOVLW  7D
01D2:  BSF    03.5
01D3:  MOVWF  5B
01D4:  BCF    03.5
....................   restart_wdt();					   
*
022B:  CLRWDT
.................... 	WriteSysexOutData (EQUIPMENT_TYPE); 
022C:  BSF    03.5
022D:  CLRF   5B
022E:  BCF    03.5
....................   restart_wdt();					 
*
0285:  CLRWDT
.................... 	WriteSysexOutData (ReadDeviceId()); 
0286:  CALL   1AE
0287:  MOVF   78,W
0288:  BSF    03.5
0289:  MOVWF  5A
028A:  MOVWF  5B
028B:  BCF    03.5
....................   restart_wdt();					 
*
02E2:  CLRWDT
02E3:  RETLW  00
.................... } 
....................  
.................... #endif 
....................  
.................... 
.................... #include "midiout.h" 
....................  /************************************************************** 
....................  * Author: Angelo Fraietta 
....................  * Description: Midi output interface 
....................  *************************************************************/ 
....................  
.................... // forward declarations 
.................... void ProcessMidiInputStream(); 
.................... short MidiOutFree(); 
.................... void SetLastStatusChan(byte); 
.................... int ReadAnaResolution(); 
....................  
.................... #inline 
.................... void OutputMidi (str_midiconfig* midi_msg) 
.................... { 
.................... 	int num_bytes; 
.................... 	byte* msg_ptr; 
.................... 	int i; 
....................   short midi_out_2; 
....................  
....................   midi_out_2 = (midi_msg->config_flag & MIDI_OUTPUT2_MASK) && !(midi_msg->config_flag & VALUE_SCALING_FLAG); 
*
05B5:  MOVLW  03
05B6:  BSF    03.5
05B7:  ADDWF  4F,W
05B8:  MOVWF  04
05B9:  MOVF   00,W
05BA:  ANDLW  08
05BB:  XORLW  00
05BC:  BTFSS  03.2
05BD:  GOTO   5C0
05BE:  BCF    03.5
05BF:  GOTO   5CD
05C0:  BCF    03.5
05C1:  MOVLW  03
05C2:  BSF    03.5
05C3:  ADDWF  4F,W
05C4:  MOVWF  04
05C5:  MOVF   00,W
05C6:  ANDLW  80
05C7:  XORLW  00
05C8:  BTFSS  03.2
05C9:  GOTO   5CC
05CA:  BCF    03.5
05CB:  GOTO   5D1
05CC:  BCF    03.5
05CD:  BSF    03.5
05CE:  BCF    53.0
05CF:  BCF    03.5
05D0:  GOTO   5D4
05D1:  BSF    03.5
05D2:  BSF    53.0
05D3:  BCF    03.5
*
1193:  MOVLW  03
1194:  BSF    03.5
1195:  ADDWF  4F,W
1196:  MOVWF  04
1197:  MOVF   00,W
1198:  ANDLW  08
1199:  XORLW  00
119A:  BTFSS  03.2
119B:  GOTO   19E
119C:  BCF    03.5
119D:  GOTO   1AB
119E:  BCF    03.5
119F:  MOVLW  03
11A0:  BSF    03.5
11A1:  ADDWF  4F,W
11A2:  MOVWF  04
11A3:  MOVF   00,W
11A4:  ANDLW  80
11A5:  XORLW  00
11A6:  BTFSS  03.2
11A7:  GOTO   1AA
11A8:  BCF    03.5
11A9:  GOTO   1AF
11AA:  BCF    03.5
11AB:  BSF    03.5
11AC:  BCF    53.0
11AD:  BCF    03.5
11AE:  GOTO   1B2
11AF:  BSF    03.5
11B0:  BSF    53.0
11B1:  BCF    03.5
*
1268:  MOVLW  03
1269:  BSF    03.5
126A:  ADDWF  4F,W
126B:  MOVWF  04
126C:  MOVF   00,W
126D:  ANDLW  08
126E:  XORLW  00
126F:  BTFSS  03.2
1270:  GOTO   273
1271:  BCF    03.5
1272:  GOTO   280
1273:  BCF    03.5
1274:  MOVLW  03
1275:  BSF    03.5
1276:  ADDWF  4F,W
1277:  MOVWF  04
1278:  MOVF   00,W
1279:  ANDLW  80
127A:  XORLW  00
127B:  BTFSS  03.2
127C:  GOTO   27F
127D:  BCF    03.5
127E:  GOTO   284
127F:  BCF    03.5
1280:  BSF    03.5
1281:  BCF    53.0
1282:  BCF    03.5
1283:  GOTO   287
1284:  BSF    03.5
1285:  BSF    53.0
1286:  BCF    03.5
*
1A38:  MOVLW  03
1A39:  BSF    03.5
1A3A:  ADDWF  4F,W
1A3B:  MOVWF  04
1A3C:  MOVF   00,W
1A3D:  ANDLW  08
1A3E:  XORLW  00
1A3F:  BTFSS  03.2
1A40:  GOTO   243
1A41:  BCF    03.5
1A42:  GOTO   250
1A43:  BCF    03.5
1A44:  MOVLW  03
1A45:  BSF    03.5
1A46:  ADDWF  4F,W
1A47:  MOVWF  04
1A48:  MOVF   00,W
1A49:  ANDLW  80
1A4A:  XORLW  00
1A4B:  BTFSS  03.2
1A4C:  GOTO   24F
1A4D:  BCF    03.5
1A4E:  GOTO   254
1A4F:  BCF    03.5
1A50:  BSF    03.5
1A51:  BCF    53.0
1A52:  BCF    03.5
1A53:  GOTO   257
1A54:  BSF    03.5
1A55:  BSF    53.0
1A56:  BCF    03.5
*
1B68:  MOVLW  03
1B69:  BSF    03.5
1B6A:  ADDWF  4F,W
1B6B:  MOVWF  04
1B6C:  MOVF   00,W
1B6D:  ANDLW  08
1B6E:  XORLW  00
1B6F:  BTFSS  03.2
1B70:  GOTO   373
1B71:  BCF    03.5
1B72:  GOTO   380
1B73:  BCF    03.5
1B74:  MOVLW  03
1B75:  BSF    03.5
1B76:  ADDWF  4F,W
1B77:  MOVWF  04
1B78:  MOVF   00,W
1B79:  ANDLW  80
1B7A:  XORLW  00
1B7B:  BTFSS  03.2
1B7C:  GOTO   37F
1B7D:  BCF    03.5
1B7E:  GOTO   384
1B7F:  BCF    03.5
1B80:  BSF    03.5
1B81:  BCF    53.0
1B82:  BCF    03.5
1B83:  GOTO   387
1B84:  BSF    03.5
1B85:  BSF    53.0
1B86:  BCF    03.5
*
1C18:  MOVLW  03
1C19:  BSF    03.5
1C1A:  ADDWF  4F,W
1C1B:  MOVWF  04
1C1C:  MOVF   00,W
1C1D:  ANDLW  08
1C1E:  XORLW  00
1C1F:  BTFSS  03.2
1C20:  GOTO   423
1C21:  BCF    03.5
1C22:  GOTO   430
1C23:  BCF    03.5
1C24:  MOVLW  03
1C25:  BSF    03.5
1C26:  ADDWF  4F,W
1C27:  MOVWF  04
1C28:  MOVF   00,W
1C29:  ANDLW  80
1C2A:  XORLW  00
1C2B:  BTFSS  03.2
1C2C:  GOTO   42F
1C2D:  BCF    03.5
1C2E:  GOTO   434
1C2F:  BCF    03.5
1C30:  BSF    03.5
1C31:  BCF    53.0
1C32:  BCF    03.5
1C33:  GOTO   437
1C34:  BSF    03.5
1C35:  BSF    53.0
1C36:  BCF    03.5
*
1CD4:  MOVLW  03
1CD5:  BSF    03.5
1CD6:  ADDWF  4F,W
1CD7:  MOVWF  04
1CD8:  MOVF   00,W
1CD9:  ANDLW  08
1CDA:  XORLW  00
1CDB:  BTFSS  03.2
1CDC:  GOTO   4DF
1CDD:  BCF    03.5
1CDE:  GOTO   4EC
1CDF:  BCF    03.5
1CE0:  MOVLW  03
1CE1:  BSF    03.5
1CE2:  ADDWF  4F,W
1CE3:  MOVWF  04
1CE4:  MOVF   00,W
1CE5:  ANDLW  80
1CE6:  XORLW  00
1CE7:  BTFSS  03.2
1CE8:  GOTO   4EB
1CE9:  BCF    03.5
1CEA:  GOTO   4F0
1CEB:  BCF    03.5
1CEC:  BSF    03.5
1CED:  BCF    53.0
1CEE:  BCF    03.5
1CEF:  GOTO   4F3
1CF0:  BSF    03.5
1CF1:  BSF    53.0
1CF2:  BCF    03.5
*
1D92:  MOVLW  03
1D93:  BSF    03.5
1D94:  ADDWF  4F,W
1D95:  MOVWF  04
1D96:  MOVF   00,W
1D97:  ANDLW  08
1D98:  XORLW  00
1D99:  BTFSS  03.2
1D9A:  GOTO   59D
1D9B:  BCF    03.5
1D9C:  GOTO   5AA
1D9D:  BCF    03.5
1D9E:  MOVLW  03
1D9F:  BSF    03.5
1DA0:  ADDWF  4F,W
1DA1:  MOVWF  04
1DA2:  MOVF   00,W
1DA3:  ANDLW  80
1DA4:  XORLW  00
1DA5:  BTFSS  03.2
1DA6:  GOTO   5A9
1DA7:  BCF    03.5
1DA8:  GOTO   5AE
1DA9:  BCF    03.5
1DAA:  BSF    03.5
1DAB:  BCF    53.0
1DAC:  BCF    03.5
1DAD:  GOTO   5B1
1DAE:  BSF    03.5
1DAF:  BSF    53.0
1DB0:  BCF    03.5
....................    
....................    
.................... 	num_bytes = NumTxBytes (midi_msg); 
*
05D4:  BSF    03.5
05D5:  MOVF   4F,W
05D6:  MOVWF  58
05D7:  BCF    03.5
05D8:  CALL   170
05D9:  MOVF   78,W
05DA:  BSF    03.5
05DB:  MOVWF  50
*
11B2:  BSF    03.5
11B3:  MOVF   4F,W
11B4:  MOVWF  58
11B5:  BCF    03.5
11B6:  BCF    0A.4
11B7:  CALL   170
11B8:  BSF    0A.4
11B9:  MOVF   78,W
11BA:  BSF    03.5
11BB:  MOVWF  50
*
1287:  BSF    03.5
1288:  MOVF   4F,W
1289:  MOVWF  58
128A:  BCF    03.5
128B:  BCF    0A.4
128C:  CALL   170
128D:  BSF    0A.4
128E:  MOVF   78,W
128F:  BSF    03.5
1290:  MOVWF  50
*
1A57:  BSF    03.5
1A58:  MOVF   4F,W
1A59:  MOVWF  58
1A5A:  BCF    03.5
1A5B:  BCF    0A.4
1A5C:  BCF    0A.3
1A5D:  CALL   170
1A5E:  BSF    0A.4
1A5F:  BSF    0A.3
1A60:  MOVF   78,W
1A61:  BSF    03.5
1A62:  MOVWF  50
*
1B87:  BSF    03.5
1B88:  MOVF   4F,W
1B89:  MOVWF  58
1B8A:  BCF    03.5
1B8B:  BCF    0A.4
1B8C:  BCF    0A.3
1B8D:  CALL   170
1B8E:  BSF    0A.4
1B8F:  BSF    0A.3
1B90:  MOVF   78,W
1B91:  BSF    03.5
1B92:  MOVWF  50
*
1C37:  BSF    03.5
1C38:  MOVF   4F,W
1C39:  MOVWF  58
1C3A:  BCF    03.5
1C3B:  BCF    0A.4
1C3C:  BCF    0A.3
1C3D:  CALL   170
1C3E:  BSF    0A.4
1C3F:  BSF    0A.3
1C40:  MOVF   78,W
1C41:  BSF    03.5
1C42:  MOVWF  50
*
1CF3:  BSF    03.5
1CF4:  MOVF   4F,W
1CF5:  MOVWF  58
1CF6:  BCF    03.5
1CF7:  BCF    0A.4
1CF8:  BCF    0A.3
1CF9:  CALL   170
1CFA:  BSF    0A.4
1CFB:  BSF    0A.3
1CFC:  MOVF   78,W
1CFD:  BSF    03.5
1CFE:  MOVWF  50
*
1DB1:  BSF    03.5
1DB2:  MOVF   4F,W
1DB3:  MOVWF  58
1DB4:  BCF    03.5
1DB5:  BCF    0A.4
1DB6:  BCF    0A.3
1DB7:  CALL   170
1DB8:  BSF    0A.4
1DB9:  BSF    0A.3
1DBA:  MOVF   78,W
1DBB:  BSF    03.5
1DBC:  MOVWF  50
.................... 	msg_ptr = (byte*) midi_msg; 
*
05DC:  MOVF   4F,W
05DD:  MOVWF  51
05DE:  BCF    03.5
*
11BC:  MOVF   4F,W
11BD:  MOVWF  51
11BE:  BCF    03.5
*
1291:  MOVF   4F,W
1292:  MOVWF  51
1293:  BCF    03.5
*
1A63:  MOVF   4F,W
1A64:  MOVWF  51
1A65:  BCF    03.5
*
1B93:  MOVF   4F,W
1B94:  MOVWF  51
1B95:  BCF    03.5
*
1C43:  MOVF   4F,W
1C44:  MOVWF  51
1C45:  BCF    03.5
*
1CFF:  MOVF   4F,W
1D00:  MOVWF  51
1D01:  BCF    03.5
*
1DBD:  MOVF   4F,W
1DBE:  MOVWF  51
1DBF:  BCF    03.5
....................  
.................... 	// make sure that there is no merge happening 
.................... 	while (!MidiOutFree()) 
*
060C:  MOVF   78,F
060D:  BTFSS  03.2
060E:  GOTO   613
*
11EC:  MOVF   78,F
11ED:  BTFSS  03.2
11EE:  GOTO   1F5
*
12C1:  MOVF   78,F
12C2:  BTFSS  03.2
12C3:  GOTO   2CA
*
1A93:  MOVF   78,F
1A94:  BTFSS  03.2
1A95:  GOTO   29A
*
1BC3:  MOVF   78,F
1BC4:  BTFSS  03.2
1BC5:  GOTO   3CA
*
1C73:  MOVF   78,F
1C74:  BTFSS  03.2
1C75:  GOTO   47A
*
1D2F:  MOVF   78,F
1D30:  BTFSS  03.2
1D31:  GOTO   536
*
1DED:  MOVF   78,F
1DEE:  BTFSS  03.2
1DEF:  GOTO   5F4
.................... 		{ 
.................... 			ProcessMidiInputStream(); 
*
060F:  BSF    0A.3
0610:  CALL   000
0611:  BCF    0A.3
*
11EF:  BCF    0A.4
11F0:  BSF    0A.3
11F1:  CALL   000
11F2:  BSF    0A.4
11F3:  BCF    0A.3
*
12C4:  BCF    0A.4
12C5:  BSF    0A.3
12C6:  CALL   000
12C7:  BSF    0A.4
12C8:  BCF    0A.3
*
1A96:  BCF    0A.4
1A97:  CALL   000
1A98:  BSF    0A.4
*
1BC6:  BCF    0A.4
1BC7:  CALL   000
1BC8:  BSF    0A.4
*
1C76:  BCF    0A.4
1C77:  CALL   000
1C78:  BSF    0A.4
*
1D32:  BCF    0A.4
1D33:  CALL   000
1D34:  BSF    0A.4
*
1DF0:  BCF    0A.4
1DF1:  CALL   000
1DF2:  BSF    0A.4
.................... 		} 
*
0612:  GOTO   5DF
*
11F4:  GOTO   1BF
*
12C9:  GOTO   294
*
1A99:  GOTO   266
*
1BC9:  GOTO   396
*
1C79:  GOTO   446
*
1D35:  GOTO   502
*
1DF3:  GOTO   5C0
....................  
.................... 	// store the last status that we are sending 
.................... 	SetLastStatusChan (msg_ptr[0]); 
*
0613:  BSF    03.5
0614:  MOVF   51,W
0615:  MOVWF  04
0616:  MOVF   00,W
0617:  MOVWF  54
0618:  MOVWF  55
0619:  BCF    03.5
*
11F5:  BSF    03.5
11F6:  MOVF   51,W
11F7:  MOVWF  04
11F8:  MOVF   00,W
11F9:  MOVWF  54
11FA:  MOVWF  55
11FB:  BCF    03.5
*
12CA:  BSF    03.5
12CB:  MOVF   51,W
12CC:  MOVWF  04
12CD:  MOVF   00,W
12CE:  MOVWF  54
12CF:  MOVWF  55
12D0:  BCF    03.5
*
1A9A:  BSF    03.5
1A9B:  MOVF   51,W
1A9C:  MOVWF  04
1A9D:  MOVF   00,W
1A9E:  MOVWF  54
1A9F:  MOVWF  55
1AA0:  BCF    03.5
*
1BCA:  BSF    03.5
1BCB:  MOVF   51,W
1BCC:  MOVWF  04
1BCD:  MOVF   00,W
1BCE:  MOVWF  54
1BCF:  MOVWF  55
1BD0:  BCF    03.5
*
1C7A:  BSF    03.5
1C7B:  MOVF   51,W
1C7C:  MOVWF  04
1C7D:  MOVF   00,W
1C7E:  MOVWF  54
1C7F:  MOVWF  55
1C80:  BCF    03.5
*
1D36:  BSF    03.5
1D37:  MOVF   51,W
1D38:  MOVWF  04
1D39:  MOVF   00,W
1D3A:  MOVWF  54
1D3B:  MOVWF  55
1D3C:  BCF    03.5
*
1DF4:  BSF    03.5
1DF5:  MOVF   51,W
1DF6:  MOVWF  04
1DF7:  MOVF   00,W
1DF8:  MOVWF  54
1DF9:  MOVWF  55
1DFA:  BCF    03.5
....................  
.................... 	for (i = 0; i < num_bytes; i++) 
*
061E:  BSF    03.5
061F:  CLRF   52
0620:  BCF    03.5
0621:  BSF    03.5
0622:  MOVF   50,W
0623:  SUBWF  52,W
0624:  BTFSS  03.0
0625:  GOTO   628
0626:  BCF    03.5
0627:  GOTO   655
0628:  BCF    03.5
*
1200:  BSF    03.5
1201:  CLRF   52
1202:  BCF    03.5
1203:  BSF    03.5
1204:  MOVF   50,W
1205:  SUBWF  52,W
1206:  BTFSS  03.0
1207:  GOTO   20A
1208:  BCF    03.5
1209:  GOTO   239
120A:  BCF    03.5
*
12D5:  BSF    03.5
12D6:  CLRF   52
12D7:  BCF    03.5
12D8:  BSF    03.5
12D9:  MOVF   50,W
12DA:  SUBWF  52,W
12DB:  BTFSS  03.0
12DC:  GOTO   2DF
12DD:  BCF    03.5
12DE:  GOTO   30E
12DF:  BCF    03.5
*
1AA5:  BSF    03.5
1AA6:  CLRF   52
1AA7:  BCF    03.5
1AA8:  BSF    03.5
1AA9:  MOVF   50,W
1AAA:  SUBWF  52,W
1AAB:  BTFSS  03.0
1AAC:  GOTO   2AF
1AAD:  BCF    03.5
1AAE:  GOTO   2E0
1AAF:  BCF    03.5
*
1BD5:  BSF    03.5
1BD6:  CLRF   52
1BD7:  BCF    03.5
1BD8:  BSF    03.5
1BD9:  MOVF   50,W
1BDA:  SUBWF  52,W
1BDB:  BTFSS  03.0
1BDC:  GOTO   3DF
1BDD:  BCF    03.5
1BDE:  GOTO   410
1BDF:  BCF    03.5
*
1C85:  BSF    03.5
1C86:  CLRF   52
1C87:  BCF    03.5
1C88:  BSF    03.5
1C89:  MOVF   50,W
1C8A:  SUBWF  52,W
1C8B:  BTFSS  03.0
1C8C:  GOTO   48F
1C8D:  BCF    03.5
1C8E:  GOTO   4C0
1C8F:  BCF    03.5
*
1D41:  BSF    03.5
1D42:  CLRF   52
1D43:  BCF    03.5
1D44:  BSF    03.5
1D45:  MOVF   50,W
1D46:  SUBWF  52,W
1D47:  BTFSS  03.0
1D48:  GOTO   54B
1D49:  BCF    03.5
1D4A:  GOTO   57C
1D4B:  BCF    03.5
*
1DFF:  BSF    03.5
1E00:  CLRF   52
1E01:  BCF    03.5
1E02:  BSF    03.5
1E03:  MOVF   50,W
1E04:  SUBWF  52,W
1E05:  BTFSS  03.0
1E06:  GOTO   609
1E07:  BCF    03.5
1E08:  GOTO   63A
1E09:  BCF    03.5
.................... 		{ 
....................       if (midi_out_2) 
*
0629:  BSF    03.5
062A:  BTFSC  53.0
062B:  GOTO   62E
062C:  BCF    03.5
062D:  GOTO   643
062E:  BCF    03.5
*
120B:  BSF    03.5
120C:  BTFSC  53.0
120D:  GOTO   210
120E:  BCF    03.5
120F:  GOTO   227
1210:  BCF    03.5
*
12E0:  BSF    03.5
12E1:  BTFSC  53.0
12E2:  GOTO   2E5
12E3:  BCF    03.5
12E4:  GOTO   2FC
12E5:  BCF    03.5
*
1AB0:  BSF    03.5
1AB1:  BTFSC  53.0
1AB2:  GOTO   2B5
1AB3:  BCF    03.5
1AB4:  GOTO   2CE
1AB5:  BCF    03.5
*
1BE0:  BSF    03.5
1BE1:  BTFSC  53.0
1BE2:  GOTO   3E5
1BE3:  BCF    03.5
1BE4:  GOTO   3FE
1BE5:  BCF    03.5
*
1C90:  BSF    03.5
1C91:  BTFSC  53.0
1C92:  GOTO   495
1C93:  BCF    03.5
1C94:  GOTO   4AE
1C95:  BCF    03.5
*
1D4C:  BSF    03.5
1D4D:  BTFSC  53.0
1D4E:  GOTO   551
1D4F:  BCF    03.5
1D50:  GOTO   56A
1D51:  BCF    03.5
*
1E0A:  BSF    03.5
1E0B:  BTFSC  53.0
1E0C:  GOTO   60F
1E0D:  BCF    03.5
1E0E:  GOTO   628
1E0F:  BCF    03.5
....................       { 
.................... 			  WriteOutData2 (msg_ptr [i]);  
*
062F:  BSF    03.5
0630:  MOVF   51,W
0631:  ADDWF  52,W
0632:  MOVWF  04
0633:  MOVF   00,W
0634:  MOVWF  54
0635:  MOVWF  55
0636:  BCF    03.5
*
1211:  BSF    03.5
1212:  MOVF   51,W
1213:  ADDWF  52,W
1214:  MOVWF  04
1215:  MOVF   00,W
1216:  MOVWF  54
1217:  MOVWF  55
1218:  BCF    03.5
*
12E6:  BSF    03.5
12E7:  MOVF   51,W
12E8:  ADDWF  52,W
12E9:  MOVWF  04
12EA:  MOVF   00,W
12EB:  MOVWF  54
12EC:  MOVWF  55
12ED:  BCF    03.5
*
1AB6:  BSF    03.5
1AB7:  MOVF   51,W
1AB8:  ADDWF  52,W
1AB9:  MOVWF  04
1ABA:  MOVF   00,W
1ABB:  MOVWF  54
1ABC:  MOVWF  55
1ABD:  BCF    03.5
*
1BE6:  BSF    03.5
1BE7:  MOVF   51,W
1BE8:  ADDWF  52,W
1BE9:  MOVWF  04
1BEA:  MOVF   00,W
1BEB:  MOVWF  54
1BEC:  MOVWF  55
1BED:  BCF    03.5
*
1C96:  BSF    03.5
1C97:  MOVF   51,W
1C98:  ADDWF  52,W
1C99:  MOVWF  04
1C9A:  MOVF   00,W
1C9B:  MOVWF  54
1C9C:  MOVWF  55
1C9D:  BCF    03.5
*
1D52:  BSF    03.5
1D53:  MOVF   51,W
1D54:  ADDWF  52,W
1D55:  MOVWF  04
1D56:  MOVF   00,W
1D57:  MOVWF  54
1D58:  MOVWF  55
1D59:  BCF    03.5
*
1E10:  BSF    03.5
1E11:  MOVF   51,W
1E12:  ADDWF  52,W
1E13:  MOVWF  04
1E14:  MOVF   00,W
1E15:  MOVWF  54
1E16:  MOVWF  55
1E17:  BCF    03.5
....................       } 
....................  
....................       else 
*
0642:  GOTO   651
*
1226:  GOTO   235
*
12FB:  GOTO   30A
*
1ACD:  GOTO   2DC
*
1BFD:  GOTO   40C
*
1CAD:  GOTO   4BC
*
1D69:  GOTO   578
*
1E27:  GOTO   636
....................       { 
.................... 			  WriteOutData (msg_ptr [i]);  
*
0643:  BSF    03.5
0644:  MOVF   51,W
0645:  ADDWF  52,W
0646:  MOVWF  04
0647:  MOVF   00,W
0648:  MOVWF  54
0649:  MOVWF  5D
064A:  BCF    03.5
*
1227:  BSF    03.5
1228:  MOVF   51,W
1229:  ADDWF  52,W
122A:  MOVWF  04
122B:  MOVF   00,W
122C:  MOVWF  54
122D:  MOVWF  5D
122E:  BCF    03.5
*
12FC:  BSF    03.5
12FD:  MOVF   51,W
12FE:  ADDWF  52,W
12FF:  MOVWF  04
1300:  MOVF   00,W
1301:  MOVWF  54
1302:  MOVWF  5D
1303:  BCF    03.5
*
1ACE:  BSF    03.5
1ACF:  MOVF   51,W
1AD0:  ADDWF  52,W
1AD1:  MOVWF  04
1AD2:  MOVF   00,W
1AD3:  MOVWF  54
1AD4:  MOVWF  5D
1AD5:  BCF    03.5
*
1BFE:  BSF    03.5
1BFF:  MOVF   51,W
1C00:  ADDWF  52,W
1C01:  MOVWF  04
1C02:  MOVF   00,W
1C03:  MOVWF  54
1C04:  MOVWF  5D
1C05:  BCF    03.5
*
1CAE:  BSF    03.5
1CAF:  MOVF   51,W
1CB0:  ADDWF  52,W
1CB1:  MOVWF  04
1CB2:  MOVF   00,W
1CB3:  MOVWF  54
1CB4:  MOVWF  5D
1CB5:  BCF    03.5
*
1D6A:  BSF    03.5
1D6B:  MOVF   51,W
1D6C:  ADDWF  52,W
1D6D:  MOVWF  04
1D6E:  MOVF   00,W
1D6F:  MOVWF  54
1D70:  MOVWF  5D
1D71:  BCF    03.5
*
1E28:  BSF    03.5
1E29:  MOVF   51,W
1E2A:  ADDWF  52,W
1E2B:  MOVWF  04
1E2C:  MOVF   00,W
1E2D:  MOVWF  54
1E2E:  MOVWF  5D
1E2F:  BCF    03.5
....................       } 
.................... 		} 
*
0651:  BSF    03.5
0652:  INCF   52,F
0653:  BCF    03.5
0654:  GOTO   621
*
1235:  BSF    03.5
1236:  INCF   52,F
1237:  BCF    03.5
1238:  GOTO   203
*
130A:  BSF    03.5
130B:  INCF   52,F
130C:  BCF    03.5
130D:  GOTO   2D8
*
1ADC:  BSF    03.5
1ADD:  INCF   52,F
1ADE:  BCF    03.5
1ADF:  GOTO   2A8
*
1C0C:  BSF    03.5
1C0D:  INCF   52,F
1C0E:  BCF    03.5
1C0F:  GOTO   3D8
*
1CBC:  BSF    03.5
1CBD:  INCF   52,F
1CBE:  BCF    03.5
1CBF:  GOTO   488
*
1D78:  BSF    03.5
1D79:  INCF   52,F
1D7A:  BCF    03.5
1D7B:  GOTO   544
*
1E36:  BSF    03.5
1E37:  INCF   52,F
1E38:  BCF    03.5
1E39:  GOTO   602
....................  
.................... 	 
.................... } 
....................  
.................... #inline 
.................... short OutputHigResAna(int16 value, str_midiconfig &midi_msg) 
.................... { 
.................... 	int lsb, lsb_num; 
....................  
.................... 	if (midi_msg.config_flag & HIGH_RES_DUAL_CHAN) 
*
1B4A:  BSF    03.5
1B4B:  MOVF   46,W
1B4C:  ANDLW  20
1B4D:  XORLW  00
1B4E:  BTFSS  03.2
1B4F:  GOTO   352
1B50:  BCF    03.5
1B51:  GOTO   4C1
1B52:  BCF    03.5
.................... 	{ 
.................... 		 
.................... 		lsb = value & 0x07; // hold lower 3 bits 
1B53:  BSF    03.5
1B54:  MOVF   47,W
1B55:  ANDLW  07
1B56:  MOVWF  49
.................... 		 
.................... 		// no need to caluclate the MSB controller number as it is already in data_1 
.................... 		lsb_num = midi_msg.data_2; 
1B57:  MOVF   45,W
1B58:  MOVWF  4A
.................... 	 
.................... 		// first tx MSB 
.................... 		value >>= 3; 
1B59:  BCF    03.0
1B5A:  RRF    48,F
1B5B:  RRF    47,F
1B5C:  RRF    48,F
1B5D:  RRF    47,F
1B5E:  RRF    48,F
1B5F:  RRF    47,F
1B60:  MOVLW  1F
1B61:  ANDWF  48,F
.................... 		 
.................... 		midi_msg.data_2 = value & 0x7F; 
1B62:  MOVF   47,W
1B63:  ANDLW  7F
1B64:  MOVWF  45
....................  
.................... 		OutputMidi (&midi_msg); 
1B65:  MOVLW  C3
1B66:  MOVWF  4F
1B67:  BCF    03.5
....................  
.................... 		// now TX lsb 
.................... 		midi_msg.data_1 = lsb_num; 
*
1C10:  BSF    03.5
1C11:  MOVF   4A,W
1C12:  MOVWF  44
.................... 		midi_msg.data_2 = lsb; 
1C13:  MOVF   49,W
1C14:  MOVWF  45
.................... 		OutputMidi (&midi_msg); 
1C15:  MOVLW  C3
1C16:  MOVWF  4F
1C17:  BCF    03.5
.................... 	} 
....................  
.................... 	else 
*
1CC0:  GOTO   57C
.................... 	{ 
.................... 		midi_msg.data_1 = value & 0x07; // hold lower 3 bits 
1CC1:  BSF    03.5
1CC2:  MOVF   47,W
1CC3:  ANDLW  07
1CC4:  MOVWF  44
.................... 		value >>= 3; 
1CC5:  BCF    03.0
1CC6:  RRF    48,F
1CC7:  RRF    47,F
1CC8:  RRF    48,F
1CC9:  RRF    47,F
1CCA:  RRF    48,F
1CCB:  RRF    47,F
1CCC:  MOVLW  1F
1CCD:  ANDWF  48,F
.................... 	 
.................... 		midi_msg.data_2 = value & 0x7F; // data 2 holds MSB in 7 bit 
1CCE:  MOVF   47,W
1CCF:  ANDLW  7F
1CD0:  MOVWF  45
.................... 		OutputMidi (&midi_msg); 
1CD1:  MOVLW  C3
1CD2:  MOVWF  4F
1CD3:  BCF    03.5
.................... 	} 
....................  
.................... } 
....................  
.................... int16 CalculateScaledAnalogue(str_midiconfig &midi_msg, int16 value) 
.................... { 
.................... 	int32 out; 
.................... 	int16 range; 
.................... 	int16 min_value, max_value; 
.................... 	int int_val; 
....................  
.................... 	// we cannot do comparisons with non int 
....................  
.................... 	// first store the value 
.................... 	out = value / 8; 
*
1868:  BCF    03.0
1869:  BSF    03.5
186A:  RRF    48,W
186B:  MOVWF  4A
186C:  RRF    47,W
186D:  MOVWF  49
186E:  RRF    4A,F
186F:  RRF    49,F
1870:  RRF    4A,F
1871:  RRF    49,F
1872:  MOVLW  1F
1873:  ANDWF  4A,F
....................  
.................... 	int_val = (int)out; 
1874:  MOVF   49,W
1875:  MOVWF  53
....................  
.................... 	if (int_val >= (midi_msg.data_2 & 0x7F)) 
1876:  MOVF   44,W
1877:  ANDLW  7F
1878:  SUBWF  53,W
1879:  BTFSC  03.0
187A:  GOTO   07D
187B:  BCF    03.5
187C:  GOTO   083
187D:  BCF    03.5
.................... 	{ 
.................... 		return 127;  
187E:  MOVLW  7F
187F:  MOVWF  78
1880:  MOVLW  00
1881:  MOVWF  79
1882:  GOTO   126
.................... 	} 
....................  
.................... 	if ((midi_msg.config_flag & 0x7F) >= int_val) 
1883:  BSF    03.5
1884:  MOVF   45,W
1885:  ANDLW  7F
1886:  SUBWF  53,W
1887:  BTFSS  03.2
1888:  GOTO   08B
1889:  BCF    03.5
188A:  GOTO   090
188B:  BTFSS  03.0
188C:  GOTO   08F
188D:  BCF    03.5
188E:  GOTO   095
188F:  BCF    03.5
.................... 	{ 
.................... 		return 0;  
1890:  MOVLW  00
1891:  MOVWF  78
1892:  MOVLW  00
1893:  MOVWF  79
1894:  GOTO   126
.................... 	} 
....................  
.................... 	// move upper and Lower to 10 Bit 
.................... 	min_value = (midi_msg.config_flag & 0x7F); 
1895:  BSF    03.5
1896:  MOVF   45,W
1897:  ANDLW  7F
1898:  MOVWF  4F
1899:  CLRF   50
.................... 	min_value <<=3; 
189A:  BCF    03.0
189B:  RLF    4F,F
189C:  RLF    50,F
189D:  RLF    4F,F
189E:  RLF    50,F
189F:  RLF    4F,F
18A0:  RLF    50,F
18A1:  MOVLW  F8
18A2:  ANDWF  4F,F
....................  
.................... 	max_value = (midi_msg.data_2 & 0x7F); 
18A3:  MOVF   44,W
18A4:  ANDLW  7F
18A5:  MOVWF  51
18A6:  CLRF   52
.................... 	max_value <<= 3; 
18A7:  BCF    03.0
18A8:  RLF    51,F
18A9:  RLF    52,F
18AA:  RLF    51,F
18AB:  RLF    52,F
18AC:  RLF    51,F
18AD:  RLF    52,F
18AE:  MOVLW  F8
18AF:  ANDWF  51,F
....................  
....................  
.................... 	range = max_value - min_value; 
18B0:  MOVF   4F,W
18B1:  SUBWF  51,W
18B2:  MOVWF  4D
18B3:  MOVF   52,W
18B4:  MOVWF  4E
18B5:  MOVF   50,W
18B6:  BTFSS  03.0
18B7:  INCFSZ 50,W
18B8:  SUBWF  4E,F
....................  
.................... 	out = value - min_value; 
18B9:  MOVF   4F,W
18BA:  SUBWF  47,W
18BB:  MOVWF  49
18BC:  MOVF   48,W
18BD:  MOVWF  4A
18BE:  MOVF   50,W
18BF:  BTFSS  03.0
18C0:  INCFSZ 50,W
18C1:  SUBWF  4A,F
18C2:  CLRF   4B
18C3:  CLRF   4C
.................... 	out *= 127; 
18C4:  MOVF   4C,W
18C5:  MOVWF  5B
18C6:  MOVF   4B,W
18C7:  MOVWF  5A
18C8:  MOVF   4A,W
18C9:  MOVWF  59
18CA:  MOVF   49,W
18CB:  MOVWF  58
18CC:  CLRF   5F
18CD:  CLRF   5E
18CE:  CLRF   5D
18CF:  MOVLW  7F
18D0:  MOVWF  5C
18D1:  BCF    03.5
18D2:  BCF    0A.4
18D3:  BCF    0A.3
18D4:  GOTO   707
18D5:  BSF    0A.4
18D6:  BSF    0A.3
18D7:  MOVF   7A,W
18D8:  BSF    03.5
18D9:  MOVWF  4C
18DA:  MOVF   79,W
18DB:  MOVWF  4B
18DC:  MOVF   78,W
18DD:  MOVWF  4A
18DE:  MOVF   77,W
18DF:  MOVWF  49
.................... 	out /= range; 
18E0:  MOVF   4C,W
18E1:  MOVWF  5B
18E2:  MOVF   4B,W
18E3:  MOVWF  5A
18E4:  MOVF   4A,W
18E5:  MOVWF  59
18E6:  MOVF   49,W
18E7:  MOVWF  58
18E8:  CLRF   5F
18E9:  CLRF   5E
18EA:  MOVF   4E,W
18EB:  MOVWF  5D
18EC:  MOVF   4D,W
18ED:  MOVWF  5C
18EE:  BCF    03.5
18EF:  BCF    0A.4
18F0:  BCF    0A.3
18F1:  GOTO   73C
18F2:  BSF    0A.4
18F3:  BSF    0A.3
18F4:  MOVF   7A,W
18F5:  BSF    03.5
18F6:  MOVWF  4C
18F7:  MOVF   79,W
18F8:  MOVWF  4B
18F9:  MOVF   78,W
18FA:  MOVWF  4A
18FB:  MOVF   77,W
18FC:  MOVWF  49
....................  
.................... 	if (out > 127) 
18FD:  MOVF   4C,F
18FE:  BTFSC  03.2
18FF:  GOTO   102
1900:  BCF    03.5
1901:  GOTO   119
1902:  BCF    03.5
1903:  BSF    03.5
1904:  MOVF   4B,F
1905:  BTFSC  03.2
1906:  GOTO   109
1907:  BCF    03.5
1908:  GOTO   119
1909:  BCF    03.5
190A:  BSF    03.5
190B:  MOVF   4A,F
190C:  BTFSC  03.2
190D:  GOTO   110
190E:  BCF    03.5
190F:  GOTO   119
1910:  BCF    03.5
1911:  BSF    03.5
1912:  MOVF   49,W
1913:  SUBLW  7F
1914:  BTFSS  03.0
1915:  GOTO   118
1916:  BCF    03.5
1917:  GOTO   120
1918:  BCF    03.5
.................... 	{ 
.................... 		out = 127; 
1919:  BSF    03.5
191A:  CLRF   4C
191B:  CLRF   4B
191C:  CLRF   4A
191D:  MOVLW  7F
191E:  MOVWF  49
191F:  BCF    03.5
.................... 	} 
....................  
.................... 	return out; 
1920:  BSF    03.5
1921:  MOVF   49,W
1922:  MOVWF  78
1923:  MOVF   4A,W
1924:  MOVWF  79
1925:  BCF    03.5
....................  
.................... } 
....................  
.................... int16 ScaleAnalogValue (int channel, int16 value) 
.................... { 
.................... 	str_midiconfig midi_msg; 
....................  
.................... 	int i; 
....................  
.................... 	ReadAnalogueInConfig (&midi_msg, channel); 
*
1848:  MOVLW  C2
1849:  BSF    03.5
184A:  MOVWF  4C
184B:  MOVF   3F,W
184C:  MOVWF  4D
184D:  BCF    03.5
.................... 	if (midi_msg.config_flag & VALUE_SCALING_FLAG) 
*
1859:  BSF    03.5
185A:  MOVF   45,W
185B:  ANDLW  80
185C:  XORLW  00
185D:  BTFSS  03.2
185E:  GOTO   061
185F:  BCF    03.5
1860:  GOTO   129
1861:  BCF    03.5
.................... 		return CalculateScaledAnalogue (midi_msg, value); 
1862:  BSF    03.5
1863:  MOVF   41,W
1864:  MOVWF  48
1865:  MOVF   40,W
1866:  MOVWF  47
1867:  BCF    03.5
*
1926:  MOVF   79,W
1927:  GOTO   16D
.................... 	else 
1928:  GOTO   167
.................... 		if (midi_msg.config_flag & HIGH_RES_DUAL_CHAN) 
1929:  BSF    03.5
192A:  MOVF   45,W
192B:  ANDLW  20
192C:  XORLW  00
192D:  BTFSS  03.2
192E:  GOTO   131
192F:  BCF    03.5
1930:  GOTO   13A
1931:  BCF    03.5
.................... 		{  
.................... 			return value; 
1932:  BSF    03.5
1933:  MOVF   40,W
1934:  MOVWF  78
1935:  MOVF   41,W
1936:  MOVWF  79
1937:  BCF    03.5
1938:  GOTO   16D
.................... 		} 
.................... 		else 
1939:  GOTO   167
.................... 		{ 
.................... 			i = ReadAnaResolution(); 
193A:  BCF    0A.4
193B:  BCF    0A.3
193C:  CALL   795
193D:  BSF    0A.4
193E:  BSF    0A.3
193F:  MOVF   78,W
1940:  BSF    03.5
1941:  MOVWF  46
1942:  BCF    03.5
.................... 			while (i) 
1943:  BSF    03.5
1944:  MOVF   46,F
1945:  BTFSS  03.2
1946:  GOTO   149
1947:  BCF    03.5
1948:  GOTO   167
1949:  BCF    03.5
.................... 			{ 
.................... 				i--; 
194A:  BSF    03.5
194B:  DECF   46,F
.................... 				bit_clear (value, i); 
194C:  CLRF   7A
194D:  MOVLW  01
194E:  MOVWF  79
194F:  MOVF   46,W
1950:  MOVWF  77
1951:  BTFSS  03.2
1952:  GOTO   155
1953:  BCF    03.5
1954:  GOTO   15B
1955:  BCF    03.5
1956:  BCF    03.0
1957:  RLF    79,F
1958:  RLF    7A,F
1959:  DECFSZ 77,F
195A:  GOTO   156
195B:  MOVF   79,W
195C:  XORLW  FF
195D:  MOVWF  77
195E:  MOVLW  FF
195F:  XORWF  7A,F
1960:  MOVF   77,W
1961:  BSF    03.5
1962:  ANDWF  40,F
1963:  MOVF   7A,W
1964:  ANDWF  41,F
.................... 			} 
1965:  BCF    03.5
1966:  GOTO   143
.................... 		} 
....................  
.................... 	return value; 
1967:  BSF    03.5
1968:  MOVF   40,W
1969:  MOVWF  78
196A:  MOVF   41,W
196B:  MOVWF  79
196C:  BCF    03.5
....................  
.................... } 
....................  
....................  
.................... short OutputScaledAnalog (str_midiconfig &midi_msg, int value) 
.................... { 
.................... 	 
.................... 		int num_bytes; 
....................  
.................... 		num_bytes = NumTxBytes (&midi_msg); 
*
1A0D:  MOVLW  C3
1A0E:  BSF    03.5
1A0F:  MOVWF  58
1A10:  BCF    03.5
1A11:  BCF    0A.4
1A12:  BCF    0A.3
1A13:  CALL   170
1A14:  BSF    0A.4
1A15:  BSF    0A.3
1A16:  MOVF   78,W
1A17:  BSF    03.5
1A18:  MOVWF  48
.................... 		 
.................... 		switch (num_bytes) 
1A19:  MOVWF  77
1A1A:  MOVLW  03
1A1B:  SUBWF  77,W
1A1C:  BTFSS  03.2
1A1D:  GOTO   220
1A1E:  BCF    03.5
1A1F:  GOTO   228
1A20:  MOVLW  02
1A21:  SUBWF  77,W
1A22:  BTFSS  03.2
1A23:  GOTO   226
1A24:  BCF    03.5
1A25:  GOTO   22E
1A26:  BCF    03.5
1A27:  GOTO   234
.................... 			{ 
.................... 			case 3: 
.................... 				midi_msg.data_2 = value & 0x7F; 
1A28:  BSF    03.5
1A29:  MOVF   47,W
1A2A:  ANDLW  7F
1A2B:  MOVWF  45
.................... 				break; 
1A2C:  BCF    03.5
1A2D:  GOTO   234
.................... 				 
.................... 			case 2: 
....................  
.................... 					midi_msg.data_1 = value & 0x7F; 
1A2E:  BSF    03.5
1A2F:  MOVF   47,W
1A30:  ANDLW  7F
1A31:  MOVWF  44
.................... 				break; 
1A32:  BCF    03.5
1A33:  GOTO   234
.................... 				 
.................... 			default: 
.................... 			} 
.................... 		 
.................... 		OutputMidi (&midi_msg); 
1A34:  MOVLW  C3
1A35:  BSF    03.5
1A36:  MOVWF  4F
1A37:  BCF    03.5
....................  
.................... } 
....................  
.................... #inline 
.................... short OutputAnalog (int channel, int16 value) 
.................... { 
....................   int num_bytes; 
....................    
.................... 	str_midiconfig midi_msg; 
....................  
.................... 	ReadAnalogueInConfig (&midi_msg, channel); 
*
19EF:  MOVLW  C3
19F0:  BSF    03.5
19F1:  MOVWF  4C
19F2:  MOVF   3F,W
19F3:  MOVWF  4D
19F4:  BCF    03.5
....................  
.................... 	if (midi_msg.config_flag & VALUE_SCALING_FLAG) 
*
1A00:  BSF    03.5
1A01:  MOVF   46,W
1A02:  ANDLW  80
1A03:  XORLW  00
1A04:  BTFSS  03.2
1A05:  GOTO   208
1A06:  BCF    03.5
1A07:  GOTO   2E2
1A08:  BCF    03.5
.................... 	{ 
.................... 		return OutputScaledAnalog (midi_msg, (int)value); 
1A09:  BSF    03.5
1A0A:  MOVF   40,W
1A0B:  MOVWF  47
1A0C:  BCF    03.5
*
1AE0:  MOVF   78,W
1AE1:  GOTO   63C
.................... 	} 
....................  
....................   if (!(MUTE_CONFIG_MASK  & midi_msg.config_flag)) 
1AE2:  BSF    03.5
1AE3:  MOVF   46,W
1AE4:  ANDLW  04
1AE5:  XORLW  00
1AE6:  BTFSC  03.2
1AE7:  GOTO   2EA
1AE8:  BCF    03.5
1AE9:  GOTO   63A
1AEA:  BCF    03.5
....................     { 
.................... 		if (INVERT_VALUE_MASK & midi_msg.config_flag) 
1AEB:  BSF    03.5
1AEC:  MOVF   46,W
1AED:  ANDLW  02
1AEE:  XORLW  00
1AEF:  BTFSS  03.2
1AF0:  GOTO   2F3
1AF1:  BCF    03.5
1AF2:  GOTO   2FA
1AF3:  BCF    03.5
.................... 			{ 
.................... 				value ^= 0xFFFF; // flip all 
1AF4:  MOVLW  FF
1AF5:  BSF    03.5
1AF6:  XORWF  40,F
1AF7:  MOVLW  FF
1AF8:  XORWF  41,F
1AF9:  BCF    03.5
.................... 			} 
.................... 		 
.................... 		num_bytes = NumTxBytes (&midi_msg); 
1AFA:  MOVLW  C3
1AFB:  BSF    03.5
1AFC:  MOVWF  58
1AFD:  BCF    03.5
1AFE:  BCF    0A.4
1AFF:  BCF    0A.3
1B00:  CALL   170
1B01:  BSF    0A.4
1B02:  BSF    0A.3
1B03:  MOVF   78,W
1B04:  BSF    03.5
1B05:  MOVWF  42
.................... 		 
.................... 		switch (num_bytes) 
1B06:  MOVWF  77
1B07:  MOVLW  03
1B08:  SUBWF  77,W
1B09:  BTFSS  03.2
1B0A:  GOTO   30D
1B0B:  BCF    03.5
1B0C:  GOTO   315
1B0D:  MOVLW  02
1B0E:  SUBWF  77,W
1B0F:  BTFSS  03.2
1B10:  GOTO   313
1B11:  BCF    03.5
1B12:  GOTO   57F
1B13:  BCF    03.5
1B14:  GOTO   58E
.................... 			{ 
.................... 			case 3: 
.................... 				if (ReadAnaResolution()) 
1B15:  BCF    0A.4
1B16:  BCF    0A.3
1B17:  CALL   795
1B18:  BSF    0A.4
1B19:  BSF    0A.3
1B1A:  MOVF   78,F
1B1B:  BTFSC  03.2
1B1C:  GOTO   344
.................... 				{ 
.................... 					if (DATA_1_VARY_MASK & midi_msg.config_flag) 
1B1D:  BSF    03.5
1B1E:  MOVF   46,W
1B1F:  ANDLW  01
1B20:  XORLW  00
1B21:  BTFSS  03.2
1B22:  GOTO   325
1B23:  BCF    03.5
1B24:  GOTO   335
1B25:  BCF    03.5
.................... 					{ 
.................... 						value >>= 3; // make 7 bit 
1B26:  BCF    03.0
1B27:  BSF    03.5
1B28:  RRF    41,F
1B29:  RRF    40,F
1B2A:  RRF    41,F
1B2B:  RRF    40,F
1B2C:  RRF    41,F
1B2D:  RRF    40,F
1B2E:  MOVLW  1F
1B2F:  ANDWF  41,F
.................... 						midi_msg.data_1 = value & 0x7F; 
1B30:  MOVF   40,W
1B31:  ANDLW  7F
1B32:  MOVWF  44
.................... 					} 
.................... 					else 
1B33:  BCF    03.5
1B34:  GOTO   343
.................... 					{ 
.................... 						value >>= 3; // make 7 bit 
1B35:  BCF    03.0
1B36:  BSF    03.5
1B37:  RRF    41,F
1B38:  RRF    40,F
1B39:  RRF    41,F
1B3A:  RRF    40,F
1B3B:  RRF    41,F
1B3C:  RRF    40,F
1B3D:  MOVLW  1F
1B3E:  ANDWF  41,F
.................... 						midi_msg.data_2 = value & 0x7F; 
1B3F:  MOVF   40,W
1B40:  ANDLW  7F
1B41:  MOVWF  45
1B42:  BCF    03.5
.................... 					} 
.................... 				} 
.................... 				else 
1B43:  GOTO   57E
.................... 				{ 
.................... 					return OutputHigResAna (value, midi_msg); 
1B44:  BSF    03.5
1B45:  MOVF   41,W
1B46:  MOVWF  48
1B47:  MOVF   40,W
1B48:  MOVWF  47
1B49:  BCF    03.5
*
1D7C:  MOVF   78,W
1D7D:  GOTO   63C
.................... 				} 
....................  
.................... 				break; 
1D7E:  GOTO   58E
.................... 				 
.................... 			case 2: 
.................... 					value >>= 3; // make 7 bit 
1D7F:  BCF    03.0
1D80:  BSF    03.5
1D81:  RRF    41,F
1D82:  RRF    40,F
1D83:  RRF    41,F
1D84:  RRF    40,F
1D85:  RRF    41,F
1D86:  RRF    40,F
1D87:  MOVLW  1F
1D88:  ANDWF  41,F
.................... 					midi_msg.data_1 = value & 0x7F; 
1D89:  MOVF   40,W
1D8A:  ANDLW  7F
1D8B:  MOVWF  44
.................... 				break; 
1D8C:  BCF    03.5
1D8D:  GOTO   58E
.................... 				 
.................... 			default: 
.................... 			} 
.................... 		 
.................... 		OutputMidi (&midi_msg); 
1D8E:  MOVLW  C3
1D8F:  BSF    03.5
1D90:  MOVWF  4F
1D91:  BCF    03.5
.................... 		} 
....................   return true; 
*
1E3A:  MOVLW  01
1E3B:  MOVWF  78
.................... } 
....................  
.................... #inline 
.................... short OutputDigital (int channel, int value) 
.................... { 
....................   int num_bytes; 
.................... 	str_midiconfig midi_msg; 
....................  
.................... 	ReadDigitalInConfig (&midi_msg, channel); 
*
055B:  MOVLW  C5
055C:  BSF    03.5
055D:  MOVWF  49
055E:  MOVF   42,W
055F:  MOVWF  4A
0560:  BCF    03.5
....................  
....................   if (!(MUTE_CONFIG_MASK  & midi_msg.config_flag)) 
*
056B:  BSF    03.5
056C:  MOVF   48,W
056D:  ANDLW  04
056E:  XORLW  00
056F:  BTFSC  03.2
0570:  GOTO   573
0571:  BCF    03.5
0572:  GOTO   655
0573:  BCF    03.5
....................     { 
....................     num_bytes = NumTxBytes (&midi_msg); 
0574:  MOVLW  C5
0575:  BSF    03.5
0576:  MOVWF  58
0577:  BCF    03.5
0578:  CALL   170
0579:  MOVF   78,W
057A:  BSF    03.5
057B:  MOVWF  44
....................  
.................... 		if (INVERT_VALUE_MASK & midi_msg.config_flag) 
057C:  MOVF   48,W
057D:  ANDLW  02
057E:  XORLW  00
057F:  BTFSS  03.2
0580:  GOTO   583
0581:  BCF    03.5
0582:  GOTO   588
0583:  BCF    03.5
.................... 			{ 
.................... 				value ^= 0x7f; // flip all but msb 
0584:  MOVLW  7F
0585:  BSF    03.5
0586:  XORWF  43,F
0587:  BCF    03.5
.................... 			} 
.................... 		 
.................... 		switch (num_bytes) 
0588:  BSF    03.5
0589:  MOVF   44,W
058A:  MOVWF  77
058B:  MOVLW  03
058C:  SUBWF  77,W
058D:  BTFSS  03.2
058E:  GOTO   591
058F:  BCF    03.5
0590:  GOTO   599
0591:  MOVLW  02
0592:  SUBWF  77,W
0593:  BTFSS  03.2
0594:  GOTO   597
0595:  BCF    03.5
0596:  GOTO   5AC
0597:  BCF    03.5
0598:  GOTO   5B1
.................... 			{ 
.................... 			case 3: 
.................... 				if (DATA_1_VARY_MASK & midi_msg.config_flag) 
0599:  BSF    03.5
059A:  MOVF   48,W
059B:  ANDLW  01
059C:  XORLW  00
059D:  BTFSS  03.2
059E:  GOTO   5A1
059F:  BCF    03.5
05A0:  GOTO   5A7
05A1:  BCF    03.5
.................... 					{ 
.................... 						midi_msg.data_1 = value; 
05A2:  BSF    03.5
05A3:  MOVF   43,W
05A4:  MOVWF  46
.................... 					} 
.................... 				else 
05A5:  BCF    03.5
05A6:  GOTO   5AB
.................... 					{ 
.................... 						midi_msg.data_2 = value; 
05A7:  BSF    03.5
05A8:  MOVF   43,W
05A9:  MOVWF  47
05AA:  BCF    03.5
.................... 					} 
.................... 				 
.................... 				break; 
05AB:  GOTO   5B1
.................... 				 
.................... 			case 2: 
.................... 				midi_msg.data_1 = value; 
05AC:  BSF    03.5
05AD:  MOVF   43,W
05AE:  MOVWF  46
.................... 				break; 
05AF:  BCF    03.5
05B0:  GOTO   5B1
.................... 				 
.................... 			default: 
.................... 			} 
.................... 		 
.................... 		 
.................... 		OutputMidi (&midi_msg); 
05B1:  MOVLW  C5
05B2:  BSF    03.5
05B3:  MOVWF  4F
05B4:  BCF    03.5
.................... 		} 
....................   return true; 
*
0655:  MOVLW  01
0656:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... 
.................... #include "spi_read.h" 
....................  /******************************************************************************* 
.................... *	Author: Angelo Fraietta 
.................... *	Description: General SPI Read function 
.................... *	Processor N/A 
.................... * Inputs:  
.................... *    data_size: size of the data structure receiving the data 
.................... *    data_pin: the I/O pin that receives the data*      
.................... * Outputs: 
.................... *           ret_data: pointer to structure to receive data  
.................... * 
.................... * Global 
.................... *    SPI_IN_LATCH: the I/O pin that latches input registers 
.................... *    SPI_CLOCK: the I/O pin that clocks the device shift registers 
....................  
....................  
.................... *	Description: 
.................... *  
.................... *		The registers are latched.  
.................... *   [iterate] 
.................... *   The state of the Input is read and shifted left 
.................... *   When 8 bits are read and shifted, the value is stored into ret_data 
....................  
....................  
.................... * Notes: asuumes the I/O pins are configured if not using standard I/O 
.................... * Assumes a Low latch and a Low to High clock 
.................... *******************************************************************************/ 
.................... #inline 
.................... void Spi_read_data (int* ret_data,  
.................... 											int data_size,  
.................... 											int data_pin) 
.................... { 
.................... 	int byte_num; 
.................... 	int bit_num; 
.................... 	byte in_val; 
.................... 	short data_val; 
....................  
.................... 	// prepare clock 
.................... 	output_low (SPI_CLOCK); 
*
0456:  BCF    54.3
0457:  MOVF   54,W
0458:  BSF    03.5
0459:  MOVWF  07
045A:  BCF    03.5
045B:  BCF    07.3
....................  
....................   // latch the data 
....................   switch (data_pin) 
045C:  BSF    03.5
045D:  MOVF   3D,W
045E:  MOVWF  77
045F:  MOVLW  3C
0460:  SUBWF  77,W
0461:  BTFSS  03.2
0462:  GOTO   465
0463:  BCF    03.5
0464:  GOTO   467
0465:  BCF    03.5
0466:  GOTO   474
....................   { 
....................     case DIGITAL_IN_DATA: 
.................... 	 
.................... 	    output_low (SPI_IN_LATCH); 
0467:  BCF    54.2
0468:  MOVF   54,W
0469:  BSF    03.5
046A:  MOVWF  07
046B:  BCF    03.5
046C:  BCF    07.2
.................... 	    output_high (SPI_IN_LATCH); 
046D:  BCF    54.2
046E:  MOVF   54,W
046F:  BSF    03.5
0470:  MOVWF  07
0471:  BCF    03.5
0472:  BSF    07.2
....................       break; 
0473:  GOTO   475
....................  
....................     default: 
....................       break; 
0474:  GOTO   475
....................   } 
....................  
.................... 	 
.................... 	for (byte_num = 0; byte_num < data_size; byte_num++) 
0475:  BSF    03.5
0476:  CLRF   3E
0477:  BCF    03.5
0478:  BSF    03.5
0479:  MOVF   3C,W
047A:  SUBWF  3E,W
047B:  BTFSS  03.0
047C:  GOTO   47F
047D:  BCF    03.5
047E:  GOTO   4CC
047F:  BCF    03.5
.................... 		{ 
.................... 			in_val = 0; 
0480:  BSF    03.5
0481:  CLRF   40
....................  
.................... 			for (bit_num = 0; bit_num < 8; bit_num++) 
0482:  CLRF   3F
0483:  BCF    03.5
0484:  BSF    03.5
0485:  MOVF   3F,W
0486:  SUBLW  07
0487:  BTFSC  03.0
0488:  GOTO   48B
0489:  BCF    03.5
048A:  GOTO   4C1
048B:  BCF    03.5
.................... 				{ 
.................... 					in_val <<= 1; // first shift is a dummy. Only seven are really shifted 
048C:  BCF    03.0
048D:  BSF    03.5
048E:  RLF    40,F
....................  
.................... 					// read the input 
.................... 					switch (data_pin) 
048F:  MOVF   3D,W
0490:  MOVWF  77
0491:  MOVLW  3C
0492:  SUBWF  77,W
0493:  BTFSS  03.2
0494:  GOTO   497
0495:  BCF    03.5
0496:  GOTO   499
0497:  BCF    03.5
0498:  GOTO   4A8
.................... 						{ 
.................... 							case DIGITAL_IN_DATA: 
.................... 								data_val = input (DIGITAL_IN_DATA); 
0499:  BSF    54.4
049A:  MOVF   54,W
049B:  BSF    03.5
049C:  MOVWF  07
049D:  BCF    03.5
049E:  BTFSC  07.4
049F:  GOTO   4A4
04A0:  BSF    03.5
04A1:  BCF    41.0
04A2:  BCF    03.5
04A3:  GOTO   4A7
04A4:  BSF    03.5
04A5:  BSF    41.0
04A6:  BCF    03.5
.................... 								break; 
04A7:  GOTO   4A8
....................                
.................... 						} 
....................  
.................... 					if (data_val) 
04A8:  BSF    03.5
04A9:  BTFSC  41.0
04AA:  GOTO   4AD
04AB:  BCF    03.5
04AC:  GOTO   4B1
04AD:  BCF    03.5
.................... 						{ 
.................... 							in_val |= 0x0001; 
04AE:  BSF    03.5
04AF:  BSF    40.0
04B0:  BCF    03.5
.................... 						} 
....................  
.................... 					// now clock register 
.................... 					output_high (SPI_CLOCK); 
04B1:  BCF    54.3
04B2:  MOVF   54,W
04B3:  BSF    03.5
04B4:  MOVWF  07
04B5:  BCF    03.5
04B6:  BSF    07.3
.................... 					output_low (SPI_CLOCK); 
04B7:  BCF    54.3
04B8:  MOVF   54,W
04B9:  BSF    03.5
04BA:  MOVWF  07
04BB:  BCF    03.5
04BC:  BCF    07.3
.................... 				} 
04BD:  BSF    03.5
04BE:  INCF   3F,F
04BF:  BCF    03.5
04C0:  GOTO   484
....................  
.................... 			// now store that byte in ret_data 
.................... 			ret_data [byte_num] = in_val; 
04C1:  BSF    03.5
04C2:  MOVF   3B,W
04C3:  ADDWF  3E,W
04C4:  MOVWF  04
04C5:  MOVF   40,W
04C6:  MOVWF  00
04C7:  BCF    03.5
.................... 		} 
04C8:  BSF    03.5
04C9:  INCF   3E,F
04CA:  BCF    03.5
04CB:  GOTO   478
.................... } 
....................  
....................  
.................... /******************************************************************************* 
.................... *	Author: Angelo Fraietta 
.................... *	Description: General SPI Write function 
.................... *	Processor N/A 
.................... * Inputs:  
.................... *    out_data: structure containing the data to be written 
.................... *    data_size: size of the data structure receiving the data 
.................... *    latch_pin: the I/O pin that receives the data*      
.................... * Outputs: 
.................... *           Data written to the outputs after being latched 
.................... * 
.................... * Global 
.................... *    SPI_CLOCK: the I/O pin that clocks the device shift registers 
.................... *    SPI_DATA_OUT: the data I/O pin that receives the output data 
....................  
.................... *	Description: 
.................... *  
.................... *		The registers are latched.  
.................... *   [iterate] 
.................... *   The state of the Output is written and shifted left 
.................... *   When 8 bits are read and shifted, the value is stored into ret_data 
....................  
....................  
.................... * Notes: asuumes the I/O pins are configured if not using standard I/O 
.................... * Assumes a Low latch and a Low to High clock 
.................... *******************************************************************************/ 
.................... #inline 
.................... void Spi_write_data (int* out_data,  
.................... 											int data_size,  
.................... 											int latch_pin) 
.................... { 
.................... 	int byte_num; 
.................... 	int bit_num; 
.................... 	byte out_val; 
.................... 	short data_val; 
....................    
.................... 	// prepare clock 
.................... 	output_low (SPI_CLOCK); 
*
03C4:  BCF    54.3
03C5:  MOVF   54,W
03C6:  BSF    03.5
03C7:  MOVWF  07
03C8:  BCF    03.5
03C9:  BCF    07.3
....................  
.................... 	for (byte_num = 0; byte_num < data_size; byte_num++) 
03CA:  BSF    03.5
03CB:  CLRF   65
03CC:  BCF    03.5
03CD:  BSF    03.5
03CE:  MOVF   63,W
03CF:  SUBWF  65,W
03D0:  BTFSS  03.0
03D1:  GOTO   3D4
03D2:  BCF    03.5
03D3:  GOTO   40A
03D4:  BCF    03.5
.................... 		{ 
.................... 			out_val = out_data [byte_num]; 
03D5:  BSF    03.5
03D6:  MOVF   62,W
03D7:  ADDWF  65,W
03D8:  MOVWF  04
03D9:  MOVF   00,W
03DA:  MOVWF  67
....................   
....................  
.................... 			for (bit_num = 0; bit_num < 8; bit_num++) 
03DB:  CLRF   66
03DC:  BCF    03.5
03DD:  BSF    03.5
03DE:  MOVF   66,W
03DF:  SUBLW  07
03E0:  BTFSC  03.0
03E1:  GOTO   3E4
03E2:  BCF    03.5
03E3:  GOTO   406
03E4:  BCF    03.5
.................... 				{ 
.................... 					// write the high bit 
....................           output_bit (SPI_DATA_OUT, out_val & 0x80); 
03E5:  BSF    03.5
03E6:  MOVF   67,W
03E7:  ANDLW  80
03E8:  XORLW  00
03E9:  BTFSC  03.2
03EA:  GOTO   3ED
03EB:  BCF    03.5
03EC:  GOTO   3F0
03ED:  BCF    03.5
03EE:  BCF    08.1
03EF:  GOTO   3F1
03F0:  BSF    08.1
03F1:  BSF    03.5
03F2:  BCF    08.1
....................           out_val<<=1; 
03F3:  BCF    03.0
03F4:  RLF    67,F
....................  
.................... 					// now clock register 
.................... 					output_high (SPI_CLOCK); 
03F5:  BCF    03.5
03F6:  BCF    54.3
03F7:  MOVF   54,W
03F8:  BSF    03.5
03F9:  MOVWF  07
03FA:  BCF    03.5
03FB:  BSF    07.3
.................... 					output_low (SPI_CLOCK); 
03FC:  BCF    54.3
03FD:  MOVF   54,W
03FE:  BSF    03.5
03FF:  MOVWF  07
0400:  BCF    03.5
0401:  BCF    07.3
.................... 				} 
0402:  BSF    03.5
0403:  INCF   66,F
0404:  BCF    03.5
0405:  GOTO   3DD
....................  
....................  
.................... 		} 
0406:  BSF    03.5
0407:  INCF   65,F
0408:  BCF    03.5
0409:  GOTO   3CD
....................  
.................... 	// latch the data 
....................   switch (latch_pin) 
040A:  BSF    03.5
040B:  MOVF   64,W
040C:  MOVWF  77
040D:  MOVLW  42
040E:  SUBWF  77,W
040F:  BTFSS  03.2
0410:  GOTO   413
0411:  BCF    03.5
0412:  GOTO   415
0413:  BCF    03.5
0414:  GOTO   41E
....................   { 
....................     case DIGITAL_OUT_LATCH: 
.................... 	    output_low (DIGITAL_OUT_LATCH); 
0415:  BSF    03.5
0416:  BCF    08.2
0417:  BCF    03.5
0418:  BCF    08.2
.................... 	    output_high (DIGITAL_OUT_LATCH); 
0419:  BSF    03.5
041A:  BCF    08.2
041B:  BCF    03.5
041C:  BSF    08.2
....................       break; 
041D:  GOTO   41E
....................  
....................   } 
.................... } 
....................  
....................  
....................  
.................... 
.................... #include "watchdog.h" 
....................   
.................... #define NUM_WD_FLASHES	8 
....................  
.................... //#ifndef WATCHDOG_PIN 
.................... #define WATCHDOG_PIN	PIN_C0 
.................... //#endif 
....................  
.................... void FlashWatchdog(int16 ms_time) 
.................... { 
.................... 		output_high (WATCHDOG_PIN); 
*
1113:  BCF    54.0
1114:  MOVF   54,W
1115:  BSF    03.5
1116:  MOVWF  07
1117:  BCF    03.5
1118:  BSF    07.0
.................... 		restart_wdt(); 
1119:  CLRWDT
.................... #ifndef _SIMULATE 
.................... 		delay_ms (ms_time); 
111A:  BSF    03.5
111B:  MOVF   36,W
111C:  MOVWF  38
111D:  BCF    03.5
111E:  BCF    0A.4
111F:  CALL   0FD
1120:  BSF    0A.4
.................... #endif 
.................... 		restart_wdt(); 
1121:  CLRWDT
.................... 		output_low (WATCHDOG_PIN); 
1122:  BCF    54.0
1123:  MOVF   54,W
1124:  BSF    03.5
1125:  MOVWF  07
1126:  BCF    03.5
1127:  BCF    07.0
.................... #ifndef _SIMULATE 
.................... 		delay_ms (ms_time); 
1128:  BSF    03.5
1129:  MOVF   36,W
112A:  MOVWF  38
112B:  BCF    03.5
112C:  BCF    0A.4
112D:  CALL   0FD
112E:  BSF    0A.4
.................... #endif 
.................... 		restart_wdt(); 
112F:  CLRWDT
.................... } 
....................  
.................... void SetWatchdogLed (short value) 
.................... { 
.................... 	output_bit (WATCHDOG_PIN, value); 
*
0FAB:  BSF    03.5
0FAC:  MOVF   36,F
0FAD:  BTFSC  03.2
0FAE:  GOTO   7B1
0FAF:  BCF    03.5
0FB0:  GOTO   7B4
0FB1:  BCF    03.5
0FB2:  BCF    07.0
0FB3:  GOTO   7B5
0FB4:  BSF    07.0
0FB5:  BCF    54.0
0FB6:  MOVF   54,W
0FB7:  BSF    03.5
0FB8:  MOVWF  07
0FB9:  BCF    03.5
.................... } 
....................  
.................... void InitialiseWatchdog() 
.................... { 
.................... 	int i; 
.................... 	for (i = 0; i < NUM_WD_FLASHES; i++) 
*
1103:  BSF    03.5
1104:  CLRF   35
1105:  BCF    03.5
1106:  BSF    03.5
1107:  MOVF   35,W
1108:  SUBLW  07
1109:  BTFSC  03.0
110A:  GOTO   10D
110B:  BCF    03.5
110C:  GOTO   135
110D:  BCF    03.5
.................... 		{ 
.................... 			FlashWatchdog(100); 
110E:  BSF    03.5
110F:  CLRF   37
1110:  MOVLW  64
1111:  MOVWF  36
1112:  BCF    03.5
.................... 			restart_wdt(); 
*
1130:  CLRWDT
.................... 		} 
1131:  BSF    03.5
1132:  INCF   35,F
1133:  BCF    03.5
1134:  GOTO   106
.................... } 
....................  
.................... 
.................... #include "decmidi.h" 
....................  /********************************************************************** 
....................  * decodes midi message and produces an output if we are configured to 
....................  * 
....................  *dependant uponf midicfg.h,   
....................  *********************************************************************/ 
....................  
.................... void GenerateAnalogueOutput (int out_num, byte val); 
.................... void GenerateDigitalOutput (int out_num, byte val); 
....................  
.................... int ana_values [NUM_ANALOGUE_OUT]; 
....................  
.................... #inline 
.................... short MatchingConfig (str_midiconfig* test, str_midiconfig* reference) 
.................... { 
....................   short ret; 
....................   byte match_only_status; 
....................  
....................   ret = (test->status_chan == reference->status_chan); 
*
0D1B:  BSF    03.5
0D1C:  MOVF   5F,W
0D1D:  MOVWF  04
0D1E:  MOVF   00,W
0D1F:  MOVWF  64
0D20:  MOVF   60,W
0D21:  MOVWF  04
0D22:  MOVF   00,W
0D23:  SUBWF  64,W
0D24:  BTFSS  03.2
0D25:  GOTO   528
0D26:  BCF    03.5
0D27:  GOTO   52D
0D28:  BCF    03.5
0D29:  BSF    03.5
0D2A:  BCF    61.0
0D2B:  BCF    03.5
0D2C:  GOTO   530
0D2D:  BSF    03.5
0D2E:  BSF    61.0
0D2F:  BCF    03.5
*
0E9E:  BSF    03.5
0E9F:  MOVF   5F,W
0EA0:  MOVWF  04
0EA1:  MOVF   00,W
0EA2:  MOVWF  64
0EA3:  MOVF   60,W
0EA4:  MOVWF  04
0EA5:  MOVF   00,W
0EA6:  SUBWF  64,W
0EA7:  BTFSS  03.2
0EA8:  GOTO   6AB
0EA9:  BCF    03.5
0EAA:  GOTO   6B0
0EAB:  BCF    03.5
0EAC:  BSF    03.5
0EAD:  BCF    61.0
0EAE:  BCF    03.5
0EAF:  GOTO   6B3
0EB0:  BSF    03.5
0EB1:  BSF    61.0
0EB2:  BCF    03.5
....................  
.................... 	if (!ret) return ret; 
*
0D30:  BSF    03.5
0D31:  BTFSS  61.0
0D32:  GOTO   535
0D33:  BCF    03.5
0D34:  GOTO   53D
0D35:  BCF    03.5
0D36:  MOVLW  00
0D37:  BSF    03.5
0D38:  BTFSC  61.0
0D39:  MOVLW  01
0D3A:  MOVWF  78
0D3B:  BCF    03.5
0D3C:  GOTO   5C8
*
0EB3:  BSF    03.5
0EB4:  BTFSS  61.0
0EB5:  GOTO   6B8
0EB6:  BCF    03.5
0EB7:  GOTO   6C0
0EB8:  BCF    03.5
0EB9:  MOVLW  00
0EBA:  BSF    03.5
0EBB:  BTFSC  61.0
0EBC:  MOVLW  01
0EBD:  MOVWF  78
0EBE:  BCF    03.5
0EBF:  GOTO   74B
....................  
.................... 	if (HIGH_RES_DUAL_CHAN  & reference->config_flag) 
*
0D3D:  MOVLW  03
0D3E:  BSF    03.5
0D3F:  ADDWF  60,W
0D40:  MOVWF  04
0D41:  MOVF   00,W
0D42:  ANDLW  20
0D43:  XORLW  00
0D44:  BTFSS  03.2
0D45:  GOTO   548
0D46:  BCF    03.5
0D47:  GOTO   571
0D48:  BCF    03.5
*
0EC0:  MOVLW  03
0EC1:  BSF    03.5
0EC2:  ADDWF  60,W
0EC3:  MOVWF  04
0EC4:  MOVF   00,W
0EC5:  ANDLW  20
0EC6:  XORLW  00
0EC7:  BTFSS  03.2
0EC8:  GOTO   6CB
0EC9:  BCF    03.5
0ECA:  GOTO   6F4
0ECB:  BCF    03.5
.................... 	{ 
.................... 		ret = (test->data_1 == reference->data_1) || (test->data_1 == reference->data_2) ; 
*
0D49:  MOVLW  01
0D4A:  BSF    03.5
0D4B:  ADDWF  5F,W
0D4C:  MOVWF  04
0D4D:  MOVF   00,W
0D4E:  MOVWF  64
0D4F:  MOVLW  01
0D50:  ADDWF  60,W
0D51:  MOVWF  04
0D52:  MOVF   00,W
0D53:  SUBWF  64,W
0D54:  BTFSS  03.2
0D55:  GOTO   558
0D56:  BCF    03.5
0D57:  GOTO   56D
0D58:  BCF    03.5
0D59:  MOVLW  01
0D5A:  BSF    03.5
0D5B:  ADDWF  5F,W
0D5C:  MOVWF  04
0D5D:  MOVF   00,W
0D5E:  MOVWF  67
0D5F:  MOVLW  02
0D60:  ADDWF  60,W
0D61:  MOVWF  04
0D62:  MOVF   00,W
0D63:  SUBWF  67,W
0D64:  BTFSS  03.2
0D65:  GOTO   568
0D66:  BCF    03.5
0D67:  GOTO   56D
0D68:  BCF    03.5
0D69:  BSF    03.5
0D6A:  BCF    61.0
0D6B:  BCF    03.5
0D6C:  GOTO   570
0D6D:  BSF    03.5
0D6E:  BSF    61.0
0D6F:  BCF    03.5
*
0ECC:  MOVLW  01
0ECD:  BSF    03.5
0ECE:  ADDWF  5F,W
0ECF:  MOVWF  04
0ED0:  MOVF   00,W
0ED1:  MOVWF  64
0ED2:  MOVLW  01
0ED3:  ADDWF  60,W
0ED4:  MOVWF  04
0ED5:  MOVF   00,W
0ED6:  SUBWF  64,W
0ED7:  BTFSS  03.2
0ED8:  GOTO   6DB
0ED9:  BCF    03.5
0EDA:  GOTO   6F0
0EDB:  BCF    03.5
0EDC:  MOVLW  01
0EDD:  BSF    03.5
0EDE:  ADDWF  5F,W
0EDF:  MOVWF  04
0EE0:  MOVF   00,W
0EE1:  MOVWF  67
0EE2:  MOVLW  02
0EE3:  ADDWF  60,W
0EE4:  MOVWF  04
0EE5:  MOVF   00,W
0EE6:  SUBWF  67,W
0EE7:  BTFSS  03.2
0EE8:  GOTO   6EB
0EE9:  BCF    03.5
0EEA:  GOTO   6F0
0EEB:  BCF    03.5
0EEC:  BSF    03.5
0EED:  BCF    61.0
0EEE:  BCF    03.5
0EEF:  GOTO   6F3
0EF0:  BSF    03.5
0EF1:  BSF    61.0
0EF2:  BCF    03.5
.................... 	} 
.................... 	else 
*
0D70:  GOTO   5C2
*
0EF3:  GOTO   745
.................... 	{ 
....................   	ret = !(MUTE_CONFIG_MASK  & reference->config_flag); 
*
0D71:  MOVLW  03
0D72:  BSF    03.5
0D73:  ADDWF  60,W
0D74:  MOVWF  04
0D75:  MOVF   00,W
0D76:  ANDLW  04
0D77:  XORLW  00
0D78:  BTFSS  03.2
0D79:  GOTO   57C
0D7A:  BCF    03.5
0D7B:  GOTO   581
0D7C:  BCF    03.5
0D7D:  BSF    03.5
0D7E:  BCF    61.0
0D7F:  BCF    03.5
0D80:  GOTO   584
0D81:  BSF    03.5
0D82:  BSF    61.0
0D83:  BCF    03.5
*
0EF4:  MOVLW  03
0EF5:  BSF    03.5
0EF6:  ADDWF  60,W
0EF7:  MOVWF  04
0EF8:  MOVF   00,W
0EF9:  ANDLW  04
0EFA:  XORLW  00
0EFB:  BTFSS  03.2
0EFC:  GOTO   6FF
0EFD:  BCF    03.5
0EFE:  GOTO   704
0EFF:  BCF    03.5
0F00:  BSF    03.5
0F01:  BCF    61.0
0F02:  BCF    03.5
0F03:  GOTO   707
0F04:  BSF    03.5
0F05:  BSF    61.0
0F06:  BCF    03.5
....................  
....................    
....................  	 	match_only_status = (DATA_1_VARY_MASK & reference->config_flag) || ((reference->status_chan) == PITCHBEND_MASK); 
*
0D84:  MOVLW  03
0D85:  BSF    03.5
0D86:  ADDWF  60,W
0D87:  MOVWF  04
0D88:  MOVF   00,W
0D89:  ANDLW  01
0D8A:  XORLW  00
0D8B:  BTFSC  03.2
0D8C:  GOTO   58F
0D8D:  BCF    03.5
0D8E:  GOTO   59C
0D8F:  BCF    03.5
0D90:  BSF    03.5
0D91:  MOVF   60,W
0D92:  MOVWF  04
0D93:  MOVF   00,W
0D94:  SUBLW  E0
0D95:  BTFSS  03.2
0D96:  GOTO   599
0D97:  BCF    03.5
0D98:  GOTO   59C
0D99:  BCF    03.5
0D9A:  MOVLW  00
0D9B:  GOTO   59D
0D9C:  MOVLW  01
0D9D:  BSF    03.5
0D9E:  MOVWF  62
*
0F07:  MOVLW  03
0F08:  BSF    03.5
0F09:  ADDWF  60,W
0F0A:  MOVWF  04
0F0B:  MOVF   00,W
0F0C:  ANDLW  01
0F0D:  XORLW  00
0F0E:  BTFSC  03.2
0F0F:  GOTO   712
0F10:  BCF    03.5
0F11:  GOTO   71F
0F12:  BCF    03.5
0F13:  BSF    03.5
0F14:  MOVF   60,W
0F15:  MOVWF  04
0F16:  MOVF   00,W
0F17:  SUBLW  E0
0F18:  BTFSS  03.2
0F19:  GOTO   71C
0F1A:  BCF    03.5
0F1B:  GOTO   71F
0F1C:  BCF    03.5
0F1D:  MOVLW  00
0F1E:  GOTO   720
0F1F:  MOVLW  01
0F20:  BSF    03.5
0F21:  MOVWF  62
....................    
....................   	if (!match_only_status) 
*
0D9F:  MOVF   62,F
0DA0:  BTFSC  03.2
0DA1:  GOTO   5A4
0DA2:  BCF    03.5
0DA3:  GOTO   5C2
0DA4:  BCF    03.5
*
0F22:  MOVF   62,F
0F23:  BTFSC  03.2
0F24:  GOTO   727
0F25:  BCF    03.5
0F26:  GOTO   745
0F27:  BCF    03.5
....................     { 
....................     	ret = ret	&& (test->data_1 == reference->data_1); 
*
0DA5:  BSF    03.5
0DA6:  BTFSC  61.0
0DA7:  GOTO   5AA
0DA8:  BCF    03.5
0DA9:  GOTO   5BB
0DAA:  BCF    03.5
0DAB:  MOVLW  01
0DAC:  BSF    03.5
0DAD:  ADDWF  5F,W
0DAE:  MOVWF  04
0DAF:  MOVF   00,W
0DB0:  MOVWF  64
0DB1:  MOVLW  01
0DB2:  ADDWF  60,W
0DB3:  MOVWF  04
0DB4:  MOVF   00,W
0DB5:  SUBWF  64,W
0DB6:  BTFSS  03.2
0DB7:  GOTO   5BA
0DB8:  BCF    03.5
0DB9:  GOTO   5BF
0DBA:  BCF    03.5
0DBB:  BSF    03.5
0DBC:  BCF    61.0
0DBD:  BCF    03.5
0DBE:  GOTO   5C2
0DBF:  BSF    03.5
0DC0:  BSF    61.0
0DC1:  BCF    03.5
*
0F28:  BSF    03.5
0F29:  BTFSC  61.0
0F2A:  GOTO   72D
0F2B:  BCF    03.5
0F2C:  GOTO   73E
0F2D:  BCF    03.5
0F2E:  MOVLW  01
0F2F:  BSF    03.5
0F30:  ADDWF  5F,W
0F31:  MOVWF  04
0F32:  MOVF   00,W
0F33:  MOVWF  64
0F34:  MOVLW  01
0F35:  ADDWF  60,W
0F36:  MOVWF  04
0F37:  MOVF   00,W
0F38:  SUBWF  64,W
0F39:  BTFSS  03.2
0F3A:  GOTO   73D
0F3B:  BCF    03.5
0F3C:  GOTO   742
0F3D:  BCF    03.5
0F3E:  BSF    03.5
0F3F:  BCF    61.0
0F40:  BCF    03.5
0F41:  GOTO   745
0F42:  BSF    03.5
0F43:  BSF    61.0
0F44:  BCF    03.5
....................     } 
.................... 	} //if (HIGH_RES_DUAL_CHAN  & reference->config_flag) 
....................  
....................   return ret; 
*
0DC2:  MOVLW  00
0DC3:  BSF    03.5
0DC4:  BTFSC  61.0
0DC5:  MOVLW  01
0DC6:  MOVWF  78
0DC7:  BCF    03.5
*
0F45:  MOVLW  00
0F46:  BSF    03.5
0F47:  BTFSC  61.0
0F48:  MOVLW  01
0F49:  MOVWF  78
0F4A:  BCF    03.5
.................... } 
....................  
.................... void WriteHighResAnaOut(int channel, str_midiconfig* message, str_midiconfig* reference) 
.................... { 
.................... 	int outval; 
....................  
.................... 	if (message->data_1 == reference->data_1) // Data 1 is MSB 
*
0DDC:  MOVLW  01
0DDD:  BSF    03.5
0DDE:  ADDWF  60,W
0DDF:  MOVWF  04
0DE0:  MOVF   00,W
0DE1:  MOVWF  64
0DE2:  MOVLW  01
0DE3:  ADDWF  61,W
0DE4:  MOVWF  04
0DE5:  MOVF   00,W
0DE6:  SUBWF  64,W
0DE7:  BTFSC  03.2
0DE8:  GOTO   5EB
0DE9:  BCF    03.5
0DEA:  GOTO   5FA
0DEB:  BCF    03.5
.................... 	{ 
.................... 		outval = message->data_2; 
0DEC:  MOVLW  02
0DED:  BSF    03.5
0DEE:  ADDWF  60,W
0DEF:  MOVWF  04
0DF0:  MOVF   00,W
0DF1:  MOVWF  62
.................... 		ana_values[channel] = outval<<1; 
0DF2:  MOVLW  55
0DF3:  ADDWF  5F,W
0DF4:  MOVWF  04
0DF5:  BCF    03.0
0DF6:  RLF    62,W
0DF7:  MOVWF  77
0DF8:  MOVWF  00
0DF9:  BCF    03.5
.................... 	} 
....................  
.................... 	if (message->data_1 == reference->data_2) // Data 2 is LSB and generates output 
0DFA:  MOVLW  01
0DFB:  BSF    03.5
0DFC:  ADDWF  60,W
0DFD:  MOVWF  04
0DFE:  MOVF   00,W
0DFF:  MOVWF  64
0E00:  MOVLW  02
0E01:  ADDWF  61,W
0E02:  MOVWF  04
0E03:  MOVF   00,W
0E04:  SUBWF  64,W
0E05:  BTFSC  03.2
0E06:  GOTO   609
0E07:  BCF    03.5
0E08:  GOTO   625
0E09:  BCF    03.5
.................... 	{ 
.................... 		outval = ana_values[channel]; 
0E0A:  MOVLW  55
0E0B:  BSF    03.5
0E0C:  ADDWF  5F,W
0E0D:  MOVWF  04
0E0E:  MOVF   00,W
0E0F:  MOVWF  62
....................  
.................... 		if (message->data_2) 
0E10:  MOVLW  02
0E11:  ADDWF  60,W
0E12:  MOVWF  04
0E13:  MOVF   00,F
0E14:  BTFSS  03.2
0E15:  GOTO   618
0E16:  BCF    03.5
0E17:  GOTO   61C
0E18:  BCF    03.5
.................... 		{ 
.................... 			outval++;  
0E19:  BSF    03.5
0E1A:  INCF   62,F
0E1B:  BCF    03.5
.................... 		} 
....................   
.................... 		GenerateAnalogueOutput (channel, outval);  
0E1C:  BSF    03.5
0E1D:  MOVF   5F,W
0E1E:  MOVWF  63
0E1F:  MOVF   62,W
0E20:  MOVWF  64
0E21:  BCF    03.5
0E22:  BCF    0A.3
0E23:  CALL   32F
0E24:  BSF    0A.3
.................... 	} 
....................  
.................... 	 
.................... } 
....................  
.................... // test all analogs and digitals for a match 
.................... void DecodeMidiMessage (str_midiconfig* test_msg) 
.................... { 
.................... 	str_midiconfig config; 
.................... 	int i; 
....................   byte outval; 
....................  
....................   outval = test_msg->data_2 <<1; 
*
0CF2:  MOVLW  02
0CF3:  BSF    03.5
0CF4:  ADDWF  58,W
0CF5:  MOVWF  04
0CF6:  BCF    03.0
0CF7:  RLF    00,W
0CF8:  MOVWF  5E
....................   
.................... 	for (i = 0; i < NUM_ANALOGUE_OUT; i++) 
0CF9:  CLRF   5D
0CFA:  BCF    03.5
0CFB:  BSF    03.5
0CFC:  MOVF   5D,W
0CFD:  SUBLW  07
0CFE:  BTFSC  03.0
0CFF:  GOTO   502
0D00:  BCF    03.5
0D01:  GOTO   67B
0D02:  BCF    03.5
.................... 		{ 
.................... #ifndef _SIMULATE 
.................... 			ReadAnalogueOutConfig (&config, i); 
0D03:  MOVLW  D9
0D04:  BSF    03.5
0D05:  MOVWF  5F
0D06:  MOVF   5D,W
0D07:  MOVWF  60
0D08:  BCF    03.5
.................... #else 
....................       GetDefaultAnalogueOut (&config, i); 
.................... #endif 
.................... 			if (MatchingConfig (test_msg, &config)) 
*
0D15:  BSF    03.5
0D16:  MOVF   58,W
0D17:  MOVWF  5F
0D18:  MOVLW  D9
0D19:  MOVWF  60
0D1A:  BCF    03.5
*
0DC8:  MOVF   78,F
0DC9:  BTFSC  03.2
0DCA:  GOTO   677
.................... 				{ 
.................... 					if (HIGH_RES_DUAL_CHAN  & config.config_flag) 
0DCB:  BSF    03.5
0DCC:  MOVF   5C,W
0DCD:  ANDLW  20
0DCE:  XORLW  00
0DCF:  BTFSS  03.2
0DD0:  GOTO   5D3
0DD1:  BCF    03.5
0DD2:  GOTO   626
0DD3:  BCF    03.5
.................... 					{ 
.................... 						WriteHighResAnaOut(i, test_msg, &config); 
0DD4:  BSF    03.5
0DD5:  MOVF   5D,W
0DD6:  MOVWF  5F
0DD7:  MOVF   58,W
0DD8:  MOVWF  60
0DD9:  MOVLW  D9
0DDA:  MOVWF  61
0DDB:  BCF    03.5
.................... 						return; 
*
0E25:  GOTO   778
.................... 					} 
....................  
.................... 					if (test_msg->status_chan == PITCHBEND_MASK) 
0E26:  BSF    03.5
0E27:  MOVF   58,W
0E28:  MOVWF  04
0E29:  MOVF   00,W
0E2A:  SUBLW  E0
0E2B:  BTFSC  03.2
0E2C:  GOTO   62F
0E2D:  BCF    03.5
0E2E:  GOTO   63E
0E2F:  BCF    03.5
.................... 					{ 
.................... 						if (test_msg->data_1) 
0E30:  MOVLW  01
0E31:  BSF    03.5
0E32:  ADDWF  58,W
0E33:  MOVWF  04
0E34:  MOVF   00,F
0E35:  BTFSS  03.2
0E36:  GOTO   639
0E37:  BCF    03.5
0E38:  GOTO   63D
0E39:  BCF    03.5
.................... 						{ 
.................... 							outval++; // add LSB 
0E3A:  BSF    03.5
0E3B:  INCF   5E,F
0E3C:  BCF    03.5
.................... 						}  
.................... 					} 
.................... 					else 
0E3D:  GOTO   64F
.................... 					{ 
....................           	if (DATA_1_VARY_MASK & config.config_flag) 
0E3E:  BSF    03.5
0E3F:  MOVF   5C,W
0E40:  ANDLW  01
0E41:  XORLW  00
0E42:  BTFSS  03.2
0E43:  GOTO   646
0E44:  BCF    03.5
0E45:  GOTO   64F
0E46:  BCF    03.5
....................             	{ 
.................... 					  	outval = test_msg->data_1<<1;   
0E47:  MOVLW  01
0E48:  BSF    03.5
0E49:  ADDWF  58,W
0E4A:  MOVWF  04
0E4B:  BCF    03.0
0E4C:  RLF    00,W
0E4D:  MOVWF  5E
0E4E:  BCF    03.5
....................             	} 
.................... 					} 
....................  
....................           if (INVERT_VALUE_MASK & config.config_flag) 
0E4F:  BSF    03.5
0E50:  MOVF   5C,W
0E51:  ANDLW  02
0E52:  XORLW  00
0E53:  BTFSS  03.2
0E54:  GOTO   657
0E55:  BCF    03.5
0E56:  GOTO   66E
0E57:  BCF    03.5
....................             { 
....................             outval ^= 0xFf; // flip all  
0E58:  MOVLW  FF
0E59:  BSF    03.5
0E5A:  XORWF  5E,F
.................... 						if (test_msg->status_chan != PITCHBEND_MASK) 
0E5B:  MOVF   58,W
0E5C:  MOVWF  04
0E5D:  MOVF   00,W
0E5E:  SUBLW  E0
0E5F:  BTFSS  03.2
0E60:  GOTO   663
0E61:  BCF    03.5
0E62:  GOTO   66E
0E63:  BCF    03.5
.................... 							{ 
.................... 								if (outval == 1) // we flipped the LSB. We want zero to be zero 
0E64:  BSF    03.5
0E65:  DECFSZ 5E,W
0E66:  GOTO   668
0E67:  GOTO   66A
0E68:  BCF    03.5
0E69:  GOTO   66E
0E6A:  BCF    03.5
.................... 								{ 
.................... 									outval = 0; 
0E6B:  BSF    03.5
0E6C:  CLRF   5E
0E6D:  BCF    03.5
.................... 								} 
.................... 							} 
....................             } 
....................  
....................           GenerateAnalogueOutput (i, outval);  
0E6E:  BSF    03.5
0E6F:  MOVF   5D,W
0E70:  MOVWF  63
0E71:  MOVF   5E,W
0E72:  MOVWF  64
0E73:  BCF    03.5
0E74:  BCF    0A.3
0E75:  CALL   32F
0E76:  BSF    0A.3
....................               
.................... 				} 
.................... 		} 
0E77:  BSF    03.5
0E78:  INCF   5D,F
0E79:  BCF    03.5
0E7A:  GOTO   4FB
....................  
.................... 	for (i = 0; i < NUM_DIGITAL_OUT; i++) 
0E7B:  BSF    03.5
0E7C:  CLRF   5D
0E7D:  BCF    03.5
0E7E:  BSF    03.5
0E7F:  MOVF   5D,W
0E80:  SUBLW  0F
0E81:  BTFSC  03.0
0E82:  GOTO   685
0E83:  BCF    03.5
0E84:  GOTO   778
0E85:  BCF    03.5
.................... 		{ 
.................... #ifndef _SIMULATE 
.................... 			ReadDigitalOutConfig (&config, i); 
0E86:  MOVLW  D9
0E87:  BSF    03.5
0E88:  MOVWF  5F
0E89:  MOVF   5D,W
0E8A:  MOVWF  60
0E8B:  BCF    03.5
.................... #else 
....................       GetDefaultDigitalOut (&config, i); 
.................... #endif		 
.................... 	if ( MatchingConfig (test_msg, &config)) 
*
0E98:  BSF    03.5
0E99:  MOVF   58,W
0E9A:  MOVWF  5F
0E9B:  MOVLW  D9
0E9C:  MOVWF  60
0E9D:  BCF    03.5
*
0F4B:  MOVF   78,F
0F4C:  BTFSC  03.2
0F4D:  GOTO   774
.................... 				{ 
....................           if (DATA_1_VARY_MASK & config.config_flag) 
0F4E:  BSF    03.5
0F4F:  MOVF   5C,W
0F50:  ANDLW  01
0F51:  XORLW  00
0F52:  BTFSS  03.2
0F53:  GOTO   756
0F54:  BCF    03.5
0F55:  GOTO   75E
0F56:  BCF    03.5
....................             { 
.................... 					  outval = test_msg->data_1;   
0F57:  MOVLW  01
0F58:  BSF    03.5
0F59:  ADDWF  58,W
0F5A:  MOVWF  04
0F5B:  MOVF   00,W
0F5C:  MOVWF  5E
0F5D:  BCF    03.5
....................             } 
....................            
....................           if (INVERT_VALUE_MASK & config.config_flag) 
0F5E:  BSF    03.5
0F5F:  MOVF   5C,W
0F60:  ANDLW  02
0F61:  XORLW  00
0F62:  BTFSS  03.2
0F63:  GOTO   766
0F64:  BCF    03.5
0F65:  GOTO   76B
0F66:  BCF    03.5
....................             { 
....................             outval ^= 0x7f; // flip all but msb 
0F67:  MOVLW  7F
0F68:  BSF    03.5
0F69:  XORWF  5E,F
0F6A:  BCF    03.5
....................             } 
....................  
....................              
.................... 					GenerateDigitalOutput (i, outval); 
0F6B:  BSF    03.5
0F6C:  MOVF   5D,W
0F6D:  MOVWF  5F
0F6E:  MOVF   5E,W
0F6F:  MOVWF  60
0F70:  BCF    03.5
0F71:  BCF    0A.3
0F72:  CALL   37E
0F73:  BSF    0A.3
.................... 				} 
.................... 		} 
0F74:  BSF    03.5
0F75:  INCF   5D,F
0F76:  BCF    03.5
0F77:  GOTO   67E
....................  
.................... } 
.................... 
.................... #include "procmidi.h" 
....................  /************************************************************** 
....................  * Module for processing Midi input on PIC 
....................  * Contains running status, and determines how many bytes left to  
....................  * read in an input midi message 
....................  * 
....................  * dependant upon midicfg.h, decmidi.h 
....................  *************************************************************/ 
....................  
....................  
.................... // forward declaration 
.................... void ResetController (); 
.................... short DecodeSysexByte (byte byte_val); 
.................... void ResetSysex(); 
.................... void ExecuteSysexMessage(); 
....................  
.................... typedef struct 
.................... { 
.................... 	str_midiconfig current_msg; 
.................... 	byte in_sysex :1; 
.................... 	byte bytes_left :2; // the number of bytes remaining in this message 
.................... 	byte our_sysex :1; // this could be our sysex 
.................... 	byte byte_num:4 ;   // the byte number within current message 
.................... 	byte last_status_chan; 
.................... 	byte control_char; // for sysex commands 
.................... } str_midistatus; 
....................  
.................... str_midistatus midi_status; 
....................  
.................... void InitialiseMidiStatus() 
.................... { 
.................... 	midi_status.current_msg.status_chan = 0; 
*
06A8:  CLRF   5D
.................... 	midi_status.in_sysex = 0; 
06A9:  BCF    61.0
.................... 	midi_status.bytes_left = 0; 
06AA:  MOVLW  F9
06AB:  ANDWF  61,W
06AC:  MOVWF  61
.................... 	midi_status.byte_num = 0; 
06AD:  MOVLW  0F
06AE:  ANDWF  61,W
06AF:  MOVWF  61
.................... 	midi_status.last_status_chan = 0; // the last status sent by us 
06B0:  CLRF   62
06B1:  RETLW  00
.................... } 
....................  
.................... void SetLastStatusChan (byte status_chan) 
.................... { 
.................... 	midi_status.last_status_chan = status_chan; 
*
061A:  BSF    03.5
061B:  MOVF   55,W
061C:  BCF    03.5
061D:  MOVWF  62
*
11FC:  BSF    03.5
11FD:  MOVF   55,W
11FE:  BCF    03.5
11FF:  MOVWF  62
*
12D1:  BSF    03.5
12D2:  MOVF   55,W
12D3:  BCF    03.5
12D4:  MOVWF  62
*
1AA1:  BSF    03.5
1AA2:  MOVF   55,W
1AA3:  BCF    03.5
1AA4:  MOVWF  62
*
1BD1:  BSF    03.5
1BD2:  MOVF   55,W
1BD3:  BCF    03.5
1BD4:  MOVWF  62
*
1C81:  BSF    03.5
1C82:  MOVF   55,W
1C83:  BCF    03.5
1C84:  MOVWF  62
*
1D3D:  BSF    03.5
1D3E:  MOVF   55,W
1D3F:  BCF    03.5
1D40:  MOVWF  62
*
1DFB:  BSF    03.5
1DFC:  MOVF   55,W
1DFD:  BCF    03.5
1DFE:  MOVWF  62
.................... } 
....................  
.................... #ifdef MIDI_CONTROLLER_BUILD 
.................... // returns true if the merge is currently free 
.................... short MidiOutFree() 
.................... { 
.................... 	return (!DoMidiMerge()) || (InQueueEmpty ()  
....................           && !midi_status.bytes_left  
....................           && !midi_status.in_sysex); 
*
05F1:  MOVF   78,F
05F2:  BTFSC  03.2
05F3:  GOTO   60A
*
05FC:  MOVF   78,F
05FD:  BTFSC  03.2
05FE:  GOTO   608
05FF:  MOVF   61,W
0600:  MOVWF  77
0601:  RRF    77,W
0602:  ANDLW  03
0603:  XORLW  00
0604:  BTFSS  03.2
0605:  GOTO   608
0606:  BTFSS  61.0
0607:  GOTO   60A
0608:  MOVLW  00
0609:  GOTO   60B
060A:  MOVLW  01
060B:  MOVWF  78
*
11D1:  MOVF   78,F
11D2:  BTFSC  03.2
11D3:  GOTO   1EA
*
11DC:  MOVF   78,F
11DD:  BTFSC  03.2
11DE:  GOTO   1E8
11DF:  MOVF   61,W
11E0:  MOVWF  77
11E1:  RRF    77,W
11E2:  ANDLW  03
11E3:  XORLW  00
11E4:  BTFSS  03.2
11E5:  GOTO   1E8
11E6:  BTFSS  61.0
11E7:  GOTO   1EA
11E8:  MOVLW  00
11E9:  GOTO   1EB
11EA:  MOVLW  01
11EB:  MOVWF  78
*
12A6:  MOVF   78,F
12A7:  BTFSC  03.2
12A8:  GOTO   2BF
*
12B1:  MOVF   78,F
12B2:  BTFSC  03.2
12B3:  GOTO   2BD
12B4:  MOVF   61,W
12B5:  MOVWF  77
12B6:  RRF    77,W
12B7:  ANDLW  03
12B8:  XORLW  00
12B9:  BTFSS  03.2
12BA:  GOTO   2BD
12BB:  BTFSS  61.0
12BC:  GOTO   2BF
12BD:  MOVLW  00
12BE:  GOTO   2C0
12BF:  MOVLW  01
12C0:  MOVWF  78
*
1A78:  MOVF   78,F
1A79:  BTFSC  03.2
1A7A:  GOTO   291
*
1A83:  MOVF   78,F
1A84:  BTFSC  03.2
1A85:  GOTO   28F
1A86:  MOVF   61,W
1A87:  MOVWF  77
1A88:  RRF    77,W
1A89:  ANDLW  03
1A8A:  XORLW  00
1A8B:  BTFSS  03.2
1A8C:  GOTO   28F
1A8D:  BTFSS  61.0
1A8E:  GOTO   291
1A8F:  MOVLW  00
1A90:  GOTO   292
1A91:  MOVLW  01
1A92:  MOVWF  78
*
1BA8:  MOVF   78,F
1BA9:  BTFSC  03.2
1BAA:  GOTO   3C1
*
1BB3:  MOVF   78,F
1BB4:  BTFSC  03.2
1BB5:  GOTO   3BF
1BB6:  MOVF   61,W
1BB7:  MOVWF  77
1BB8:  RRF    77,W
1BB9:  ANDLW  03
1BBA:  XORLW  00
1BBB:  BTFSS  03.2
1BBC:  GOTO   3BF
1BBD:  BTFSS  61.0
1BBE:  GOTO   3C1
1BBF:  MOVLW  00
1BC0:  GOTO   3C2
1BC1:  MOVLW  01
1BC2:  MOVWF  78
*
1C58:  MOVF   78,F
1C59:  BTFSC  03.2
1C5A:  GOTO   471
*
1C63:  MOVF   78,F
1C64:  BTFSC  03.2
1C65:  GOTO   46F
1C66:  MOVF   61,W
1C67:  MOVWF  77
1C68:  RRF    77,W
1C69:  ANDLW  03
1C6A:  XORLW  00
1C6B:  BTFSS  03.2
1C6C:  GOTO   46F
1C6D:  BTFSS  61.0
1C6E:  GOTO   471
1C6F:  MOVLW  00
1C70:  GOTO   472
1C71:  MOVLW  01
1C72:  MOVWF  78
*
1D14:  MOVF   78,F
1D15:  BTFSC  03.2
1D16:  GOTO   52D
*
1D1F:  MOVF   78,F
1D20:  BTFSC  03.2
1D21:  GOTO   52B
1D22:  MOVF   61,W
1D23:  MOVWF  77
1D24:  RRF    77,W
1D25:  ANDLW  03
1D26:  XORLW  00
1D27:  BTFSS  03.2
1D28:  GOTO   52B
1D29:  BTFSS  61.0
1D2A:  GOTO   52D
1D2B:  MOVLW  00
1D2C:  GOTO   52E
1D2D:  MOVLW  01
1D2E:  MOVWF  78
*
1DD2:  MOVF   78,F
1DD3:  BTFSC  03.2
1DD4:  GOTO   5EB
*
1DDD:  MOVF   78,F
1DDE:  BTFSC  03.2
1DDF:  GOTO   5E9
1DE0:  MOVF   61,W
1DE1:  MOVWF  77
1DE2:  RRF    77,W
1DE3:  ANDLW  03
1DE4:  XORLW  00
1DE5:  BTFSS  03.2
1DE6:  GOTO   5E9
1DE7:  BTFSS  61.0
1DE8:  GOTO   5EB
1DE9:  MOVLW  00
1DEA:  GOTO   5EC
1DEB:  MOVLW  01
1DEC:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #pragma  inline 
.................... void ProcessSystemMessage ( byte midi_byte) 
.................... { 
.................... 	switch (midi_byte) 
*
0864:  BSF    03.5
0865:  MOVF   58,W
0866:  MOVWF  77
0867:  MOVLW  F0
0868:  SUBWF  77,W
0869:  BTFSS  03.2
086A:  GOTO   06D
086B:  BCF    03.5
086C:  GOTO   08D
086D:  MOVLW  F1
086E:  SUBWF  77,W
086F:  BTFSS  03.2
0870:  GOTO   073
0871:  BCF    03.5
0872:  GOTO   09C
0873:  MOVLW  F2
0874:  SUBWF  77,W
0875:  BTFSS  03.2
0876:  GOTO   079
0877:  BCF    03.5
0878:  GOTO   0A4
0879:  MOVLW  F3
087A:  SUBWF  77,W
087B:  BTFSS  03.2
087C:  GOTO   07F
087D:  BCF    03.5
087E:  GOTO   0AC
087F:  MOVLW  F7
0880:  SUBWF  77,W
0881:  BTFSS  03.2
0882:  GOTO   085
0883:  BCF    03.5
0884:  GOTO   0B4
0885:  MOVLW  FF
0886:  SUBWF  77,W
0887:  BTFSS  03.2
0888:  GOTO   08B
0889:  BCF    03.5
088A:  GOTO   320
088B:  BCF    03.5
088C:  GOTO   322
.................... 		{ 
.................... 		case SYSEX_BEGIN: 
.................... 			midi_status.in_sysex = 1; 
088D:  BSF    61.0
.................... 			midi_status.our_sysex = 1; 
088E:  BSF    61.3
.................... 			midi_status.current_msg.status_chan = 0; 
088F:  CLRF   5D
.................... 			midi_status.byte_num = 0; 
0890:  MOVLW  0F
0891:  ANDWF  61,W
0892:  MOVWF  61
.................... 			midi_status.last_status_chan = 0; 
0893:  CLRF   62
.................... 			midi_status.control_char = 0x00; 
0894:  CLRF   63
.................... 			ResetSysex(); 
.................... 			break; 
*
089B:  GOTO   323
....................  
.................... 		case SYSTEM_QUARTER_FRAME: 
.................... 			midi_status.byte_num = 0; 
089C:  MOVLW  0F
089D:  ANDWF  61,W
089E:  MOVWF  61
.................... 			midi_status.bytes_left = 1; 
089F:  MOVLW  F9
08A0:  ANDWF  61,W
08A1:  IORLW  02
08A2:  MOVWF  61
.................... 			break; 
08A3:  GOTO   323
....................  
.................... 		case SYSTEM_SONG_POS: 
.................... 			midi_status.byte_num = 0; 
08A4:  MOVLW  0F
08A5:  ANDWF  61,W
08A6:  MOVWF  61
.................... 			midi_status.bytes_left = 2; 
08A7:  MOVLW  F9
08A8:  ANDWF  61,W
08A9:  IORLW  04
08AA:  MOVWF  61
.................... 			break; 
08AB:  GOTO   323
....................  
.................... 		case SYSTEM_SONG_SELECT: 
.................... 			midi_status.byte_num = 0; 
08AC:  MOVLW  0F
08AD:  ANDWF  61,W
08AE:  MOVWF  61
.................... 			midi_status.bytes_left = 1; 
08AF:  MOVLW  F9
08B0:  ANDWF  61,W
08B1:  IORLW  02
08B2:  MOVWF  61
.................... 			break; 
08B3:  GOTO   323
....................  
.................... 		case SYSEX_END: 
.................... 			if (midi_status.our_sysex)  
08B4:  BTFSS  61.3
08B5:  GOTO   318
.................... 				{ 
.................... 					ExecuteSysexMessage(); 
.................... 				} 
.................... 			midi_status.in_sysex = 0; 
*
0B18:  BCF    61.0
.................... 			midi_status.our_sysex = 0; 
0B19:  BCF    61.3
.................... 			midi_status.current_msg.status_chan = 0; 
0B1A:  CLRF   5D
.................... 			midi_status.byte_num = 0; 
0B1B:  MOVLW  0F
0B1C:  ANDWF  61,W
0B1D:  MOVWF  61
.................... 			midi_status.last_status_chan = 0; 
0B1E:  CLRF   62
.................... 			 
....................       break; 
0B1F:  GOTO   323
....................  
.................... 		case SYSTEM_RESET: 
.................... 			//reset_cpu(); 
.................... #ifdef MIDI_CONTROLLER_BUILD 
.................... 			while (1); // wait for watchdog 
.................... #endif 
0B20:  GOTO   320
.................... 			break; 
0B21:  GOTO   323
.................... 		default: 
....................       break; 
0B22:  GOTO   323
.................... 			// just ignore 
.................... 		} 
.................... } // end void ProcessSystemMessage ( byte midi_byte) 
....................  
.................... #ifdef MIDI_CONTROLLER_BUILD 
.................... // ensures that complete midi word is transmitted  
.................... void ProcessMidiInputStream() 
.................... { 
.................... 	byte midi_byte; 
.................... 	byte status_nibble; 
.................... 	byte* msg_ptr; 
....................   short valid_byte; 
.................... 	 
.................... 	while (!InQueueEmpty()) 
*
0808:  MOVF   78,F
0809:  BTFSS  03.2
080A:  GOTO   779
.................... 		{ 
.................... 			restart_wdt(); 
080B:  CLRWDT
.................... 			midi_byte = GetInChar(); 
*
082B:  MOVF   78,W
082C:  BSF    03.5
082D:  MOVWF  54
....................  
.................... 			if (midi_byte & STATUS_BYTE_MASK) // then this is a status byte 
082E:  MOVF   54,W
082F:  ANDLW  80
0830:  XORLW  00
0831:  BTFSS  03.2
0832:  GOTO   035
0833:  BCF    03.5
0834:  GOTO   342
0835:  BCF    03.5
.................... 				{ 
....................           if (DoMidiMerge()) 
*
0848:  MOVF   78,F
0849:  BTFSC  03.2
084A:  GOTO   055
....................   					{ 
.................... 							WriteOutData (midi_byte); 
084B:  BSF    03.5
084C:  MOVF   54,W
084D:  MOVWF  5D
084E:  BCF    03.5
.................... 						} 
....................  
.................... 					status_nibble = midi_byte & STATUS_NIBBLE_MASK; 
*
0855:  BSF    03.5
0856:  MOVF   54,W
0857:  ANDLW  F0
0858:  MOVWF  55
....................  
.................... 					if (status_nibble == SYSTEM_MSG_VAL) // then this is system message 
0859:  MOVF   55,W
085A:  SUBLW  F0
085B:  BTFSC  03.2
085C:  GOTO   05F
085D:  BCF    03.5
085E:  GOTO   324
085F:  BCF    03.5
....................             { 
.................... 							ProcessSystemMessage (midi_byte); 
0860:  BSF    03.5
0861:  MOVF   54,W
0862:  MOVWF  58
0863:  BCF    03.5
....................             } 
....................           else 
*
0B23:  GOTO   341
.................... 						{ 
.................... 							midi_status.in_sysex = 0; // clear in sysex flag 
0B24:  BCF    61.0
.................... 							midi_status.current_msg.status_chan = midi_byte; 
0B25:  BSF    03.5
0B26:  MOVF   54,W
0B27:  BCF    03.5
0B28:  MOVWF  5D
....................  
.................... 							midi_status.bytes_left = NumTxBytes (&(midi_status.current_msg)) -1; 
0B29:  MOVLW  5D
0B2A:  BSF    03.5
0B2B:  MOVWF  58
0B2C:  BCF    03.5
0B2D:  BCF    0A.3
0B2E:  CALL   170
0B2F:  BSF    0A.3
0B30:  MOVLW  01
0B31:  SUBWF  78,W
0B32:  ANDLW  03
0B33:  MOVWF  77
0B34:  BCF    03.0
0B35:  RLF    77,F
0B36:  MOVLW  F9
0B37:  ANDWF  61,W
0B38:  IORWF  77,W
0B39:  MOVWF  61
.................... 							// store the last status that we have transmitted 
.................... 							midi_status.last_status_chan = midi_byte; 
0B3A:  BSF    03.5
0B3B:  MOVF   54,W
0B3C:  BCF    03.5
0B3D:  MOVWF  62
.................... 					 
.................... 							midi_status.byte_num = 0;		 
0B3E:  MOVLW  0F
0B3F:  ANDWF  61,W
0B40:  MOVWF  61
.................... 						} 
.................... 					 
.................... 				} 
.................... 			else // not a status byte 
0B41:  GOTO   778
.................... 				{ 
.................... 					midi_status.byte_num++; 
0B42:  MOVF   61,W
0B43:  ADDLW  10
0B44:  ANDLW  F0
0B45:  MOVWF  77
0B46:  MOVLW  0F
0B47:  ANDWF  61,W
0B48:  IORWF  77,W
0B49:  MOVWF  61
....................  
.................... 					if (midi_status.in_sysex) 
0B4A:  BTFSS  61.0
0B4B:  GOTO   451
.................... 						{ 
.................... 							// we need to write data out 
....................               if (DoMidiMerge()) 
*
0B5E:  MOVF   78,F
0B5F:  BTFSC  03.2
0B60:  GOTO   36B
.................... 								{ 
.................... 									WriteOutData (midi_byte); 
0B61:  BSF    03.5
0B62:  MOVF   54,W
0B63:  MOVWF  5D
0B64:  BCF    03.5
.................... 								} 
....................  
.................... 							if (midi_status.our_sysex) 
*
0B6B:  BTFSS  61.3
0B6C:  GOTO   450
.................... 								{ 
....................                 if (DecodeMidiByte (&midi_status.control_char, &midi_byte)) 
0B6D:  MOVLW  63
0B6E:  BSF    03.5
0B6F:  MOVWF  58
0B70:  MOVLW  D4
0B71:  MOVWF  59
0B72:  BCF    03.5
*
0BC2:  MOVF   78,F
0BC3:  BTFSC  03.2
0BC4:  GOTO   450
....................   								{ 
....................                   midi_status.our_sysex = DecodeSysexByte (midi_byte);	 
0BC5:  BSF    03.5
0BC6:  MOVF   54,W
0BC7:  MOVWF  58
0BC8:  BCF    03.5
*
0C4A:  MOVF   78,F
0C4B:  BTFSS  03.2
0C4C:  GOTO   44F
0C4D:  BCF    61.3
0C4E:  GOTO   450
0C4F:  BSF    61.3
....................                   } 
.................... 								} 
.................... 						} 
.................... 					else // not in sysex 
0C50:  GOTO   778
.................... 						{ 
....................               valid_byte = 1; 
0C51:  BSF    03.5
0C52:  BSF    57.0
....................  
.................... 							if (!midi_status.bytes_left)// must be using running status 
0C53:  BCF    03.5
0C54:  MOVF   61,W
0C55:  MOVWF  77
0C56:  RRF    77,W
0C57:  ANDLW  03
0C58:  XORLW  00
0C59:  BTFSS  03.2
0C5A:  GOTO   4AC
.................... 								{ 
.................... 									valid_byte = (NumTxBytes (&(midi_status.current_msg))); 
0C5B:  MOVLW  5D
0C5C:  BSF    03.5
0C5D:  MOVWF  58
0C5E:  BCF    03.5
0C5F:  BCF    0A.3
0C60:  CALL   170
0C61:  BSF    0A.3
0C62:  MOVF   78,F
0C63:  BTFSS  03.2
0C64:  GOTO   469
0C65:  BSF    03.5
0C66:  BCF    57.0
0C67:  BCF    03.5
0C68:  GOTO   46C
0C69:  BSF    03.5
0C6A:  BSF    57.0
0C6B:  BCF    03.5
....................      
....................                   if (valid_byte) 
0C6C:  BSF    03.5
0C6D:  BTFSC  57.0
0C6E:  GOTO   471
0C6F:  BCF    03.5
0C70:  GOTO   4AC
0C71:  BCF    03.5
....................                     { 
.................... 											midi_status.bytes_left = NumTxBytes (&(midi_status.current_msg)) -1; 
0C72:  MOVLW  5D
0C73:  BSF    03.5
0C74:  MOVWF  58
0C75:  BCF    03.5
0C76:  BCF    0A.3
0C77:  CALL   170
0C78:  BSF    0A.3
0C79:  MOVLW  01
0C7A:  SUBWF  78,W
0C7B:  ANDLW  03
0C7C:  MOVWF  77
0C7D:  BCF    03.0
0C7E:  RLF    77,F
0C7F:  MOVLW  F9
0C80:  ANDWF  61,W
0C81:  IORWF  77,W
0C82:  MOVWF  61
....................  
.................... 											if (midi_status.last_status_chan  
.................... 													!= midi_status.current_msg.status_chan) 
0C83:  MOVF   5D,W
0C84:  SUBWF  62,W
0C85:  BTFSC  03.2
0C86:  GOTO   4A8
.................... 												{ 
....................                           if (DoMidiMerge()) 
*
0C99:  MOVF   78,F
0C9A:  BTFSC  03.2
0C9B:  GOTO   4A6
.................... 														{ 
.................... 															WriteOutData (midi_status.current_msg.status_chan); 
0C9C:  MOVF   5D,W
0C9D:  BSF    03.5
0C9E:  MOVWF  5D
0C9F:  BCF    03.5
.................... 														} 
....................  
.................... 													midi_status.last_status_chan = midi_status.current_msg.status_chan; 
*
0CA6:  MOVF   5D,W
0CA7:  MOVWF  62
.................... 												} 
....................  
.................... 											midi_status.byte_num = 1; 
0CA8:  MOVLW  0F
0CA9:  ANDWF  61,W
0CAA:  IORLW  10
0CAB:  MOVWF  61
....................                     } 
.................... 								} 
.................... 							 
....................               if (valid_byte) 
0CAC:  BSF    03.5
0CAD:  BTFSC  57.0
0CAE:  GOTO   4B1
0CAF:  BCF    03.5
0CB0:  GOTO   778
0CB1:  BCF    03.5
.................... 								{ 
....................                 if (DoMidiMerge()) 
*
0CC4:  MOVF   78,F
0CC5:  BTFSC  03.2
0CC6:  GOTO   4D1
.................... 									{ 
.................... 										WriteOutData (midi_byte); 
0CC7:  BSF    03.5
0CC8:  MOVF   54,W
0CC9:  MOVWF  5D
0CCA:  BCF    03.5
.................... 									} 
....................  
.................... 									// store current byte  
.................... 									msg_ptr = (byte*)(&midi_status.current_msg); 
*
0CD1:  MOVLW  5D
0CD2:  BSF    03.5
0CD3:  MOVWF  56
.................... 									msg_ptr [midi_status.byte_num] = midi_byte; 
0CD4:  BCF    03.5
0CD5:  MOVF   61,W
0CD6:  MOVWF  77
0CD7:  SWAPF  77,W
0CD8:  ANDLW  0F
0CD9:  BSF    03.5
0CDA:  ADDWF  56,W
0CDB:  MOVWF  04
0CDC:  MOVF   54,W
0CDD:  MOVWF  00
.................... 							 
.................... 									midi_status.bytes_left--; 
0CDE:  BCF    03.5
0CDF:  MOVF   61,W
0CE0:  ADDLW  06
0CE1:  ANDLW  06
0CE2:  MOVWF  77
0CE3:  MOVLW  F9
0CE4:  ANDWF  61,W
0CE5:  IORWF  77,W
0CE6:  MOVWF  61
.................... 							 
.................... 									// if no bytes to tx, we need to decode to see if we need to produce some sort of o/p 
.................... 									if (!midi_status.bytes_left) 
0CE7:  MOVF   61,W
0CE8:  MOVWF  77
0CE9:  RRF    77,W
0CEA:  ANDLW  03
0CEB:  XORLW  00
0CEC:  BTFSS  03.2
0CED:  GOTO   778
.................... 										{ 
.................... 											DecodeMidiMessage (&midi_status.current_msg); 
0CEE:  MOVLW  5D
0CEF:  BSF    03.5
0CF0:  MOVWF  58
0CF1:  BCF    03.5
.................... 										} 
.................... 								} 
.................... 						} 
.................... 				} 
.................... 		} 
*
0F78:  GOTO   000
0F79:  RETLW  00
.................... } 
....................  
.................... #endif  
.................... 
.................... #include "digout.h" 
....................  /********************************************************************** 
.................... Performs the digital output using an SPI write 
.................... ***********************************************************************/ 
.................... typedef struct  
.................... { 
....................   byte upper; 
....................   byte lower; 
.................... }str_digout; 
....................  
.................... str_digout current_value; // this is the current state of the digital pins 
....................  
....................  
.................... void GenerateDigitalOutput (int out_num, byte val) 
.................... { 
*
037E:  MOVLW  65
037F:  BSF    03.5
0380:  MOVWF  61
....................   byte* byte_to_write = &current_value.lower; 
....................    
....................  
....................   if (out_num >= 8) 
0381:  MOVF   5F,W
0382:  SUBLW  07
0383:  BTFSS  03.0
0384:  GOTO   387
0385:  BCF    03.5
0386:  GOTO   38C
0387:  BCF    03.5
....................     { 
....................     byte_to_write = &current_value.upper; 
0388:  MOVLW  64
0389:  BSF    03.5
038A:  MOVWF  61
038B:  BCF    03.5
....................     } 
....................    
....................   // now define the bit num 
....................   out_num %= 8; 
038C:  MOVLW  07
038D:  BSF    03.5
038E:  ANDWF  5F,F
....................  
.................... 	if (val > 63) 
038F:  MOVF   60,W
0390:  SUBLW  3F
0391:  BTFSS  03.0
0392:  GOTO   395
0393:  BCF    03.5
0394:  GOTO   3A9
0395:  BCF    03.5
.................... 		{ 
.................... 			bit_set (*byte_to_write, out_num); 
0396:  BSF    03.5
0397:  MOVF   61,W
0398:  MOVWF  04
0399:  MOVLW  01
039A:  MOVWF  77
039B:  MOVF   5F,W
039C:  MOVWF  78
039D:  BTFSS  03.2
039E:  GOTO   3A1
039F:  BCF    03.5
03A0:  GOTO   3A6
03A1:  BCF    03.5
03A2:  BCF    03.0
03A3:  RLF    77,F
03A4:  DECFSZ 78,F
03A5:  GOTO   3A2
03A6:  MOVF   77,W
03A7:  IORWF  00,F
.................... 		} 
.................... 	else 
03A8:  GOTO   3BC
.................... 		{ 
.................... 			bit_clear (*byte_to_write, out_num); 
03A9:  BSF    03.5
03AA:  MOVF   61,W
03AB:  MOVWF  04
03AC:  MOVLW  01
03AD:  MOVWF  77
03AE:  MOVF   5F,W
03AF:  MOVWF  78
03B0:  BTFSS  03.2
03B1:  GOTO   3B4
03B2:  BCF    03.5
03B3:  GOTO   3B9
03B4:  BCF    03.5
03B5:  BCF    03.0
03B6:  RLF    77,F
03B7:  DECFSZ 78,F
03B8:  GOTO   3B5
03B9:  MOVF   77,W
03BA:  XORLW  FF
03BB:  ANDWF  00,F
.................... 		} 
....................  
.................... 	Spi_write_data (&current_value, sizeof(current_value), DIGITAL_OUT_LATCH); 
03BC:  MOVLW  64
03BD:  BSF    03.5
03BE:  MOVWF  62
03BF:  MOVLW  02
03C0:  MOVWF  63
03C1:  MOVLW  42
03C2:  MOVWF  64
03C3:  BCF    03.5
*
041E:  RETLW  00
.................... } 
....................  
.................... void InitialiseDigitalOut() 
.................... { 
....................   current_value.upper = 0; 
*
115F:  CLRF   64
....................   current_value.lower = 0; 
1160:  CLRF   65
....................   GenerateDigitalOutput (0, 0); 
1161:  BSF    03.5
1162:  CLRF   5F
1163:  CLRF   60
1164:  BCF    03.5
1165:  BCF    0A.4
1166:  CALL   37E
1167:  BSF    0A.4
.................... } 
.................... 
.................... #include "sysex.h" 
....................  /*************************************************** 
.................... Module for decoding Incoming sysex messages 
....................  note that all messages must have a MSB of 0 
.................... **************************************************/ 
....................  
.................... #define MAX_MIDIDCONTROLLER_PARAMS 4 
....................  
.................... #ifndef MIDI_CONTROLLER_BUILD 
.................... typedef int int32; 
....................  
.................... #define MAX_PARAMS 256 
.................... void ProcessAcknowledge(); 
.................... #else 
.................... #define MAX_PARAMS MAX_MIDIDCONTROLLER_PARAMS 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef MIDI_CONTROLLER_BUILD 
.................... void ProcessreadConfigMsg(); 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
.................... 	int command_type; // the command type of this message 
.................... 	int config_index; // the start index 
.................... 	int32 byte_num; // the byte number of the byte coming in 
.................... 	int config_data_size; // the current index for config bytes 
.................... 	byte config_data [MAX_PARAMS]; 
....................  
.................... } STR_SYSEX_MSG; 
.................... 	 
.................... STR_SYSEX_MSG current_sysex_msg; 
....................  
....................  
....................  
.................... #pragma inline 
.................... void SetFactoryDefault() 
.................... { 
....................   byte i; 
....................    
....................   for (i = 0; i < 0xff; i++) 
*
0AFC:  BSF    03.5
0AFD:  CLRF   59
0AFE:  BCF    03.5
0AFF:  BSF    03.5
0B00:  INCFSZ 59,W
0B01:  GOTO   303
0B02:  GOTO   305
0B03:  BCF    03.5
0B04:  GOTO   307
0B05:  BCF    03.5
0B06:  GOTO   315
....................     { 
.................... #ifdef MIDI_CONTROLLER_BUILD 
....................     restart_wdt(); 
0B07:  CLRWDT
.................... #endif 
....................     WriteConfigByte (i, 0xff); 
0B08:  BSF    03.5
0B09:  MOVF   59,W
0B0A:  MOVWF  5C
0B0B:  MOVLW  FF
0B0C:  MOVWF  5D
0B0D:  BCF    03.5
0B0E:  BCF    0A.3
0B0F:  CALL   0A7
0B10:  BSF    0A.3
....................     } 
.................... #ifdef MIDI_CONTROLLER_BUILD 
0B11:  BSF    03.5
0B12:  INCF   59,F
0B13:  BCF    03.5
0B14:  GOTO   2FF
....................   while (1); // wait till we watchdog 
.................... #endif 
0B15:  GOTO   315
.................... } 
....................  
.................... #pragma inline 
.................... void ProcessReadConfigMsg() 
.................... { 
.................... 	byte i; // must be byte so will cycle around 0xff 
.................... #ifdef MIDI_CONTROLLER_BUILD 
.................... 	// now write the config 
....................   WriteSysexHeader(); 
*
0954:  BCF    0A.3
0955:  CALL   1C6
0956:  BSF    0A.3
....................  
.................... 	WriteSysexOutData (WRITE_CONGFIG_BYTE); 
0957:  MOVLW  01
0958:  BSF    03.5
0959:  MOVWF  5B
095A:  BCF    03.5
.................... #endif 
....................  
.................... 	i = (byte) current_sysex_msg.config_index; 
*
09B1:  MOVF   67,W
09B2:  BSF    03.5
09B3:  MOVWF  59
....................  
.................... #ifdef MIDI_CONTROLLER_BUILD 
....................   WriteSysexOutData (current_sysex_msg.config_index); 
09B4:  BCF    03.5
09B5:  MOVF   67,W
09B6:  BSF    03.5
09B7:  MOVWF  5B
09B8:  BCF    03.5
.................... 	WriteSysexOutData (ReadConfigByte (i)); 
*
0A0F:  BSF    03.5
0A10:  MOVF   59,W
0A11:  MOVWF  69
0A12:  BCF    03.5
*
0A20:  MOVF   78,W
0A21:  BSF    03.5
0A22:  MOVWF  5A
0A23:  MOVWF  5B
0A24:  BCF    03.5
.................... #endif 
....................  
....................  
....................   do 
.................... 	  { 
....................       i++;  
*
0A7B:  BSF    03.5
0A7C:  INCF   59,F
.................... #ifdef MIDI_CONTROLLER_BUILD 
.................... 			restart_wdt(); 
0A7D:  CLRWDT
.................... 			WriteSysexOutData (ReadConfigByte (i)); 
0A7E:  MOVF   59,W
0A7F:  MOVWF  69
0A80:  BCF    03.5
*
0A8E:  MOVF   78,W
0A8F:  BSF    03.5
0A90:  MOVWF  5A
0A91:  MOVWF  5B
0A92:  BCF    03.5
.................... #endif 
.................... 		} while (i != current_sysex_msg.config_data[0]); // end index 
....................  
.................... #ifdef MIDI_CONTROLLER_BUILD     
*
0AE9:  MOVF   6D,W
0AEA:  BSF    03.5
0AEB:  SUBWF  59,W
0AEC:  BTFSC  03.2
0AED:  GOTO   2F0
0AEE:  BCF    03.5
0AEF:  GOTO   27B
0AF0:  BCF    03.5
.................... 	WriteOutData (SYSEX_END); 
0AF1:  MOVLW  F7
0AF2:  BSF    03.5
0AF3:  MOVWF  5D
0AF4:  BCF    03.5
.................... #endif 
.................... }// end ProcessReadConfigMsg 
....................  
.................... #pragma inline 
.................... void ProcessWriteConfigMsg() 
.................... { 
.................... 	int i; 
....................  
.................... #ifdef MIDI_CONTROLLER_BUILD 
.................... 	disable_interrupts (GLOBAL); 
*
08C4:  BCF    0B.6
08C5:  BCF    0B.7
08C6:  BTFSC  0B.7
08C7:  GOTO   0C5
.................... #endif 
....................  
.................... 	for (i = 0; i < current_sysex_msg.config_data_size; i++) 
08C8:  BSF    03.5
08C9:  CLRF   59
08CA:  BCF    03.5
08CB:  MOVF   6C,W
08CC:  BSF    03.5
08CD:  SUBWF  59,W
08CE:  BTFSS  03.0
08CF:  GOTO   0D2
08D0:  BCF    03.5
08D1:  GOTO   0EA
08D2:  BCF    03.5
.................... 		{ 
.................... #ifdef MIDI_CONTROLLER_BUILD 
....................       restart_wdt(); 
08D3:  CLRWDT
.................... #endif 
.................... 			WriteConfigByte (i + current_sysex_msg.config_index,  
.................... 											 current_sysex_msg.config_data[i]); 
08D4:  MOVF   67,W
08D5:  BSF    03.5
08D6:  ADDWF  59,W
08D7:  MOVWF  5A
08D8:  MOVLW  07
08D9:  ADDWF  59,W
08DA:  ADDLW  66
08DB:  MOVWF  04
08DC:  MOVF   00,W
08DD:  MOVWF  5B
08DE:  MOVF   5A,W
08DF:  MOVWF  5C
08E0:  MOVF   5B,W
08E1:  MOVWF  5D
08E2:  BCF    03.5
08E3:  BCF    0A.3
08E4:  CALL   0A7
08E5:  BSF    0A.3
.................... 		} 
.................... #ifdef MIDI_CONTROLLER_BUILD 
08E6:  BSF    03.5
08E7:  INCF   59,F
08E8:  BCF    03.5
08E9:  GOTO   0CB
.................... 	enable_interrupts (GLOBAL); 
08EA:  MOVLW  C0
08EB:  IORWF  0B,F
....................  
....................   WriteSysexHeader(); 
08EC:  BCF    0A.3
08ED:  CALL   1C6
08EE:  BSF    0A.3
....................  
.................... 	WriteSysexOutData (WRITE_ACKNOWLEDGE); 
08EF:  MOVLW  03
08F0:  BSF    03.5
08F1:  MOVWF  5B
08F2:  BCF    03.5
....................  
.................... 	WriteOutData (SYSEX_END); 
*
0949:  MOVLW  F7
094A:  BSF    03.5
094B:  MOVWF  5D
094C:  BCF    03.5
....................  
.................... #endif //#ifdef MIDI_CONTROLLER_BUILD 
....................  
.................... } // end  ProcessWriteConfigMsg() 
....................  
....................  
.................... void ResetSysex() 
.................... { 
.................... 	current_sysex_msg.byte_num = 0; 
*
0895:  CLRF   6B
0896:  CLRF   6A
0897:  CLRF   69
0898:  CLRF   68
.................... 	current_sysex_msg.config_index = 0; 
0899:  CLRF   67
.................... 	current_sysex_msg.config_data_size = 0; 
089A:  CLRF   6C
.................... } 
....................  
.................... short DecodeSysexByte (byte byte_val) 
.................... { 
.................... 	short ret; 
.................... 	current_sysex_msg.byte_num++; 
*
0BC9:  INCF   68,F
0BCA:  BTFSC  03.2
0BCB:  INCF   69,F
0BCC:  BTFSC  03.2
0BCD:  INCF   6A,F
0BCE:  BTFSC  03.2
0BCF:  INCF   6B,F
....................  
....................  	switch (current_sysex_msg.byte_num) 
0BD0:  MOVF   68,W
0BD1:  MOVWF  77
0BD2:  MOVLW  01
0BD3:  SUBWF  77,W
0BD4:  BTFSC  03.2
0BD5:  GOTO   3E7
0BD6:  MOVLW  02
0BD7:  SUBWF  77,W
0BD8:  BTFSC  03.2
0BD9:  GOTO   3F7
0BDA:  MOVLW  03
0BDB:  SUBWF  77,W
0BDC:  BTFSC  03.2
0BDD:  GOTO   406
0BDE:  MOVLW  04
0BDF:  SUBWF  77,W
0BE0:  BTFSC  03.2
0BE1:  GOTO   421
0BE2:  MOVLW  05
0BE3:  SUBWF  77,W
0BE4:  BTFSC  03.2
0BE5:  GOTO   429
0BE6:  GOTO   432
.................... 		{ 
.................... 		case SYSEX_ID_NUM: 
.................... 			ret = (byte_val == SYSEX_ID); 
0BE7:  BSF    03.5
0BE8:  MOVF   58,W
0BE9:  SUBLW  7D
0BEA:  BTFSS  03.2
0BEB:  GOTO   3EE
0BEC:  BCF    03.5
0BED:  GOTO   3F3
0BEE:  BCF    03.5
0BEF:  BSF    03.5
0BF0:  BCF    59.0
0BF1:  BCF    03.5
0BF2:  GOTO   3F6
0BF3:  BSF    03.5
0BF4:  BSF    59.0
0BF5:  BCF    03.5
.................... 			break; 
0BF6:  GOTO   444
....................  
.................... 		case SYSEX_EQUIPMENT_NUM: 
.................... 			ret = (byte_val == EQUIPMENT_TYPE); 
0BF7:  BSF    03.5
0BF8:  MOVF   58,F
0BF9:  BTFSS  03.2
0BFA:  GOTO   3FD
0BFB:  BCF    03.5
0BFC:  GOTO   402
0BFD:  BCF    03.5
0BFE:  BSF    03.5
0BFF:  BCF    59.0
0C00:  BCF    03.5
0C01:  GOTO   405
0C02:  BSF    03.5
0C03:  BSF    59.0
0C04:  BCF    03.5
.................... 			break;  
0C05:  GOTO   444
....................  
.................... 		case SYSEX_DEVICE_NUM: 
.................... 			ret = (byte_val == ReadDeviceId() || byte_val == ANY_DEVICE_ID_NUM); 
0C06:  BCF    0A.3
0C07:  CALL   1AE
0C08:  BSF    0A.3
0C09:  MOVF   78,W
0C0A:  BSF    03.5
0C0B:  SUBWF  58,W
0C0C:  BTFSS  03.2
0C0D:  GOTO   410
0C0E:  BCF    03.5
0C0F:  GOTO   41D
0C10:  BCF    03.5
0C11:  BSF    03.5
0C12:  INCFSZ 58,W
0C13:  GOTO   415
0C14:  GOTO   417
0C15:  BCF    03.5
0C16:  GOTO   419
0C17:  BCF    03.5
0C18:  GOTO   41D
0C19:  BSF    03.5
0C1A:  BCF    59.0
0C1B:  BCF    03.5
0C1C:  GOTO   420
0C1D:  BSF    03.5
0C1E:  BSF    59.0
0C1F:  BCF    03.5
.................... 			break; 
0C20:  GOTO   444
....................  
.................... 		case SYSEX_COMMAND_NUM: 
.................... 			current_sysex_msg.command_type = byte_val; 
0C21:  BSF    03.5
0C22:  MOVF   58,W
0C23:  BCF    03.5
0C24:  MOVWF  66
....................       ret = true; 
0C25:  BSF    03.5
0C26:  BSF    59.0
.................... 			break; 
0C27:  BCF    03.5
0C28:  GOTO   444
....................  
.................... 		case SYSEX_CONGIG_INDEX_NUM: 
.................... 			current_sysex_msg.config_index = byte_val; 
0C29:  BSF    03.5
0C2A:  MOVF   58,W
0C2B:  BCF    03.5
0C2C:  MOVWF  67
....................       current_sysex_msg.config_data_size = 0; 
0C2D:  CLRF   6C
.................... 			ret = true; 
0C2E:  BSF    03.5
0C2F:  BSF    59.0
.................... 			break; 
0C30:  BCF    03.5
0C31:  GOTO   444
....................  
.................... 		default: 
.................... 			if (current_sysex_msg.config_data_size < MAX_PARAMS) 
0C32:  MOVF   6C,W
0C33:  SUBLW  03
0C34:  BTFSS  03.0
0C35:  GOTO   440
.................... 				{ 
.................... 					current_sysex_msg.config_data [current_sysex_msg.config_data_size]  
.................... 						= byte_val; 
0C36:  MOVLW  07
0C37:  ADDWF  6C,W
0C38:  ADDLW  66
0C39:  MOVWF  04
0C3A:  BSF    03.5
0C3B:  MOVF   58,W
0C3C:  MOVWF  00
.................... 					ret = true; 
0C3D:  BSF    59.0
.................... 				} 
.................... 			else 
0C3E:  BCF    03.5
0C3F:  GOTO   443
.................... 				{ 
.................... 					ret = false; 
0C40:  BSF    03.5
0C41:  BCF    59.0
0C42:  BCF    03.5
.................... 				} 
....................  
.................... 			current_sysex_msg.config_data_size++; 
0C43:  INCF   6C,F
....................  
.................... 		} // end case 
....................  
....................  
.................... 	return ret; 
0C44:  MOVLW  00
0C45:  BSF    03.5
0C46:  BTFSC  59.0
0C47:  MOVLW  01
0C48:  MOVWF  78
0C49:  BCF    03.5
.................... } // end DecodeSysexByte 
....................  
.................... void ExecuteSysexMessage() 
.................... { 
.................... 	switch (current_sysex_msg.command_type) 
*
08B6:  MOVF   66,W
08B7:  MOVWF  77
08B8:  MOVLW  01
08B9:  SUBWF  77,W
08BA:  BTFSC  03.2
08BB:  GOTO   0C4
08BC:  MOVF   77,W
08BD:  BTFSC  03.2
08BE:  GOTO   154
08BF:  MOVLW  02
08C0:  SUBWF  77,W
08C1:  BTFSC  03.2
08C2:  GOTO   2FC
08C3:  GOTO   317
.................... 		{  
.................... 		case WRITE_CONGFIG_BYTE: 
.................... 			ProcessWriteConfigMsg(); 
.................... 			break; 
*
0953:  GOTO   318
.................... 			 
.................... 		case READ_CONFIG_BYTE: 
.................... 			 
.................... 			ProcessReadConfigMsg(); 
.................... 			break; 
*
0AFB:  GOTO   318
....................  
.................... 		case FACTORY_DEFAULT: // we will never return 
.................... 			SetFactoryDefault(); 
.................... 			break; 
*
0B16:  GOTO   318
....................  
.................... #ifndef MIDI_CONTROLLER_BUILD       
....................     case WRITE_ACKNOWLEDGE: 
....................       ProcessAcknowledge(); 
....................       break; 
.................... #endif 
.................... 		default: 
....................       break; 
0B17:  GOTO   318
.................... 		} 
.................... } // end ExecuteSysexMessage() 
....................  
....................  
....................  
.................... 
.................... #include "anain.h" 
....................  /********************************************************************* 
.................... Module defines functions used for Reading Analogue In 
.................... *********************************************************************/ 
.................... #define NUM_ANA_READS 4 
....................  
.................... typedef struct 
.................... { 
.................... 	int current_chan :5; 
.................... 	int current_scan:3; 
.................... }str_ana_state; 
....................  
.................... int current_analogue_val[NUM_ANALOGUE_IN_CHANS]; 
....................  
.................... int16 current_analogue_bit0; 
.................... int16 current_analogue_bit1; 
....................  
.................... str_ana_state current_ana_state; // make a global so we don't use up the RAM and increase speed 
....................  
.................... void ReadAnalogueIn(short produce_output); 
.................... int16 ScaleAnalogValue (int channel, int16 value); 
....................  
....................  
.................... #inline 
.................... int16 ReadStoredAna ()  
.................... { 
*
1973:  BSF    03.5
1974:  CLRF   3E
1975:  CLRF   3F
.................... 	int16 ret = 0; 
....................  
....................  	ret = current_analogue_val [current_ana_state.current_chan]; 
1976:  MOVF   75,W
1977:  ANDLW  1F
1978:  ADDLW  A0
1979:  MOVWF  04
197A:  MOVF   00,W
197B:  CLRF   7A
197C:  MOVWF  3E
197D:  MOVF   7A,W
197E:  MOVWF  3F
.................... 	ret <<= 2; 
197F:  BCF    03.0
1980:  RLF    3E,F
1981:  RLF    3F,F
1982:  RLF    3E,F
1983:  RLF    3F,F
1984:  MOVLW  FC
1985:  ANDWF  3E,F
.................... 	if (bit_test (current_analogue_bit1, current_ana_state.current_chan)) 
1986:  MOVF   75,W
1987:  ANDLW  1F
1988:  MOVWF  40
1989:  MOVF   74,W
198A:  MOVWF  7B
198B:  MOVF   73,W
198C:  MOVWF  7A
198D:  MOVF   40,W
198E:  MOVWF  77
198F:  BTFSS  03.2
1990:  GOTO   193
1991:  BCF    03.5
1992:  GOTO   199
1993:  BCF    03.5
1994:  BCF    03.0
1995:  RRF    7B,F
1996:  RRF    7A,F
1997:  DECFSZ 77,F
1998:  GOTO   194
1999:  BTFSS  7A.0
199A:  GOTO   19E
.................... 	{ 
.................... 		bit_set(ret, 1); 
199B:  BSF    03.5
199C:  BSF    3E.1
199D:  BCF    03.5
.................... 	} 
....................  
.................... 	if (bit_test (current_analogue_bit0, current_ana_state.current_chan)) 
199E:  MOVF   75,W
199F:  ANDLW  1F
19A0:  BSF    03.5
19A1:  MOVWF  40
19A2:  MOVF   72,W
19A3:  MOVWF  7B
19A4:  MOVF   71,W
19A5:  MOVWF  7A
19A6:  MOVF   40,W
19A7:  MOVWF  77
19A8:  BTFSS  03.2
19A9:  GOTO   1AC
19AA:  BCF    03.5
19AB:  GOTO   1B2
19AC:  BCF    03.5
19AD:  BCF    03.0
19AE:  RRF    7B,F
19AF:  RRF    7A,F
19B0:  DECFSZ 77,F
19B1:  GOTO   1AD
19B2:  BTFSS  7A.0
19B3:  GOTO   1B7
.................... 	{ 
.................... 		bit_set(ret, 0); 
19B4:  BSF    03.5
19B5:  BSF    3E.0
19B6:  BCF    03.5
.................... 	} 
....................  
.................... 	return ret; 
19B7:  BSF    03.5
19B8:  MOVF   3E,W
19B9:  MOVWF  78
19BA:  MOVF   3F,W
19BB:  MOVWF  79
19BC:  BCF    03.5
.................... } 
....................  
.................... #inline 
.................... void WriteStoredAna (int16 value) 
.................... { 
.................... 	if (bit_test(value, 0)) 
*
1E45:  BSF    03.5
1E46:  BTFSC  3E.0
1E47:  GOTO   64A
1E48:  BCF    03.5
1E49:  GOTO   663
1E4A:  BCF    03.5
*
1ED2:  BSF    03.5
1ED3:  BTFSC  3E.0
1ED4:  GOTO   6D7
1ED5:  BCF    03.5
1ED6:  GOTO   6F0
1ED7:  BCF    03.5
.................... 	{ 
.................... 		bit_set (current_analogue_bit0, current_ana_state.current_chan); 
*
1E4B:  MOVF   75,W
1E4C:  ANDLW  1F
1E4D:  BSF    03.5
1E4E:  MOVWF  40
1E4F:  CLRF   7A
1E50:  MOVLW  01
1E51:  MOVWF  79
1E52:  MOVF   40,W
1E53:  MOVWF  77
1E54:  BTFSS  03.2
1E55:  GOTO   658
1E56:  BCF    03.5
1E57:  GOTO   65E
1E58:  BCF    03.5
1E59:  BCF    03.0
1E5A:  RLF    79,F
1E5B:  RLF    7A,F
1E5C:  DECFSZ 77,F
1E5D:  GOTO   659
1E5E:  MOVF   79,W
1E5F:  IORWF  71,F
1E60:  MOVF   7A,W
1E61:  IORWF  72,F
*
1ED8:  MOVF   75,W
1ED9:  ANDLW  1F
1EDA:  BSF    03.5
1EDB:  MOVWF  40
1EDC:  CLRF   7A
1EDD:  MOVLW  01
1EDE:  MOVWF  79
1EDF:  MOVF   40,W
1EE0:  MOVWF  77
1EE1:  BTFSS  03.2
1EE2:  GOTO   6E5
1EE3:  BCF    03.5
1EE4:  GOTO   6EB
1EE5:  BCF    03.5
1EE6:  BCF    03.0
1EE7:  RLF    79,F
1EE8:  RLF    7A,F
1EE9:  DECFSZ 77,F
1EEA:  GOTO   6E6
1EEB:  MOVF   79,W
1EEC:  IORWF  71,F
1EED:  MOVF   7A,W
1EEE:  IORWF  72,F
.................... 	} 
.................... 	else 
*
1E62:  GOTO   67F
*
1EEF:  GOTO   70C
.................... 	{ 
.................... 		bit_clear (current_analogue_bit0, current_ana_state.current_chan); 
*
1E63:  MOVF   75,W
1E64:  ANDLW  1F
1E65:  BSF    03.5
1E66:  MOVWF  40
1E67:  CLRF   7A
1E68:  MOVLW  01
1E69:  MOVWF  79
1E6A:  MOVF   40,W
1E6B:  MOVWF  77
1E6C:  BTFSS  03.2
1E6D:  GOTO   670
1E6E:  BCF    03.5
1E6F:  GOTO   676
1E70:  BCF    03.5
1E71:  BCF    03.0
1E72:  RLF    79,F
1E73:  RLF    7A,F
1E74:  DECFSZ 77,F
1E75:  GOTO   671
1E76:  MOVF   79,W
1E77:  XORLW  FF
1E78:  MOVWF  77
1E79:  MOVLW  FF
1E7A:  XORWF  7A,F
1E7B:  MOVF   77,W
1E7C:  ANDWF  71,F
1E7D:  MOVF   7A,W
1E7E:  ANDWF  72,F
*
1EF0:  MOVF   75,W
1EF1:  ANDLW  1F
1EF2:  BSF    03.5
1EF3:  MOVWF  40
1EF4:  CLRF   7A
1EF5:  MOVLW  01
1EF6:  MOVWF  79
1EF7:  MOVF   40,W
1EF8:  MOVWF  77
1EF9:  BTFSS  03.2
1EFA:  GOTO   6FD
1EFB:  BCF    03.5
1EFC:  GOTO   703
1EFD:  BCF    03.5
1EFE:  BCF    03.0
1EFF:  RLF    79,F
1F00:  RLF    7A,F
1F01:  DECFSZ 77,F
1F02:  GOTO   6FE
1F03:  MOVF   79,W
1F04:  XORLW  FF
1F05:  MOVWF  77
1F06:  MOVLW  FF
1F07:  XORWF  7A,F
1F08:  MOVF   77,W
1F09:  ANDWF  71,F
1F0A:  MOVF   7A,W
1F0B:  ANDWF  72,F
.................... 	} 
....................  
.................... 	if (bit_test(value, 1)) 
*
1E7F:  BSF    03.5
1E80:  BTFSC  3E.1
1E81:  GOTO   684
1E82:  BCF    03.5
1E83:  GOTO   69D
1E84:  BCF    03.5
*
1F0C:  BSF    03.5
1F0D:  BTFSC  3E.1
1F0E:  GOTO   711
1F0F:  BCF    03.5
1F10:  GOTO   72A
1F11:  BCF    03.5
.................... 	{ 
.................... 		bit_set (current_analogue_bit1, current_ana_state.current_chan); 
*
1E85:  MOVF   75,W
1E86:  ANDLW  1F
1E87:  BSF    03.5
1E88:  MOVWF  40
1E89:  CLRF   7A
1E8A:  MOVLW  01
1E8B:  MOVWF  79
1E8C:  MOVF   40,W
1E8D:  MOVWF  77
1E8E:  BTFSS  03.2
1E8F:  GOTO   692
1E90:  BCF    03.5
1E91:  GOTO   698
1E92:  BCF    03.5
1E93:  BCF    03.0
1E94:  RLF    79,F
1E95:  RLF    7A,F
1E96:  DECFSZ 77,F
1E97:  GOTO   693
1E98:  MOVF   79,W
1E99:  IORWF  73,F
1E9A:  MOVF   7A,W
1E9B:  IORWF  74,F
*
1F12:  MOVF   75,W
1F13:  ANDLW  1F
1F14:  BSF    03.5
1F15:  MOVWF  40
1F16:  CLRF   7A
1F17:  MOVLW  01
1F18:  MOVWF  79
1F19:  MOVF   40,W
1F1A:  MOVWF  77
1F1B:  BTFSS  03.2
1F1C:  GOTO   71F
1F1D:  BCF    03.5
1F1E:  GOTO   725
1F1F:  BCF    03.5
1F20:  BCF    03.0
1F21:  RLF    79,F
1F22:  RLF    7A,F
1F23:  DECFSZ 77,F
1F24:  GOTO   720
1F25:  MOVF   79,W
1F26:  IORWF  73,F
1F27:  MOVF   7A,W
1F28:  IORWF  74,F
.................... 	} 
.................... 	else 
*
1E9C:  GOTO   6B9
*
1F29:  GOTO   746
.................... 	{ 
.................... 		bit_clear (current_analogue_bit1, current_ana_state.current_chan); 
*
1E9D:  MOVF   75,W
1E9E:  ANDLW  1F
1E9F:  BSF    03.5
1EA0:  MOVWF  40
1EA1:  CLRF   7A
1EA2:  MOVLW  01
1EA3:  MOVWF  79
1EA4:  MOVF   40,W
1EA5:  MOVWF  77
1EA6:  BTFSS  03.2
1EA7:  GOTO   6AA
1EA8:  BCF    03.5
1EA9:  GOTO   6B0
1EAA:  BCF    03.5
1EAB:  BCF    03.0
1EAC:  RLF    79,F
1EAD:  RLF    7A,F
1EAE:  DECFSZ 77,F
1EAF:  GOTO   6AB
1EB0:  MOVF   79,W
1EB1:  XORLW  FF
1EB2:  MOVWF  77
1EB3:  MOVLW  FF
1EB4:  XORWF  7A,F
1EB5:  MOVF   77,W
1EB6:  ANDWF  73,F
1EB7:  MOVF   7A,W
1EB8:  ANDWF  74,F
*
1F2A:  MOVF   75,W
1F2B:  ANDLW  1F
1F2C:  BSF    03.5
1F2D:  MOVWF  40
1F2E:  CLRF   7A
1F2F:  MOVLW  01
1F30:  MOVWF  79
1F31:  MOVF   40,W
1F32:  MOVWF  77
1F33:  BTFSS  03.2
1F34:  GOTO   737
1F35:  BCF    03.5
1F36:  GOTO   73D
1F37:  BCF    03.5
1F38:  BCF    03.0
1F39:  RLF    79,F
1F3A:  RLF    7A,F
1F3B:  DECFSZ 77,F
1F3C:  GOTO   738
1F3D:  MOVF   79,W
1F3E:  XORLW  FF
1F3F:  MOVWF  77
1F40:  MOVLW  FF
1F41:  XORWF  7A,F
1F42:  MOVF   77,W
1F43:  ANDWF  73,F
1F44:  MOVF   7A,W
1F45:  ANDWF  74,F
.................... 	} 
....................  
.................... 	value >>=2; 
*
1EB9:  BCF    03.0
1EBA:  BSF    03.5
1EBB:  RRF    3F,F
1EBC:  RRF    3E,F
1EBD:  RRF    3F,F
1EBE:  RRF    3E,F
1EBF:  MOVLW  3F
1EC0:  ANDWF  3F,F
*
1F46:  BCF    03.0
1F47:  BSF    03.5
1F48:  RRF    3F,F
1F49:  RRF    3E,F
1F4A:  RRF    3F,F
1F4B:  RRF    3E,F
1F4C:  MOVLW  3F
1F4D:  ANDWF  3F,F
.................... 	current_analogue_val [current_ana_state.current_chan] = (int) value; 
*
1EC1:  MOVF   75,W
1EC2:  ANDLW  1F
1EC3:  ADDLW  A0
1EC4:  MOVWF  04
1EC5:  MOVF   3E,W
1EC6:  MOVWF  00
1EC7:  BCF    03.5
*
1F4E:  MOVF   75,W
1F4F:  ANDLW  1F
1F50:  ADDLW  A0
1F51:  MOVWF  04
1F52:  MOVF   3E,W
1F53:  MOVWF  00
1F54:  BCF    03.5
.................... } 
....................  
.................... // initialise the previous analogue in values 
.................... // Sets RA0, RA1 and RA3 as analogue inputs 
.................... // Sets the B1 to B3 as Outputs 
.................... #USE FAST_IO(B) 
....................  
.................... #define CLEAR_BANK_MASK 0b11110001 // ANDing Mask will clear bits 1-3 
.................... void InitialiseAnalogueIn() 
.................... { 
.................... 	int i; 
....................  
.................... 	setup_adc (ADC_CLOCK_INTERNAL); 
*
1135:  MOVF   1F,W
1136:  ANDLW  38
1137:  IORLW  C1
1138:  MOVWF  1F
.................... 	setup_adc_ports (RA0_RA1_ANALOG_RA3_REF); 
1139:  MOVLW  85
113A:  BSF    03.5
113B:  MOVWF  1F
.................... 	current_ana_state.current_chan = 0; 
113C:  MOVLW  E0
113D:  ANDWF  75,W
113E:  MOVWF  75
.................... 	set_tris_b (CLEAR_BANK_MASK); 
113F:  MOVLW  F1
1140:  MOVWF  06
....................  
.................... 	current_analogue_bit0 = 0; 
1141:  CLRF   72
1142:  CLRF   71
.................... 	current_analogue_bit1 = 0; 
1143:  CLRF   74
1144:  CLRF   73
....................  
....................  	for (i = 0; i < NUM_ANALOGUE_IN_CHANS; i++) 
1145:  CLRF   35
1146:  BCF    03.5
1147:  BSF    03.5
1148:  MOVF   35,W
1149:  SUBLW  0F
114A:  BTFSC  03.0
114B:  GOTO   14E
114C:  BCF    03.5
114D:  GOTO   159
114E:  BCF    03.5
....................  		{ 
....................  			current_analogue_val[i] = 0; 
114F:  MOVLW  A0
1150:  BSF    03.5
1151:  ADDWF  35,W
1152:  MOVWF  04
1153:  CLRF   00
1154:  BCF    03.5
....................  		} 
1155:  BSF    03.5
1156:  INCF   35,F
1157:  BCF    03.5
1158:  GOTO   147
....................  
.................... } 
....................  
.................... // reads the analogue in and produces output if different 
.................... short ProcessAnalogueIn() 
.................... { 
.................... 	return ReadAnalogueIn (true); 
*
1800:  MOVLW  01
1801:  BSF    03.5
1802:  MOVWF  35
1803:  BCF    03.5
*
1F5B:  MOVF   78,W
1F5C:  BCF    0A.3
1F5D:  BSF    0A.4
1F5E:  GOTO   415 (RETURN)
.................... } 
....................  
....................  
.................... void SetAnaChannel() 
.................... { 
.................... 	int bank_num; 
....................  
.................... 	bank_num = current_ana_state.current_chan / 8; 
*
06BE:  MOVF   75,W
06BF:  ANDLW  1F
06C0:  MOVWF  77
06C1:  BCF    03.0
06C2:  RRF    77,W
06C3:  BSF    03.5
06C4:  MOVWF  35
06C5:  RRF    35,F
06C6:  RRF    35,F
06C7:  MOVLW  1F
06C8:  ANDWF  35,F
....................  
.................... 	output_bit (PIN_B1, bit_test(current_ana_state.current_chan, 0)); 
06C9:  MOVF   75,W
06CA:  ANDLW  1F
06CB:  MOVWF  36
06CC:  BTFSS  36.0
06CD:  GOTO   6D0
06CE:  BCF    03.5
06CF:  GOTO   6D3
06D0:  BCF    03.5
06D1:  BCF    06.1
06D2:  GOTO   6D4
06D3:  BSF    06.1
.................... 	output_bit (PIN_B2, bit_test(current_ana_state.current_chan, 1)); 
06D4:  MOVF   75,W
06D5:  ANDLW  1F
06D6:  BSF    03.5
06D7:  MOVWF  36
06D8:  BTFSS  36.1
06D9:  GOTO   6DC
06DA:  BCF    03.5
06DB:  GOTO   6DF
06DC:  BCF    03.5
06DD:  BCF    06.2
06DE:  GOTO   6E0
06DF:  BSF    06.2
.................... 	output_bit (PIN_B3, bit_test(current_ana_state.current_chan, 2)); 
06E0:  MOVF   75,W
06E1:  ANDLW  1F
06E2:  BSF    03.5
06E3:  MOVWF  36
06E4:  BTFSS  36.2
06E5:  GOTO   6E8
06E6:  BCF    03.5
06E7:  GOTO   6EB
06E8:  BCF    03.5
06E9:  BCF    06.3
06EA:  GOTO   6EC
06EB:  BSF    06.3
.................... 	delay_us (AD_SWITCH_DELAY); 
06EC:  NOP
06ED:  NOP
06EE:  NOP
06EF:  NOP
06F0:  NOP
....................  
.................... 	set_adc_channel (bank_num); 
06F1:  BCF    03.0
06F2:  BSF    03.5
06F3:  RLF    35,W
06F4:  MOVWF  77
06F5:  RLF    77,F
06F6:  RLF    77,F
06F7:  MOVLW  F8
06F8:  ANDWF  77,F
06F9:  MOVF   77,W
06FA:  MOVWF  78
06FB:  BCF    03.5
06FC:  MOVF   1F,W
06FD:  ANDLW  C7
06FE:  IORWF  78,W
06FF:  MOVWF  1F
.................... 	delay_us (AD_READ_DELAY); 
0700:  MOVLW  21
0701:  MOVWF  77
0702:  DECFSZ 77,F
0703:  GOTO   702
0704:  BCF    0A.3
0705:  BSF    0A.4
0706:  GOTO   40B (RETURN)
....................  
.................... } 
....................  
.................... #inline 
.................... int16 ReadAnaValue() 
.................... { 
*
1813:  BSF    03.5
1814:  CLRF   3E
1815:  CLRF   3F
.................... 	int16 ret = 0; 
.................... 	 
.................... 	ret = read_adc(); 
1816:  BCF    03.5
1817:  BSF    1F.2
1818:  BTFSC  1F.2
1819:  GOTO   018
181A:  MOVF   1E,W
181B:  MOVWF  7A
181C:  BSF    03.5
181D:  MOVF   1E,W
181E:  MOVWF  3E
181F:  MOVF   7A,W
1820:  MOVWF  3F
....................  
.................... 	return ret; 
1821:  MOVF   3E,W
1822:  MOVWF  78
1823:  MOVF   3F,W
1824:  MOVWF  79
1825:  BCF    03.5
.................... } 
....................  
.................... // if produce_output is true, the result will be sent to the output  
.................... // if different from previous value 
.................... // Must make a call to SetAnaChannel First 
.................... short ReadAnalogueIn(short produce_output) 
.................... { 
....................   short ret = false; 
.................... 	 
....................  
.................... 	int16 adc_val, last_output; 
.................... 	int ana_reads; 
*
1804:  BSF    03.5
1805:  BCF    36.0
1806:  CLRF   3C
1807:  CLRF   3D
.................... 	int16 accum_store = 0; // use this as an accumulator to condition the value 
....................  
.................... 			ana_reads = NUM_ANA_READS;	 
1808:  MOVLW  04
1809:  MOVWF  3B
.................... 			restart_wdt(); 
180A:  CLRWDT
180B:  BCF    03.5
....................  
.................... 			while (ana_reads) 
180C:  BSF    03.5
180D:  MOVF   3B,F
180E:  BTFSS  03.2
180F:  GOTO   012
1810:  BCF    03.5
1811:  GOTO   033
1812:  BCF    03.5
.................... 			{	 
.................... #ifdef IOCARD_BUILD 
.................... 				if (MessageWaiting()) 
.................... 					{ 
.................... 						ret = ProcessPlaInputStream();  
.................... 					} 
....................  
.................... #endif 
.................... 				adc_val = ReadAnaValue(); 
*
1826:  MOVF   79,W
1827:  BSF    03.5
1828:  MOVWF  38
1829:  MOVF   78,W
182A:  MOVWF  37
....................  
.................... 				accum_store += adc_val; 
182B:  ADDWF  3C,F
182C:  BTFSC  03.0
182D:  INCF   3D,F
182E:  MOVF   38,W
182F:  ADDWF  3D,F
.................... 				ana_reads--; 
1830:  DECF   3B,F
.................... 			} //end while ana_reads 
1831:  BCF    03.5
1832:  GOTO   00C
....................  
.................... 			accum_store /= NUM_ANA_READS; 
1833:  BCF    03.0
1834:  BSF    03.5
1835:  RRF    3D,F
1836:  RRF    3C,F
1837:  RRF    3D,F
1838:  RRF    3C,F
1839:  MOVLW  3F
183A:  ANDWF  3D,F
.................... 			 
.................... 			adc_val = accum_store; 
183B:  MOVF   3D,W
183C:  MOVWF  38
183D:  MOVF   3C,W
183E:  MOVWF  37
....................  
.................... 			adc_val = ScaleAnalogValue (current_ana_state.current_chan, adc_val); 
183F:  MOVF   75,W
1840:  ANDLW  1F
1841:  MOVWF  3E
1842:  MOVWF  3F
1843:  MOVF   38,W
1844:  MOVWF  41
1845:  MOVF   37,W
1846:  MOVWF  40
1847:  BCF    03.5
*
196D:  MOVF   79,W
196E:  BSF    03.5
196F:  MOVWF  38
1970:  MOVF   78,W
1971:  MOVWF  37
1972:  BCF    03.5
....................  
....................  
.................... 			// see if this read and last matched 
....................  
.................... 			last_output = ReadStoredAna(); 
*
19BD:  MOVF   79,W
19BE:  BSF    03.5
19BF:  MOVWF  3A
19C0:  MOVF   78,W
19C1:  MOVWF  39
19C2:  BCF    03.5
....................  
.................... 			if (InQueueEmpty()) //InQueueEmpty() 
*
19CB:  MOVF   78,F
19CC:  BTFSC  03.2
19CD:  GOTO   755
.................... 				{ 
....................  
.................... 				if (produce_output && last_output != adc_val) 
19CE:  BSF    03.5
19CF:  MOVF   35,F
19D0:  BTFSS  03.2
19D1:  GOTO   1D4
19D2:  BCF    03.5
19D3:  GOTO   6CC
19D4:  BCF    03.5
19D5:  BSF    03.5
19D6:  MOVF   37,W
19D7:  SUBWF  39,W
19D8:  BTFSC  03.2
19D9:  GOTO   1DC
19DA:  BCF    03.5
19DB:  GOTO   1E5
19DC:  BCF    03.5
19DD:  BSF    03.5
19DE:  MOVF   38,W
19DF:  SUBWF  3A,W
19E0:  BTFSS  03.2
19E1:  GOTO   1E4
19E2:  BCF    03.5
19E3:  GOTO   6CC
19E4:  BCF    03.5
.................... 						{ 
.................... 							if (OutputAnalog (current_ana_state.current_chan, adc_val)) 
19E5:  MOVF   75,W
19E6:  ANDLW  1F
19E7:  BSF    03.5
19E8:  MOVWF  3E
19E9:  MOVWF  3F
19EA:  MOVF   38,W
19EB:  MOVWF  41
19EC:  MOVF   37,W
19ED:  MOVWF  40
19EE:  BCF    03.5
*
1E3C:  MOVF   78,F
1E3D:  BTFSC  03.2
1E3E:  GOTO   6CB
.................... 								{ 
.................... 								// move data up to smooth	 
.................... 								WriteStoredAna (adc_val); 
1E3F:  BSF    03.5
1E40:  MOVF   38,W
1E41:  MOVWF  3F
1E42:  MOVF   37,W
1E43:  MOVWF  3E
1E44:  BCF    03.5
.................... 								ret = true; 
*
1EC8:  BSF    03.5
1EC9:  BSF    36.0
1ECA:  BCF    03.5
.................... 								} 
.................... 						} 
.................... 					else 
1ECB:  GOTO   755
.................... 						{ 
.................... 							WriteStoredAna (adc_val); 
1ECC:  BSF    03.5
1ECD:  MOVF   38,W
1ECE:  MOVWF  3F
1ECF:  MOVF   37,W
1ED0:  MOVWF  3E
1ED1:  BCF    03.5
.................... 						} 
.................... 				} 
....................   return ret; 
*
1F55:  MOVLW  00
1F56:  BSF    03.5
1F57:  BTFSC  36.0
1F58:  MOVLW  01
1F59:  MOVWF  78
1F5A:  BCF    03.5
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... 
.................... #include "digin.h" 
....................  /****************************************************************************** 
.................... Module for processing Digital Inputs 
.................... ******************************************************************************/ 
.................... // digital Read variables 
.................... int16 prev_digital_val; 
.................... int16 current_digital_val; 
....................  
....................  
.................... short ProcessDigitalInputs(int produce_output) 
.................... { 
....................   short ret = false; 
.................... 	int bit_num; 
.................... 	int byte_num; 
.................... 	byte *cur_val = &current_digital_val; 
*
0447:  BSF    03.5
0448:  BCF    36.0
0449:  MOVLW  B0
044A:  MOVWF  39
044B:  MOVLW  7C
044C:  MOVWF  3A
.................... 	byte *prev_val = &prev_digital_val; 
....................  
.................... 	current_digital_val = 0; 
044D:  CLRF   31
044E:  CLRF   30
....................  
.................... 	Spi_read_data (&current_digital_val, sizeof(current_digital_val), DIGITAL_IN_DATA); 
044F:  MOVLW  B0
0450:  MOVWF  3B
0451:  MOVLW  02
0452:  MOVWF  3C
0453:  MOVLW  3C
0454:  MOVWF  3D
0455:  BCF    03.5
....................  
.................... 	if (current_digital_val != prev_digital_val) 
*
04CC:  MOVF   7C,W
04CD:  BSF    03.5
04CE:  SUBWF  30,W
04CF:  BTFSC  03.2
04D0:  GOTO   4D3
04D1:  BCF    03.5
04D2:  GOTO   4DC
04D3:  BCF    03.5
04D4:  MOVF   7D,W
04D5:  BSF    03.5
04D6:  SUBWF  31,W
04D7:  BTFSS  03.2
04D8:  GOTO   4DB
04D9:  BCF    03.5
04DA:  GOTO   6A1
04DB:  BCF    03.5
.................... 		{ 
.................... 			if (produce_output) 
04DC:  BSF    03.5
04DD:  MOVF   35,F
04DE:  BTFSS  03.2
04DF:  GOTO   4E2
04E0:  BCF    03.5
04E1:  GOTO   6A1
04E2:  BCF    03.5
.................... 				{ 
....................           // iterate through each byte 
.................... 					for (byte_num = 0; byte_num < sizeof(current_digital_val); byte_num++) 
04E3:  BSF    03.5
04E4:  CLRF   38
04E5:  BCF    03.5
04E6:  BSF    03.5
04E7:  MOVF   38,W
04E8:  SUBLW  01
04E9:  BTFSC  03.0
04EA:  GOTO   4ED
04EB:  BCF    03.5
04EC:  GOTO   6A1
04ED:  BCF    03.5
.................... 						{ 
.................... 							// iterate through each bit 
.................... 							for (bit_num = 0; bit_num < 8; bit_num++) 
04EE:  BSF    03.5
04EF:  CLRF   37
04F0:  BCF    03.5
04F1:  BSF    03.5
04F2:  MOVF   37,W
04F3:  SUBLW  07
04F4:  BTFSC  03.0
04F5:  GOTO   4F8
04F6:  BCF    03.5
04F7:  GOTO   69D
04F8:  BCF    03.5
.................... 								{ 
.................... #ifdef IOCARD_BUILD 
....................                 if (MessageWaiting()) 
....................                   { 
....................                     ProcessPlaInputStream();  
....................                     ret = true; 
....................                   } 
.................... #endif 
.................... 									if (Bit_test (cur_val[byte_num], bit_num)  
.................... 											!= bit_test(prev_val[byte_num], bit_num)) 
04F9:  BSF    03.5
04FA:  MOVF   39,W
04FB:  ADDWF  38,W
04FC:  MOVWF  04
04FD:  MOVF   00,W
04FE:  MOVWF  3B
04FF:  MOVWF  77
0500:  MOVF   37,W
0501:  MOVWF  78
0502:  BTFSS  03.2
0503:  GOTO   506
0504:  BCF    03.5
0505:  GOTO   50B
0506:  BCF    03.5
0507:  BCF    03.0
0508:  RRF    77,F
0509:  DECFSZ 78,F
050A:  GOTO   507
050B:  MOVLW  00
050C:  BTFSC  77.0
050D:  MOVLW  01
050E:  BSF    03.5
050F:  MOVWF  3C
0510:  MOVF   3A,W
0511:  ADDWF  38,W
0512:  MOVWF  04
0513:  MOVF   00,W
0514:  MOVWF  3D
0515:  MOVWF  77
0516:  MOVF   37,W
0517:  MOVWF  78
0518:  BTFSS  03.2
0519:  GOTO   51C
051A:  BCF    03.5
051B:  GOTO   521
051C:  BCF    03.5
051D:  BCF    03.0
051E:  RRF    77,F
051F:  DECFSZ 78,F
0520:  GOTO   51D
0521:  MOVLW  00
0522:  BTFSC  77.0
0523:  MOVLW  01
0524:  BSF    03.5
0525:  SUBWF  3C,W
0526:  BTFSS  03.2
0527:  GOTO   52A
0528:  BCF    03.5
0529:  GOTO   699
052A:  BCF    03.5
.................... 										{ 
.................... 											// we use this fancy calculation because of the endian of an int16 
.................... 											// we want the first byte to be the high order byte 
....................                       // also, a one will produce a zero ouitput 
.................... 											if (OutputDigital ((sizeof(current_digital_val)-1 - byte_num) * 8 + bit_num,  
.................... 																				 (!Bit_test (cur_val[byte_num], bit_num)) * DIG_ON_VAL)) 
052B:  BSF    03.5
052C:  MOVF   38,W
052D:  SUBLW  01
052E:  MOVWF  77
052F:  BCF    03.0
0530:  RLF    77,F
0531:  RLF    77,F
0532:  RLF    77,F
0533:  MOVLW  F8
0534:  ANDWF  77,F
0535:  MOVF   77,W
0536:  ADDWF  37,W
0537:  MOVWF  3D
0538:  MOVF   39,W
0539:  ADDWF  38,W
053A:  MOVWF  04
053B:  MOVF   00,W
053C:  MOVWF  3E
053D:  MOVWF  77
053E:  MOVF   37,W
053F:  MOVWF  78
0540:  BTFSS  03.2
0541:  GOTO   544
0542:  BCF    03.5
0543:  GOTO   549
0544:  BCF    03.5
0545:  BCF    03.0
0546:  RRF    77,F
0547:  DECFSZ 78,F
0548:  GOTO   545
0549:  MOVLW  00
054A:  BTFSS  77.0
054B:  MOVLW  01
054C:  BSF    03.5
054D:  MOVWF  40
054E:  MOVWF  41
054F:  MOVLW  7F
0550:  MOVWF  42
0551:  BCF    03.5
0552:  GOTO   110
0553:  MOVF   78,W
0554:  BSF    03.5
0555:  MOVWF  41
0556:  MOVF   3D,W
0557:  MOVWF  42
0558:  MOVF   41,W
0559:  MOVWF  43
055A:  BCF    03.5
*
0657:  MOVF   78,F
0658:  BTFSC  03.2
0659:  GOTO   699
.................... 												{ 
.................... 													if (Bit_test (cur_val[byte_num], bit_num) ) 
065A:  BSF    03.5
065B:  MOVF   39,W
065C:  ADDWF  38,W
065D:  MOVWF  04
065E:  MOVF   00,W
065F:  MOVWF  3B
0660:  MOVWF  77
0661:  MOVF   37,W
0662:  MOVWF  78
0663:  BTFSS  03.2
0664:  GOTO   667
0665:  BCF    03.5
0666:  GOTO   66C
0667:  BCF    03.5
0668:  BCF    03.0
0669:  RRF    77,F
066A:  DECFSZ 78,F
066B:  GOTO   668
066C:  BTFSS  77.0
066D:  GOTO   682
.................... 														{ 
.................... 															Bit_set(prev_val[byte_num], bit_num); 
066E:  BSF    03.5
066F:  MOVF   3A,W
0670:  ADDWF  38,W
0671:  MOVWF  04
0672:  MOVLW  01
0673:  MOVWF  77
0674:  MOVF   37,W
0675:  MOVWF  78
0676:  BTFSS  03.2
0677:  GOTO   67A
0678:  BCF    03.5
0679:  GOTO   67F
067A:  BCF    03.5
067B:  BCF    03.0
067C:  RLF    77,F
067D:  DECFSZ 78,F
067E:  GOTO   67B
067F:  MOVF   77,W
0680:  IORWF  00,F
.................... 														} 
.................... 													else 
0681:  GOTO   696
.................... 														{ 
.................... 															Bit_clear(prev_val[byte_num], bit_num); 
0682:  BSF    03.5
0683:  MOVF   3A,W
0684:  ADDWF  38,W
0685:  MOVWF  04
0686:  MOVLW  01
0687:  MOVWF  77
0688:  MOVF   37,W
0689:  MOVWF  78
068A:  BTFSS  03.2
068B:  GOTO   68E
068C:  BCF    03.5
068D:  GOTO   693
068E:  BCF    03.5
068F:  BCF    03.0
0690:  RLF    77,F
0691:  DECFSZ 78,F
0692:  GOTO   68F
0693:  MOVF   77,W
0694:  XORLW  FF
0695:  ANDWF  00,F
.................... 														} 
....................                           ret = true; 
0696:  BSF    03.5
0697:  BSF    36.0
0698:  BCF    03.5
.................... 												} 
.................... 										} 
.................... 								} 
0699:  BSF    03.5
069A:  INCF   37,F
069B:  BCF    03.5
069C:  GOTO   4F1
.................... 						} 
069D:  BSF    03.5
069E:  INCF   38,F
069F:  BCF    03.5
06A0:  GOTO   4E6
.................... 				} 
.................... 			 
.................... 		} 
....................  
....................   return ret; 
06A1:  MOVLW  00
06A2:  BSF    03.5
06A3:  BTFSC  36.0
06A4:  MOVLW  01
06A5:  MOVWF  78
06A6:  BCF    03.5
06A7:  RETLW  00
.................... } 
.................... 
....................  
....................  
....................  
....................  
....................  
.................... // LED timers 
.................... int16 watchdog_flash_count = 0; // when becomes zero, changes state of LED 
.................... short watchdog_led = 0; 
.................... short overflow_val = 0; 
....................  
....................  
.................... void BlinkWatchdog() 
.................... { 
....................   if (overflow_val != InOverflow()) 
*
0F7A:  MOVLW  00
0F7B:  BTFSC  29.4
0F7C:  MOVLW  01
0F7D:  BSF    03.5
0F7E:  MOVWF  35
0F7F:  BCF    03.5
*
0F84:  MOVF   78,W
0F85:  BSF    03.5
0F86:  SUBWF  35,W
0F87:  BTFSS  03.2
0F88:  GOTO   78B
0F89:  BCF    03.5
0F8A:  GOTO   79A
0F8B:  BCF    03.5
....................     { 
....................     overflow_val = InOverflow(); 
*
0F90:  MOVF   78,F
0F91:  BTFSS  03.2
0F92:  GOTO   795
0F93:  BCF    29.4
0F94:  GOTO   796
0F95:  BSF    29.4
....................     watchdog_flash_count = 0; 
0F96:  BSF    03.5
0F97:  CLRF   33
0F98:  CLRF   32
0F99:  BCF    03.5
....................     } 
....................  
....................   if (!watchdog_flash_count) 
0F9A:  BSF    03.5
0F9B:  MOVF   32,W
0F9C:  IORWF  33,W
0F9D:  BTFSC  03.2
0F9E:  GOTO   7A1
0F9F:  BCF    03.5
0FA0:  GOTO   7E6
0FA1:  BCF    03.5
....................     { 
....................     watchdog_led = ~watchdog_led; 
0FA2:  MOVLW  08
0FA3:  XORWF  29,F
....................     SetWatchdogLed (watchdog_led); 
0FA4:  MOVLW  00
0FA5:  BTFSC  29.3
0FA6:  MOVLW  01
0FA7:  BSF    03.5
0FA8:  MOVWF  35
0FA9:  MOVWF  36
0FAA:  BCF    03.5
....................      
....................     if (InOverflow()) 
*
0FBE:  MOVF   78,F
0FBF:  BTFSC  03.2
0FC0:  GOTO   7C7
....................       { 
....................       watchdog_flash_count = WATCHDOG_OVERFLOW_COUNT; 
0FC1:  BSF    03.5
0FC2:  CLRF   33
0FC3:  MOVLW  FF
0FC4:  MOVWF  32
....................       } 
....................  
....................     else 
0FC5:  BCF    03.5
0FC6:  GOTO   7CD
....................       { 
....................       watchdog_flash_count = WATCHDOG_NORMAL_COUNT; 
0FC7:  MOVLW  13
0FC8:  BSF    03.5
0FC9:  MOVWF  33
0FCA:  MOVLW  88
0FCB:  MOVWF  32
0FCC:  BCF    03.5
....................       } 
....................  
.................... 		if (!ClearRxFlag()) // then we are locked inside a merge 
*
0FDC:  MOVF   78,F
0FDD:  BTFSS  03.2
0FDE:  GOTO   7E5
.................... 			{ 
.................... 				InitialiseMidiStatus(); 
0FDF:  BCF    0A.3
0FE0:  CALL   6A8
0FE1:  BSF    0A.3
....................  
.................... 				InitialiseInQueue(); 
0FE2:  BCF    0A.3
0FE3:  CALL   6B2
0FE4:  BSF    0A.3
.................... 			} 
....................     } 
....................   else 
0FE5:  GOTO   7EC
....................     { 
....................     watchdog_flash_count--; 
0FE6:  BSF    03.5
0FE7:  MOVF   32,W
0FE8:  BTFSC  03.2
0FE9:  DECF   33,F
0FEA:  DECF   32,F
0FEB:  BCF    03.5
....................     } 
0FEC:  BCF    0A.3
0FED:  BSF    0A.4
0FEE:  GOTO   45E (RETURN)
.................... } 
....................  
.................... void GenerateResetConfigData() 
.................... { 
.................... 	// configure analog in first 
.................... 	str_midiconfig config; 
.................... 	int i; 
....................   byte outval; 
....................  
.................... 	for (i = 0; i < MAX_INPUT_CHAN; i++) 
*
116B:  BSF    03.5
116C:  CLRF   39
116D:  BCF    03.5
116E:  BSF    03.5
116F:  MOVF   39,W
1170:  SUBLW  0F
1171:  BTFSC  03.0
1172:  GOTO   175
1173:  BCF    03.5
1174:  GOTO   23D
1175:  BCF    03.5
.................... 		{ 
....................       restart_wdt(); 
1176:  CLRWDT
.................... 			ReadAnalogueInConfig (&config, i); 
1177:  MOVLW  B5
1178:  BSF    03.5
1179:  MOVWF  4C
117A:  MOVF   39,W
117B:  MOVWF  4D
117C:  BCF    03.5
....................       if (config.config_flag & PRESET_VALUE_FLAG) 
*
1186:  BSF    03.5
1187:  MOVF   38,W
1188:  ANDLW  10
1189:  XORLW  00
118A:  BTFSS  03.2
118B:  GOTO   18E
118C:  BCF    03.5
118D:  GOTO   239
118E:  BCF    03.5
....................       { 
....................         OutputMidi (&config); 
118F:  MOVLW  B5
1190:  BSF    03.5
1191:  MOVWF  4F
1192:  BCF    03.5
....................       } 
.................... 		} 
*
1239:  BSF    03.5
123A:  INCF   39,F
123B:  BCF    03.5
123C:  GOTO   16E
....................  
....................  
.................... 	for (i = 0; i < MAX_INPUT_CHAN; i++) 
123D:  BSF    03.5
123E:  CLRF   39
123F:  BCF    03.5
1240:  BSF    03.5
1241:  MOVF   39,W
1242:  SUBLW  0F
1243:  BTFSC  03.0
1244:  GOTO   247
1245:  BCF    03.5
1246:  GOTO   312
1247:  BCF    03.5
.................... 		{ 
....................       restart_wdt(); 
1248:  CLRWDT
.................... 			ReadDigitalInConfig (&config, i); 
1249:  MOVLW  B5
124A:  BSF    03.5
124B:  MOVWF  49
124C:  MOVF   39,W
124D:  MOVWF  4A
124E:  BCF    03.5
....................  
....................       if (config.config_flag & PRESET_VALUE_FLAG) 
*
125B:  BSF    03.5
125C:  MOVF   38,W
125D:  ANDLW  10
125E:  XORLW  00
125F:  BTFSS  03.2
1260:  GOTO   263
1261:  BCF    03.5
1262:  GOTO   30E
1263:  BCF    03.5
....................       { 
....................         OutputMidi (&config); 
1264:  MOVLW  B5
1265:  BSF    03.5
1266:  MOVWF  4F
1267:  BCF    03.5
....................       } 
.................... 		} 
*
130E:  BSF    03.5
130F:  INCF   39,F
1310:  BCF    03.5
1311:  GOTO   240
....................  
.................... 	for (i = 0; i < MAX_ANAOUTPUT_CHAN; i++) 
1312:  BSF    03.5
1313:  CLRF   39
1314:  BCF    03.5
1315:  BSF    03.5
1316:  MOVF   39,W
1317:  SUBLW  07
1318:  BTFSC  03.0
1319:  GOTO   31C
131A:  BCF    03.5
131B:  GOTO   368
131C:  BCF    03.5
.................... 		{ 
....................       restart_wdt(); 
131D:  CLRWDT
.................... 			ReadAnalogueOutConfig (&config, i); 
131E:  MOVLW  B5
131F:  BSF    03.5
1320:  MOVWF  5F
1321:  MOVF   39,W
1322:  MOVWF  60
1323:  BCF    03.5
....................  
....................       if (config.config_flag & PRESET_VALUE_FLAG) 
*
1330:  BSF    03.5
1331:  MOVF   38,W
1332:  ANDLW  10
1333:  XORLW  00
1334:  BTFSS  03.2
1335:  GOTO   338
1336:  BCF    03.5
1337:  GOTO   364
1338:  BCF    03.5
....................       { 
....................           if (DATA_1_VARY_MASK & config.config_flag) 
1339:  BSF    03.5
133A:  MOVF   38,W
133B:  ANDLW  01
133C:  XORLW  00
133D:  BTFSS  03.2
133E:  GOTO   341
133F:  BCF    03.5
1340:  GOTO   347
1341:  BCF    03.5
....................             { 
.................... 					  outval = config.data_1;   
1342:  BSF    03.5
1343:  MOVF   36,W
1344:  MOVWF  3A
....................             } 
....................           else 
1345:  BCF    03.5
1346:  GOTO   34B
....................             { 
.................... 					  outval = config.data_2;   
1347:  BSF    03.5
1348:  MOVF   37,W
1349:  MOVWF  3A
134A:  BCF    03.5
....................             } 
....................  
....................           if (INVERT_VALUE_MASK & config.config_flag) 
134B:  BSF    03.5
134C:  MOVF   38,W
134D:  ANDLW  02
134E:  XORLW  00
134F:  BTFSS  03.2
1350:  GOTO   353
1351:  BCF    03.5
1352:  GOTO   358
1353:  BCF    03.5
....................             { 
....................             outval ^= 0x7f; // flip all but msb 
1354:  MOVLW  7F
1355:  BSF    03.5
1356:  XORWF  3A,F
1357:  BCF    03.5
....................             } 
....................  
....................           GenerateAnalogueOutput (i, outval << 1); // multiply by 2 
1358:  BCF    03.0
1359:  BSF    03.5
135A:  RLF    3A,W
135B:  MOVWF  3B
135C:  MOVF   39,W
135D:  MOVWF  63
135E:  MOVF   3B,W
135F:  MOVWF  64
1360:  BCF    03.5
1361:  BCF    0A.4
1362:  CALL   32F
1363:  BSF    0A.4
....................  
....................       } 
....................  
.................... 		} 
1364:  BSF    03.5
1365:  INCF   39,F
1366:  BCF    03.5
1367:  GOTO   315
....................  
.................... 	for (i = 0; i < MAX_DIGOUTPUT_CHAN; i++) 
1368:  BSF    03.5
1369:  CLRF   39
136A:  BCF    03.5
136B:  BSF    03.5
136C:  MOVF   39,W
136D:  SUBLW  0F
136E:  BTFSC  03.0
136F:  GOTO   372
1370:  BCF    03.5
1371:  GOTO   3BB
1372:  BCF    03.5
.................... 		{ 
....................       restart_wdt(); 
1373:  CLRWDT
.................... 			ReadDigitalOutConfig (&config, i); 
1374:  MOVLW  B5
1375:  BSF    03.5
1376:  MOVWF  5F
1377:  MOVF   39,W
1378:  MOVWF  60
1379:  BCF    03.5
....................  
....................       if (config.config_flag & PRESET_VALUE_FLAG) 
*
1386:  BSF    03.5
1387:  MOVF   38,W
1388:  ANDLW  10
1389:  XORLW  00
138A:  BTFSS  03.2
138B:  GOTO   38E
138C:  BCF    03.5
138D:  GOTO   3B7
138E:  BCF    03.5
....................       { 
....................  
....................           if (DATA_1_VARY_MASK & config.config_flag) 
138F:  BSF    03.5
1390:  MOVF   38,W
1391:  ANDLW  01
1392:  XORLW  00
1393:  BTFSS  03.2
1394:  GOTO   397
1395:  BCF    03.5
1396:  GOTO   39D
1397:  BCF    03.5
....................             { 
.................... 					  outval = config.data_1;   
1398:  BSF    03.5
1399:  MOVF   36,W
139A:  MOVWF  3A
....................             } 
....................           else 
139B:  BCF    03.5
139C:  GOTO   3A1
....................             { 
.................... 					  outval = config.data_2;   
139D:  BSF    03.5
139E:  MOVF   37,W
139F:  MOVWF  3A
13A0:  BCF    03.5
....................             } 
....................            
....................           if (INVERT_VALUE_MASK & config.config_flag) 
13A1:  BSF    03.5
13A2:  MOVF   38,W
13A3:  ANDLW  02
13A4:  XORLW  00
13A5:  BTFSS  03.2
13A6:  GOTO   3A9
13A7:  BCF    03.5
13A8:  GOTO   3AE
13A9:  BCF    03.5
....................             { 
....................             outval ^= 0x7f; // flip all but msb 
13AA:  MOVLW  7F
13AB:  BSF    03.5
13AC:  XORWF  3A,F
13AD:  BCF    03.5
....................             } 
....................  
....................              
.................... 					GenerateDigitalOutput (i, outval); 
13AE:  BSF    03.5
13AF:  MOVF   39,W
13B0:  MOVWF  5F
13B1:  MOVF   3A,W
13B2:  MOVWF  60
13B3:  BCF    03.5
13B4:  BCF    0A.4
13B5:  CALL   37E
13B6:  BSF    0A.4
....................       } 
.................... 		} 
13B7:  BSF    03.5
13B8:  INCF   39,F
13B9:  BCF    03.5
13BA:  GOTO   36B
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void ResetController () 
.................... { 
....................   disable_interrupts(GLOBAL); 
*
1000:  BCF    0B.6
1001:  BCF    0B.7
1002:  BTFSC  0B.7
1003:  GOTO   001
.................... #ifndef _SIMULATE 
....................   ValidateStoredConfig(); 
....................   InitialiseWatchdog(); 
.................... #endif 
....................  
.................... #ifdef _USE_OUT_BUFFER 
.................... 	InitialiseOutQueue(); 
.................... #endif 
....................  
.................... 	InitialiseAnalogueIn(); 
.................... 	ProcessDigitalInputs(false);			 
*
1159:  BSF    03.5
115A:  CLRF   35
115B:  BCF    03.5
115C:  BCF    0A.4
115D:  CALL   447
115E:  BSF    0A.4
.................... 	InitialiseDigitalOut(); 
....................   InitialiseMidiStatus(); 
*
1168:  BCF    0A.4
1169:  CALL   6A8
116A:  BSF    0A.4
....................  
....................   GenerateResetConfigData(); 
....................   InitialiseInQueue(); 
*
13BB:  BCF    0A.4
13BC:  CALL   6B2
13BD:  BSF    0A.4
....................   enable_interrupts(GLOBAL); 
13BE:  MOVLW  C0
13BF:  IORWF  0B,F
13C0:  BCF    0A.3
13C1:  BSF    0A.4
13C2:  GOTO   3FD (RETURN)
....................  
.................... } 
....................  
.................... main() { 
*
13F8:  MOVLW  61
13F9:  BSF    03.5
13FA:  MOVWF  34
.................... 	char c = 'a'; 
*
13C3:  CLRF   04
13C4:  MOVLW  1F
13C5:  ANDWF  03,F
13C6:  MOVLW  9F
13C7:  MOVWF  04
13C8:  MOVLW  07
13C9:  MOVWF  00
13CA:  CLRF   28
13CB:  MOVLW  09
13CC:  BSF    03.5
13CD:  MOVWF  19
13CE:  MOVLW  22
13CF:  MOVWF  18
13D0:  MOVLW  90
13D1:  BCF    03.5
13D2:  MOVWF  18
13D3:  BCF    29.1
13D4:  MOVLW  FF
13D5:  MOVWF  54
13D6:  BCF    54.5
13D7:  MOVF   54,W
13D8:  BSF    03.5
13D9:  MOVWF  07
13DA:  BCF    03.5
13DB:  BSF    07.5
13DC:  MOVLW  09
13DD:  BSF    03.5
13DE:  MOVWF  19
13DF:  MOVLW  22
13E0:  MOVWF  18
13E1:  MOVLW  90
13E2:  BCF    03.5
13E3:  MOVWF  18
13E4:  MOVLW  09
13E5:  BSF    03.5
13E6:  MOVWF  19
13E7:  MOVLW  22
13E8:  MOVWF  18
13E9:  MOVLW  90
13EA:  BCF    03.5
13EB:  MOVWF  18
13EC:  BCF    54.5
13ED:  MOVF   54,W
13EE:  BSF    03.5
13EF:  MOVWF  07
13F0:  BCF    03.5
13F1:  BSF    07.5
13F2:  BSF    03.5
13F3:  CLRF   32
13F4:  CLRF   33
13F5:  BCF    03.5
13F6:  BCF    29.3
13F7:  BCF    29.4
....................  
.................... 	ResetController (); 
*
13FB:  BCF    03.5
13FC:  GOTO   000
....................    do { 
.................... 				current_ana_state.current_chan = NUM_ANALOGUE_IN_CHANS; 
13FD:  MOVLW  E0
13FE:  ANDWF  75,W
13FF:  IORLW  10
1400:  MOVWF  75
.................... 				do { 
.................... 					current_ana_state.current_chan--; 
1401:  MOVF   75,W
1402:  ADDLW  1F
1403:  ANDLW  1F
1404:  MOVWF  77
1405:  MOVLW  E0
1406:  ANDWF  75,W
1407:  IORWF  77,W
1408:  MOVWF  75
.................... 					SetAnaChannel(); 
1409:  BCF    0A.4
140A:  GOTO   6BE
140B:  BSF    0A.4
.................... 				  ProcessDigitalInputs(true);			 
140C:  MOVLW  01
140D:  BSF    03.5
140E:  MOVWF  35
140F:  BCF    03.5
1410:  BCF    0A.4
1411:  CALL   447
1412:  BSF    0A.4
.................... 		      ProcessAnalogueIn(); 
1413:  BSF    0A.3
1414:  GOTO   000
1415:  BCF    0A.3
.................... 					restart_wdt(); 
1416:  CLRWDT
....................  
.................... 	  	}while (current_ana_state.current_chan); 
1417:  MOVF   75,W
1418:  ANDLW  1F
1419:  XORLW  00
141A:  BTFSS  03.2
141B:  GOTO   401
....................  
.................... 			WriteBlueTooth (c); 
141C:  BSF    03.5
141D:  MOVF   34,W
141E:  MOVWF  35
141F:  BCF    03.5
.................... 			c++; 
*
142D:  BSF    03.5
142E:  INCF   34,F
.................... 			if (c == 'z')  
142F:  MOVF   34,W
1430:  SUBLW  7A
1431:  BTFSC  03.2
1432:  GOTO   435
1433:  BCF    03.5
1434:  GOTO   45A
1435:  BCF    03.5
.................... 			{ 
.................... 				c = 'a'; 
1436:  MOVLW  61
1437:  BSF    03.5
1438:  MOVWF  34
.................... 				WriteBlueTooth ('\r'); 
1439:  MOVLW  0D
143A:  MOVWF  35
143B:  BCF    03.5
.................... 				WriteBlueTooth ('\n'); 
*
1449:  MOVLW  0A
144A:  BSF    03.5
144B:  MOVWF  35
144C:  BCF    03.5
.................... 			} 
.................... 			restart_wdt(); 
*
145A:  CLRWDT
....................       BlinkWatchdog(); 
145B:  BCF    0A.4
145C:  BSF    0A.3
145D:  GOTO   77A
145E:  BSF    0A.4
145F:  BCF    0A.3
....................       ProcessMidiInputStream();  
1460:  BCF    0A.4
1461:  BSF    0A.3
1462:  CALL   000
1463:  BSF    0A.4
1464:  BCF    0A.3
....................    } while (TRUE); 
1465:  GOTO   3FD
....................  
.................... } 
....................  
1466:  SLEEP
....................  
.................... int ReadAnaResolution() 
.................... { 
.................... 	str_midiconfig midi_msg; 
.................... 	ReadAnalogueInConfig (&midi_msg, current_ana_state.current_chan); 
*
0795:  MOVF   75,W
0796:  ANDLW  1F
0797:  BSF    03.5
0798:  MOVWF  4B
0799:  MOVLW  C7
079A:  MOVWF  4C
079B:  MOVF   4B,W
079C:  MOVWF  4D
079D:  BCF    03.5
.................... 	if ((midi_msg.status_chan & 0xF0)== 0xE0 || midi_msg.config_flag & HIGH_RES_DUAL_CHAN) 
*
07A5:  BSF    03.5
07A6:  MOVF   47,W
07A7:  ANDLW  F0
07A8:  SUBLW  E0
07A9:  BTFSS  03.2
07AA:  GOTO   7AD
07AB:  BCF    03.5
07AC:  GOTO   7B7
07AD:  BCF    03.5
07AE:  BSF    03.5
07AF:  MOVF   4A,W
07B0:  ANDLW  20
07B1:  XORLW  00
07B2:  BTFSS  03.2
07B3:  GOTO   7B6
07B4:  BCF    03.5
07B5:  GOTO   7BB
07B6:  BCF    03.5
.................... 	{   
.................... 		return 0; // leave at 10 bit 
07B7:  MOVLW  00
07B8:  MOVWF  78
07B9:  GOTO   7BE
.................... 	} 
.................... 	else 
07BA:  GOTO   7BE
.................... 	{ 
.................... 		return 3; //reduce to 7 bit 
07BB:  MOVLW  03
07BC:  MOVWF  78
07BD:  GOTO   7BE
.................... 	} 
07BE:  RETLW  00
.................... } 
.................... 
